ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 4.5.5 NumÃ©ros de sÃ©quence et acquittements

## Introduction

Les numÃ©ros de sÃ©quence et d'acquittement sont au cÅ“ur du mÃ©canisme de fiabilitÃ© de TCP. Ils permettent de :
- âœ… Garantir que toutes les donnÃ©es arrivent
- âœ… Remettre les donnÃ©es dans le bon ordre
- âœ… DÃ©tecter les pertes et les duplications
- âœ… Ã‰viter la confusion entre anciennes et nouvelles connexions

Contrairement Ã  ce que l'on pourrait penser intuitivement, TCP ne numÃ©rote pas les **segments** mais les **octets** individuels. Cette dÃ©cision architecturale, bien que plus complexe, offre une flexibilitÃ© et une prÃ©cision incomparables.

## Le principe fondamental : numÃ©rotation des octets

### Pourquoi numÃ©roter les octets ?

TCP considÃ¨re le flux de donnÃ©es comme une **sÃ©quence continue d'octets**, chacun ayant un numÃ©ro unique.

```
Flux de donnÃ©es Ã  transmettre :

Octets :  H  e  l  l  o     W  o  r  l  d  !
Position: 0  1  2  3  4  5  6  7  8  9  10 11

NumÃ©rotation TCP (si ISN = 1000) :
         1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011
Octets :  H    e    l    l    o    _    W    o    r    l    d    !
```

**Avantages de cette approche** :

```
1. FlexibilitÃ© de segmentation :
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Peut envoyer "Hello " dans un segment
   Puis "World!" dans un autre
   Ou tout dans un seul segment
   â†’ Les numÃ©ros restent cohÃ©rents

2. Retransmission prÃ©cise :
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Si perte de l'octet 1004-1007
   â†’ Peut retransmettre exactement ces octets
   â†’ Pas besoin de retransmettre tout le segment

3. Acquittement flexible :
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Peut acquitter n'importe quelle sÃ©quence d'octets
   Pas liÃ© Ã  la structure des segments
```

### Espace des numÃ©ros de sÃ©quence

Les numÃ©ros de sÃ©quence sont codÃ©s sur **32 bits** :

```
Plage : 0 Ã  4 294 967 295 (2^32 - 1)

En hexadÃ©cimal : 0x00000000 Ã  0xFFFFFFFF

AprÃ¨s 4 294 967 295, retour Ã  0 (wrap-around) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ... â†’ 4294967293 â†’ 4294967294 â†’      â”‚
â”‚       4294967295 â†’ 0 â†’ 1 â†’ 2 â†’ ...   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**CapacitÃ© thÃ©orique** :

```
Avec des segments de 1460 octets :
4 294 967 296 / 1460 â‰ˆ 2 941 622 segments

Volume total avant wrap-around :
4 294 967 296 octets = 4 Go

Ã€ 1 Gbps :
4 Go / 1 Gbps â‰ˆ 34 secondes avant wrap-around âš ï¸
```

**Protection contre le wrap-around** : Options PAWS (Protection Against Wrapped Sequences) avec timestamps TCP.

## NumÃ©ro de sÃ©quence (SEQ)

### DÃ©finition

Le champ **Sequence Number** dans l'en-tÃªte TCP indique le **numÃ©ro du premier octet** des donnÃ©es contenues dans ce segment.

```
Segment TCP :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEQ = 1000                             â”‚
â”‚ DonnÃ©es : "Hello" (5 octets)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Octets numÃ©rotÃ©s : 1000, 1001, 1002, 1003, 1004
                    H     e     l     l     o
```

### Initialisation : ISN (Initial Sequence Number)

Le premier numÃ©ro de sÃ©quence n'est **pas 0** mais choisi alÃ©atoirement.

```
Pourquoi alÃ©atoire ?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. SÃ©curitÃ© : Ã‰viter les attaques de prÃ©diction
2. Distinction : Ã‰viter confusion avec anciennes connexions

Exemple de 3-way handshake :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Client â†’ Serveur : SYN, SEQ=2847593012
Serveur â†’ Client : SYN-ACK, SEQ=1928374650, ACK=2847593013
Client â†’ Serveur : ACK, SEQ=2847593013, ACK=1928374651

PremiÃ¨re donnÃ©e du client : SEQ=2847593013
PremiÃ¨re donnÃ©e du serveur : SEQ=1928374651
```

### GÃ©nÃ©ration de l'ISN

MÃ©thode moderne (RFC 6528) :

```
ISN = M + F(localip, localport, remoteip, remoteport, secretkey)

OÃ¹ :
- M : Compteur qui s'incrÃ©mente toutes les 4 microsecondes
- F : Fonction de hachage cryptographique (MD5, SHA-256)
- secretkey : ClÃ© secrÃ¨te unique Ã  l'hÃ´te

Exemple simplifiÃ© :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Temps actuel : 15:30:45.123456
Base M = 3 890 765 432
Hash = SHA256(192.168.1.10, 54321, 93.184.216.34, 443, secret)
     = 0x3F8A2E1C (tronquÃ©)
ISN = (3 890 765 432 + 0x3F8A2E1C) mod 2^32
    = 2 847 593 012
```

### Consommation de numÃ©ros de sÃ©quence

Trois types de segments consomment des numÃ©ros :

```
1. DonnÃ©es :
   â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Segment avec N octets de donnÃ©es
   â†’ Consomme N numÃ©ros de sÃ©quence

   Exemple :
   SEQ=1000, DonnÃ©es="Hello" (5 octets)
   â†’ Consomme 1000-1004
   â†’ Prochain SEQ = 1005

2. SYN :
   â”€â”€â”€â”€â”€
   Segment SYN (sans donnÃ©es)
   â†’ Consomme 1 numÃ©ro de sÃ©quence

   Exemple :
   SYN, SEQ=1000
   â†’ Consomme 1000
   â†’ Prochain SEQ = 1001

3. FIN :
   â”€â”€â”€â”€â”€
   Segment FIN (sans donnÃ©es)
   â†’ Consomme 1 numÃ©ro de sÃ©quence

   Exemple :
   FIN, SEQ=5000
   â†’ Consomme 5000
   â†’ Prochain SEQ = 5001
```

**ACK pur ne consomme RIEN** :

```
Segment ACK sans donnÃ©es :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEQ = 1000                             â”‚
â”‚ ACK = 5000                             â”‚
â”‚ Flags : ACK (pas de donnÃ©es)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â†’ Ne consomme pas de numÃ©ro de sÃ©quence
â†’ Le prochain segment aura toujours SEQ=1000
   (jusqu'Ã  ce qu'on envoie des donnÃ©es)
```

## NumÃ©ro d'acquittement (ACK)

### DÃ©finition

Le champ **Acknowledgment Number** indique le **prochain numÃ©ro de sÃ©quence attendu** par le rÃ©cepteur.

```
Signification : ACK = X
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"J'ai bien reÃ§u tous les octets jusqu'Ã  X-1 inclus"
"J'attends maintenant l'octet numÃ©ro X"

Exemple :
â”€â”€â”€â”€â”€â”€â”€â”€
RÃ©cepteur envoie ACK=1005
â†’ A reÃ§u les octets 0-1004
â†’ Attend l'octet 1005
```

### Acquittement cumulatif

TCP utilise des **acquittements cumulatifs** : un seul ACK confirme la rÃ©ception de tous les octets jusqu'Ã  un certain point.

```
Ã‰metteur envoie :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Segment 1 : SEQ=1000, 100 octets (1000-1099)
Segment 2 : SEQ=1100, 100 octets (1100-1199)
Segment 3 : SEQ=1200, 100 octets (1200-1299)

RÃ©cepteur rÃ©pond :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACK=1300

Signification : "J'ai reÃ§u 1000-1299, j'attends 1300"
â†’ Un seul ACK pour 300 octets !
```

**Avantage** : RÃ©duit considÃ©rablement le trafic d'acquittement.

```
Sans acquittement cumulatif :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3 segments â†’ 3 ACK obligatoires

Avec acquittement cumulatif :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3 segments â†’ 1 ACK suffit
(Ã‰conomie de 66% du trafic ACK)
```

### Flag ACK

Le numÃ©ro d'acquittement n'est valide que si le **flag ACK est activÃ©**.

```
Segment avec flag ACK :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEQ = 1000                             â”‚
â”‚ ACK = 5000                             â”‚  â† Valide
â”‚ Flags : ACK = 1                        â”‚  â† Flag activÃ©
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Segment SYN initial (sans flag ACK) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEQ = 1000                             â”‚
â”‚ ACK = 0                                â”‚  â† IgnorÃ©
â”‚ Flags : SYN = 1, ACK = 0               â”‚  â† Pas d'ACK
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Exception** : Le premier segment SYN n'a pas le flag ACK (rien Ã  acquitter encore).

## Exemple complet de transmission

### ScÃ©nario : Transfert d'un fichier de 300 octets

```
Configuration :
- MSS = 100 octets (simplifiÃ© pour l'exemple)
- Client ISN = 1000
- Serveur ISN = 5000

Ã‰tape 0 : 3-way handshake
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Client â†’ Serveur : SYN, SEQ=1000
Serveur â†’ Client : SYN-ACK, SEQ=5000, ACK=1001
Client â†’ Serveur : ACK, SEQ=1001, ACK=5001

Ã‰tat initial Ã©tabli :
- Client : prochain octet Ã  envoyer = 1001
- Serveur : prochain octet Ã  envoyer = 5001

Ã‰tape 1 : Client envoie 100 octets
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T=0ms    Client                         Serveur
         â”‚                                 â”‚
         â”‚ SEQ=1001, 100 octets            â”‚
         â”‚ (octets 1001-1100)              â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
         â”‚                                 â”‚
         Prochain Ã  envoyer : 1101         Buffer : [1001-1100]
                                            Attend : 1101

Ã‰tape 2 : Serveur acquitte
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T=25ms   â”‚                                 â”‚
         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1101â”‚
         â”‚                                 â”‚
         âœ“ Octets 1001-1100 confirmÃ©s      Attend : 1101

Ã‰tape 3 : Client envoie 100 octets
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T=26ms   â”‚ SEQ=1101, 100 octets            â”‚
         â”‚ (octets 1101-1200)              â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
         â”‚                                 â”‚
         Prochain : 1201                   Buffer : [1001-1200]
                                            Attend : 1201

Ã‰tape 4 : Serveur acquitte
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T=51ms   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1201â”‚
         â”‚                                 â”‚
         âœ“ Octets 1101-1200 confirmÃ©s      Attend : 1201

Ã‰tape 5 : Client envoie 100 octets (derniers)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T=52ms   â”‚ SEQ=1201, 100 octets            â”‚
         â”‚ (octets 1201-1300)              â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
         â”‚                                 â”‚
         Prochain : 1301                   Buffer : [1001-1300]
         Fichier complet envoyÃ© !          Attend : 1301

Ã‰tape 6 : Serveur acquitte final
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T=77ms   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1301â”‚
         â”‚                                 â”‚
         âœ“ Transmission complÃ¨te !          âœ“ 300 octets reÃ§us
```

**RÃ©sumÃ©** :
- 3 segments de donnÃ©es (300 octets)
- 3 segments d'acquittement
- Total : 6 segments pour transfÃ©rer 300 octets
- EfficacitÃ© : 300 octets utiles / ~120 octets d'en-tÃªtes

## Perte de segments et retransmission

### ScÃ©nario : Perte d'un segment

```
Client envoie 3 segments de 100 octets chacun :

T=0ms    Client                         Serveur
         â”‚                                 â”‚
         â”‚ â‘  SEQ=1000, 100 octets         â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
         â”‚                                 â”‚ Buffer : [1000-1099]
         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1100â”‚ Attend : 1100
T=25ms   â”‚                                 â”‚
         â”‚ â‘¡ SEQ=1100, 100 octets         â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€X PERDU            â”‚
         â”‚                                 â”‚
         â”‚ â‘¢ SEQ=1200, 100 octets         â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
T=50ms   â”‚                                 â”‚
         â”‚                                 â”‚ Buffer : [1000-1099] [???] [1200-1299]
         â”‚                                 â”‚         âœ“          âŒ      âœ“
         â”‚                                 â”‚ Trou dÃ©tectÃ© !
         â”‚                                 â”‚ Attend toujours : 1100
         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1100â”‚ (duplicate ACK)
T=75ms   â”‚                                 â”‚
         â”‚                                 â”‚
         â”‚ â‘£ SEQ=1300, 100 octets         â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
T=100ms  â”‚                                 â”‚
         â”‚                                 â”‚ Buffer : [âœ“] [âŒ] [âœ“] [âœ“]
         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1100â”‚ (2e duplicate ACK)
         â”‚                                 â”‚
         â”‚ âš ï¸ 3 ACK dupliquÃ©s dÃ©tectÃ©s !   â”‚
         â”‚ Fast Retransmit !               â”‚
         â”‚                                 â”‚
         â”‚ SEQ=1100, 100 octets (retr.)    â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
T=125ms  â”‚                                 â”‚
         â”‚                                 â”‚ Buffer complet !
         â”‚                                 â”‚ [1000-1399]
         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1400â”‚
         â”‚                                 â”‚
         âœ“ Trou comblÃ© !                   âœ“ SÃ©quence continue
```

### Analyse des acquittements

```
ACK reÃ§us par le client :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. ACK=1100 (aprÃ¨s segment â‘ ) â†’ Normal
2. ACK=1100 (aprÃ¨s segment â‘¢) â†’ Duplicate 1 âš ï¸
3. ACK=1100 (aprÃ¨s segment â‘£) â†’ Duplicate 2 âš ï¸

RÃ¨gle TCP :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3 ACK dupliquÃ©s = Signal de perte
â†’ Fast Retransmit immÃ©diat
â†’ Pas besoin d'attendre le timeout
```

### Pourquoi 3 ACK dupliquÃ©s ?

```
Raison : Distinguer perte de rÃ©ordonnancement

ScÃ©nario 1 : Perte rÃ©elle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â‘  arrive â†’ ACK=1100
â‘¡ perdu
â‘¢ arrive â†’ ACK=1100 (dup 1)
â‘£ arrive â†’ ACK=1100 (dup 2)
â‘¤ arrive â†’ ACK=1100 (dup 3)
â†’ Vraiment perdu, retransmettre

ScÃ©nario 2 : RÃ©ordonnancement lÃ©ger
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â‘  arrive â†’ ACK=1100
â‘¢ arrive â†’ ACK=1100 (dup 1)
â‘¡ arrive (en retard) â†’ ACK=1300 âœ“
â†’ Pas de perte, juste du retard
```

**Compromis** :
- Trop peu de duplicates requis â†’ Retransmissions inutiles
- Trop de duplicates requis â†’ Retard dans la rÃ©cupÃ©ration
- 3 est un bon Ã©quilibre empirique

## Acquittements diffÃ©rÃ©s (Delayed ACK)

### Principe

Pour rÃ©duire le trafic, TCP ne rÃ©pond pas immÃ©diatement Ã  chaque segment reÃ§u.

```
Sans Delayed ACK :                Avec Delayed ACK :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Segment 1 â†’ ACK 1                Segment 1 â†’
Segment 2 â†’ ACK 2                Segment 2 â†’ ACK 1+2 combinÃ©
Segment 3 â†’ ACK 3                Segment 3 â†’
Segment 4 â†’ ACK 4                Segment 4 â†’ ACK 3+4 combinÃ©

8 segments total                  6 segments total
                                  RÃ©duction de 25% âœ“
```

### RÃ¨gles du Delayed ACK

```
1. Attendre jusqu'Ã  500ms avant d'envoyer un ACK
   OU
2. Envoyer aprÃ¨s 2 segments reÃ§us (maximum)
   OU
3. Envoyer immÃ©diatement si :
   - Segment hors sÃ©quence (dÃ©tection de perte)
   - Flag PSH activÃ©
   - DonnÃ©es Ã  envoyer (piggybacking)

Configuration Linux :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Timeout delayed ACK (millisecondes)
/proc/sys/net/ipv4/tcp_delack_min
```

### Exemple avec Delayed ACK

```
T=0ms    Client                         Serveur
         â”‚                                 â”‚
         â”‚ SEQ=1000, 100 octets            â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
         â”‚                                 â”‚
         â”‚                                 â”‚ ReÃ§u, dÃ©marre timer (200ms)
         â”‚                                 â”‚
         â”‚ SEQ=1100, 100 octets            â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
T=10ms   â”‚                                 â”‚
         â”‚                                 â”‚ ReÃ§u 2e segment
         â”‚                                 â”‚ â†’ Envoie ACK immÃ©diatement
         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1200â”‚
T=35ms   â”‚                                 â”‚
         â”‚                                 â”‚
         âœ“ Un seul ACK pour 200 octets
```

### Piggybacking

Combiner ACK avec des donnÃ©es :

```
Communication bidirectionnelle :

Client                         Serveur
   â”‚                               â”‚
   â”‚ SEQ=1000, 100 octets          â”‚
   â”‚ "RequÃªte HTTP"                â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                               â”‚
   â”‚                               â”‚ Traite la requÃªte
   â”‚                               â”‚ PrÃ©pare la rÃ©ponse
   â”‚                               â”‚
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
   â”‚ SEQ=5000, ACK=1100, donnÃ©es   â”‚  â† ACK + donnÃ©es
   â”‚ "RÃ©ponse HTTP"                â”‚     dans le mÃªme segment
   â”‚                               â”‚
   â”‚ SEQ=1100, ACK=5500            â”‚  â† ACK pur
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚

Ã‰conomie : 1 segment (ACK + donnÃ©es au lieu de 2 segments)
```

## Acquittements sÃ©lectifs (SACK)

### Limitation des ACK cumulatifs

```
ProblÃ¨me avec ACK cumulatifs :

Ã‰metteur envoie :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â‘  SEQ=1000, 100 octets
â‘¡ SEQ=1100, 100 octets â† PERDU
â‘¢ SEQ=1200, 100 octets
â‘£ SEQ=1300, 100 octets
â‘¤ SEQ=1400, 100 octets

RÃ©cepteur envoie :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACK=1100 (aprÃ¨s â‘ ) â†’ Normal
ACK=1100 (aprÃ¨s â‘¢) â†’ Duplicate
ACK=1100 (aprÃ¨s â‘£) â†’ Duplicate
ACK=1100 (aprÃ¨s â‘¤) â†’ Duplicate

Ã‰metteur sait :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Perte dÃ©tectÃ©e (3 dup ACK)
- Mais ne sait PAS si â‘¢â‘£â‘¤ sont arrivÃ©s
- Pourrait retransmettre â‘¡â‘¢â‘£â‘¤ (inefficace)
- Alors que seul â‘¡ est perdu
```

### Solution : SACK (Selective Acknowledgment)

SACK permet d'acquitter des **blocs discontinus**.

```
Avec SACK :

RÃ©cepteur envoie :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACK=1100, SACK=[1200-1500]

Signification :
"J'attends 1100, MAIS j'ai dÃ©jÃ  reÃ§u 1200-1499"

Ã‰metteur comprend :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Octets 1000-1099 : âœ“ ReÃ§us
- Octets 1100-1199 : âŒ Manquants
- Octets 1200-1499 : âœ“ DÃ©jÃ  reÃ§us

Action :
â”€â”€â”€â”€â”€â”€â”€â”€
Retransmettre SEULEMENT 1100-1199 âœ“
Pas besoin de retransmettre 1200-1499
```

### Format SACK

```
Option TCP SACK :
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ Kind â”‚ Len  â”‚ Left Edge 1â”‚ Right Edge 1â”‚ ... â”‚
â”‚  5   â”‚  N   â”‚  (4 bytes) â”‚  (4 bytes)  â”‚     â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

Exemple avec 2 blocs :
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5   â”‚  18  â”‚  1200  â”‚  1500  â”‚  1700  â”‚  1900  â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Signification :
"J'ai reÃ§u les blocs 1200-1499 ET 1700-1899"
```

### Exemple complet avec SACK

```
NÃ©gociation pendant handshake :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Client â†’ Serveur : SYN, SACK Permitted
Serveur â†’ Client : SYN-ACK, SACK Permitted
â†’ SACK activÃ© pour cette connexion

Transmission avec pertes :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T=0ms    Client                         Serveur
         â”‚                                 â”‚
         â”‚ â‘  SEQ=1000, 100 octets         â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
         â”‚                                 â”‚ Buffer : [1000-1099]
         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1100â”‚
T=25ms   â”‚                                 â”‚
         â”‚ â‘¡ SEQ=1100, 100 octets         â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€X PERDU            â”‚
         â”‚                                 â”‚
         â”‚ â‘¢ SEQ=1200, 100 octets         â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
T=50ms   â”‚                                 â”‚
         â”‚                                 â”‚ Buffer : [âœ“] [âŒ] [âœ“]
         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1100      â”‚
         â”‚                   SACK=1200-1300â”‚ â† Info prÃ©cise !
T=75ms   â”‚                                 â”‚
         â”‚ â‘£ SEQ=1300, 100 octets         â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
         â”‚                                 â”‚ Buffer : [âœ“] [âŒ] [âœ“] [âœ“]
         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1100      â”‚
         â”‚                   SACK=1200-1400â”‚
T=100ms  â”‚                                 â”‚
         â”‚ Sait que seul 1100-1199 manque  â”‚
         â”‚                                 â”‚
         â”‚ Retransmission SEQ=1100         â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
T=125ms  â”‚                                 â”‚
         â”‚                                 â”‚ Buffer complet !
         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1400â”‚
         â”‚                                 â”‚
```

**Avantage** : Ã‰conomie de bande passante

```
Sans SACK :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Retransmet : â‘¡ â‘¢ â‘£ (300 octets)
Car ne sait pas que â‘¢ â‘£ sont arrivÃ©s

Avec SACK :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Retransmet : â‘¡ seulement (100 octets)
Ã‰conomie : 66% de bande passante âœ“
```

## Cas particuliers et edge cases

### Cas 1 : Wrap-around des numÃ©ros de sÃ©quence

```
NumÃ©ros proches de la limite :

SEQ = 4294967290
DonnÃ©es : 10 octets (4294967290-4294967299)
Prochain SEQ = 4294967300 âŒ DÃ©passe 2^32

Wrap-around :
SEQ = 4294967290 (0xFFFFFFFA)
DonnÃ©es : 10 octets
Prochain SEQ = 4 (0x00000004) âœ“

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ... â†’ 4294967295 â†’ 0 â†’ 1 â†’ 2 â†’ 3 â†’ 4   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Comparaison avec wrap-around** :

```
Comment comparer SEQ=10 et SEQ=4294967290 ?

MÃ©thode naÃ¯ve (fausse) :
10 < 4294967290 â†’ 10 est plus ancien âŒ

MÃ©thode correcte (RFC 1323) :
ConsidÃ©rer la distance dans l'espace modulo 2^32

Si distance < 2^31 : A < B
Si distance > 2^31 : A > B (wrap-around)

Exemple :
Distance de 4294967290 Ã  10 :
= (10 - 4294967290) mod 2^32
= 20 (petit)
â†’ 10 est APRÃˆS 4294967290 âœ“
```

### Cas 2 : Segment de taille zÃ©ro

```
Segment sans donnÃ©es :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEQ = 1000                             â”‚
â”‚ ACK = 5000                             â”‚
â”‚ Flags : ACK                            â”‚
â”‚ DonnÃ©es : 0 octets                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Prochain SEQ : toujours 1000
(Pas de consommation de numÃ©ro)

Usage :
- ACK pur
- Window update (changement de fenÃªtre)
- Keep-alive
```

### Cas 3 : Retransmission partielle

```
Segment original :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SEQ=1000, 1000 octets (1000-1999)

Retransmission peut Ãªtre diffÃ©rente :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SEQ=1000, 500 octets (1000-1499)
SEQ=1500, 500 octets (1500-1999)

Ou mÃªme :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
SEQ=1000, 1400 octets (1000-1399)
(Si MSS a changÃ©)

Les numÃ©ros d'octets restent cohÃ©rents !
```

### Cas 4 : ACK pour des donnÃ©es futures

```
Situation anormale :

RÃ©cepteur attend SEQ=1000
ReÃ§oit ACK=2000 (pour donnÃ©es non envoyÃ©es)

RÃ©action :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Segment invalide â†’ IgnorÃ©
Ou envoi d'ACK challenge
```

### Cas 5 : Ancien segment retardÃ©

```
ProblÃ¨me : Segment d'une ancienne connexion arrive

Connexion 1 (terminÃ©e) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ISN = 1000
Segment en transit : SEQ=5000

Connexion 2 (mÃªme ports, nouvelle) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ISN = 2847593012

Protection :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. ISN alÃ©atoire â†’ peu probable mÃªme ISN
2. TIME-WAIT â†’ anciennes connexions expirÃ©es
3. Timestamps â†’ dÃ©tection segments anciens
4. Checksums â†’ dÃ©tection corruption
```

## NumÃ©rotation relative vs absolue

### Wireshark : numÃ©ros relatifs

Wireshark affiche des numÃ©ros **relatifs** par dÃ©faut (commence Ã  0) :

```
Capture rÃ©elle :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Segment 1 : SEQ=2847593012 (ISN)
Segment 2 : SEQ=2847593112
Segment 3 : SEQ=2847593212

Affichage Wireshark (relatif) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Segment 1 : SEQ=0 (relatif)
Segment 2 : SEQ=100 (relatif)
Segment 3 : SEQ=200 (relatif)

Plus facile Ã  lire ! âœ“
```

**Basculer vers numÃ©ros absolus** :

```
Wireshark :
Edit â†’ Preferences â†’ Protocols â†’ TCP
â˜ Relative sequence numbers
```

### Exemple de capture

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frame 42: Client â†’ Serveur [PSH, ACK]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Transmission Control Protocol
    Source Port: 54321
    Destination Port: 443
    Sequence number: 1 (relative)
    Sequence number (raw): 2847593013
    Next sequence number: 1461
    Acknowledgment number: 1 (relative)
    Acknowledgment number (raw): 1928374651
    Header Length: 20 bytes
    Flags: 0x018 (PSH, ACK)
    Window size value: 65535
    [SEQ/ACK analysis]
        [Bytes in flight: 1460]
        [Bytes sent since last PSH: 1460]
    TCP payload (1460 bytes)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frame 43: Serveur â†’ Client [ACK]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Transmission Control Protocol
    Sequence number: 1 (relative)
    Sequence number (raw): 1928374651
    Acknowledgment number: 1461 (relative)
    Acknowledgment number (raw): 2847594473
    [SEQ/ACK analysis]
        This is an ACK to the segment in frame: 42
        The RTT to ACK the segment was: 0.025 seconds
        [Bytes in flight: 0]
```

## Analyse de performance avec SEQ/ACK

### Calcul du dÃ©bit

```
Mesure basÃ©e sur SEQ/ACK :

T=0s     : SEQ=1000
T=1s     : SEQ=1001000

Octets envoyÃ©s : 1001000 - 1000 = 1 000 000 octets
DurÃ©e : 1 seconde
DÃ©bit : 1 000 000 octets/s = 8 Mbps
```

### DÃ©tection de retransmissions

```
Analyse Wireshark :

Frame 100 : SEQ=5000, Len=1460
Frame 101 : SEQ=6460, Len=1460
Frame 102 : SEQ=7920, Len=1460
Frame 103 : SEQ=5000, Len=1460  â† MÃªme SEQ que Frame 100 !

[TCP Analysis Flags]
    [TCP Retransmission] âš ï¸
    [This is a retransmission of segment in frame: 100]
    [The RTO for this segment was: 0.200 seconds]
```

### Mesure du RTT

```
BasÃ© sur timestamps SEQ/ACK :

T=0.000s : Client envoie SEQ=1000
T=0.025s : Client reÃ§oit ACK=1461
RTT = 25 ms

Wireshark calcule automatiquement :
[SEQ/ACK analysis]
    [RTT: 0.025 seconds]
    [RTT Variance: 0.003 seconds]
```

## Optimisations et tuning

### FenÃªtre de rÃ©ception et SEQ/ACK

```
Impact de la fenÃªtre sur le dÃ©bit :

Window = 64 Ko, RTT = 100 ms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DÃ©bit max thÃ©orique :
= Window / RTT
= 65536 / 0.1
= 655 360 octets/s
â‰ˆ 5.2 Mbps

Pour 1 Gbps avec RTT=100ms :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Window requise :
= DÃ©bit Ã— RTT
= 1 Gbps Ã— 0.1s
= 100 Mb = 12.5 Mo
NÃ©cessite Window Scale !
```

### Bandwidth-Delay Product (BDP)

```
BDP = Bande passante Ã— RTT

Exemple : Liaison 100 Mbps, RTT 50ms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BDP = 100 Mbps Ã— 0.05s
    = 5 Mb = 625 Ko

Signification :
625 Ko de donnÃ©es peuvent Ãªtre "en vol"
Pour saturer la bande passante,
la fenÃªtre doit Ãªtre â‰¥ 625 Ko
```

## Debugging et diagnostic

### Commandes utiles

```bash
# Capture avec tcpdump (SEQ/ACK)
tcpdump -i eth0 -nn -v 'tcp port 443'

# Sortie exemple :
# 10:30:45.123 IP 192.168.1.10.54321 > 93.184.216.34.443:
#   Flags [.], seq 1000:1460, ack 5000, win 65535, length 1460

# Analyse avec ss (Socket Statistics)
ss -tin
# Affiche :
# - SEQ numbers
# - Send buffer
# - Retransmissions

# Exemple de sortie :
# tcp   ESTAB  0  0  192.168.1.10:54321  93.184.216.34:443
#       ts sack cubic wscale:7,7 rto:204 rtt:3.5/1.75
#       send 11.4Mbps lastsnd:1 lastrcv:1 lastack:1
#       bytes_acked:123456 bytes_received:654321
#       segs_out:789 segs_in:456
#       data_segs_out:678 data_segs_in:345
#       send 11.4Mbps pacing_rate 22.8Mbps
#       rcv_space:29200 rcv_ssthresh:29200
#       notsent:0 minrtt:3.5
```

### ProblÃ¨mes courants

#### ProblÃ¨me 1 : ACK dupliquÃ©s constants

```bash
# SymptÃ´me dans Wireshark
[TCP Dup ACK] apparaÃ®t frÃ©quemment

Causes possibles :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Pertes de paquets (congestion, erreurs)
2. RÃ©ordonnancement excessif
3. ProblÃ¨me de routage

Diagnostic :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Statistiques de retransmission
ss -s
# TCP: 100 (estab 80, retrans 20)
# Si taux de retrans > 5% â†’ ProblÃ¨me
```

#### ProblÃ¨me 2 : Retransmissions excessives

```bash
# VÃ©rifier les retransmissions
netstat -s | grep retransmit
# 12345 segments retransmitted

# Ratio acceptable : < 1% des segments

Causes :
â”€â”€â”€â”€â”€â”€â”€â”€
- Congestion rÃ©seau
- MTU mismatch
- ProblÃ¨mes matÃ©riels
```

#### ProblÃ¨me 3 : SÃ©quence invalide

```
Log Wireshark :
[TCP Previous segment not captured]
[TCP Out-Of-Order]
[TCP Spurious Retransmission]

Action :
â”€â”€â”€â”€â”€â”€â”€â”€
Examiner la sÃ©quence SEQ/ACK
Identifier les trous
VÃ©rifier si rÃ©ordonnancement ou perte
```

## ImplÃ©mentation : pseudo-code

### Ã‰metteur

```python
class TCPSender:
    def __init__(self):
        self.seq = random_isn()  # ISN alÃ©atoire
        self.send_buffer = []
        self.unacked_segments = {}

    def send(self, data):
        """Envoie des donnÃ©es"""
        # CrÃ©er segment
        segment = TCPSegment(
            seq=self.seq,
            data=data,
            length=len(data)
        )

        # Envoyer
        send_to_network(segment)

        # Sauvegarder pour retransmission Ã©ventuelle
        self.unacked_segments[self.seq] = segment

        # IncrÃ©menter SEQ
        self.seq += len(data)

        # DÃ©marrer timer
        start_retransmission_timer(segment.seq)

    def receive_ack(self, ack_num):
        """Traite un acquittement"""
        # Acquittement cumulatif : tous les octets < ack_num
        for seq in list(self.unacked_segments.keys()):
            if seq < ack_num:
                # Segment acquittÃ©
                del self.unacked_segments[seq]
                cancel_timer(seq)

    def timeout(self, seq):
        """Timeout : retransmettre"""
        if seq in self.unacked_segments:
            segment = self.unacked_segments[seq]
            send_to_network(segment)  # Retransmission
            restart_timer(seq)
```

### RÃ©cepteur

```python
class TCPReceiver:
    def __init__(self):
        self.expected_seq = None  # Prochain octet attendu
        self.receive_buffer = {}  # Buffer pour rÃ©ordonnancement

    def receive(self, segment):
        """ReÃ§oit un segment"""
        seq = segment.seq
        data = segment.data
        length = len(data)

        if seq == self.expected_seq:
            # Segment dans l'ordre
            deliver_to_application(data)
            self.expected_seq += length

            # VÃ©rifier buffer pour segments suivants
            self.check_buffer()

            # Envoyer ACK
            send_ack(self.expected_seq)

        elif seq > self.expected_seq:
            # Segment futur (trou dÃ©tectÃ©)
            self.receive_buffer[seq] = data

            # ACK duplicate (signal de perte)
            send_ack(self.expected_seq)

        else:
            # seq < expected : ancien segment ou duplicate
            # Ignorer, mais ACK quand mÃªme
            send_ack(self.expected_seq)

    def check_buffer(self):
        """VÃ©rifie si des segments dans le buffer sont consÃ©cutifs"""
        while self.expected_seq in self.receive_buffer:
            data = self.receive_buffer[self.expected_seq]
            deliver_to_application(data)
            del self.receive_buffer[self.expected_seq]
            self.expected_seq += len(data)
```

## Conclusion

Les numÃ©ros de sÃ©quence et d'acquittement sont les fondations de la fiabilitÃ© de TCP. Leur conception Ã©lÃ©gante permet :

**âœ… Avantages** :
- NumÃ©rotation prÃ©cise de chaque octet
- DÃ©tection fiable des pertes
- RÃ©ordonnancement transparent
- FlexibilitÃ© de segmentation
- Support de SACK pour optimisation

**ğŸ¯ Points clÃ©s Ã  retenir** :

1. **NumÃ©rotation des octets** : Chaque octet a un numÃ©ro unique
2. **SEQ** : Indique le premier octet du segment
3. **ACK** : Indique le prochain octet attendu (cumulatif)
4. **ISN alÃ©atoire** : SÃ©curitÃ© et distinction des connexions
5. **Consommation** : DonnÃ©es (N octets), SYN (1), FIN (1), ACK pur (0)
6. **Fast Retransmit** : 3 ACK dupliquÃ©s dÃ©clenchent retransmission
7. **SACK** : Acquittements sÃ©lectifs pour blocs discontinus
8. **Delayed ACK** : Optimisation du trafic (max 2 segments ou 500ms)

**Implications pratiques** :

```
Pour les dÃ©veloppeurs :
- Comprendre les traces rÃ©seau
- Diagnostiquer les problÃ¨mes de performance
- Optimiser les configurations

Pour les administrateurs :
- Tuner les paramÃ¨tres TCP
- Identifier les goulots d'Ã©tranglement
- RÃ©soudre les problÃ¨mes de retransmission

Pour les architectes :
- Dimensionner les systÃ¨mes
- Choisir les bons protocoles
- Concevoir des systÃ¨mes rÃ©silients
```

La maÃ®trise des SEQ/ACK est essentielle pour comprendre et optimiser les performances rÃ©seau. C'est la clÃ© pour passer d'une utilisation basique de TCP Ã  une vÃ©ritable expertise.

Dans la prochaine section, nous explorerons la **fenÃªtre glissante**, mÃ©canisme qui permet Ã  TCP d'optimiser le dÃ©bit en envoyant plusieurs segments avant d'attendre les acquittements.

---

**Prochaine section** : 4.5.6 FenÃªtre glissante (sliding window)

â­ï¸ [FenÃªtre glissante (sliding window)](/04-couche-transport/05.6-tcp-fenetre-glissante.md)
