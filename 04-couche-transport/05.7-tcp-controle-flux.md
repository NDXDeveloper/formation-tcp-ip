ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 4.5.7 ContrÃ´le de flux

## Introduction

Le **contrÃ´le de flux** (flow control) est le mÃ©canisme par lequel TCP empÃªche un Ã©metteur rapide de submerger un rÃ©cepteur lent. C'est l'un des deux mÃ©canismes de contrÃ´le de TCP, distinct mais complÃ©mentaire au contrÃ´le de congestion.

```
Deux mÃ©canismes de contrÃ´le distincts :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ContrÃ´le de FLUX (Flow Control) :
â””â”€ ProtÃ¨ge le RÃ‰CEPTEUR
   â””â”€ Ã‰vite la saturation du buffer de rÃ©ception
      â””â”€ BasÃ© sur rwnd (receive window)

ContrÃ´le de CONGESTION (Congestion Control) :
â””â”€ ProtÃ¨ge le RÃ‰SEAU
   â””â”€ Ã‰vite la saturation des routeurs
      â””â”€ BasÃ© sur cwnd (congestion window)
```

**FenÃªtre effective** :

```
Window = min(rwnd, cwnd)
             â”‚      â”‚
             â”‚      â””â”€ Limitation rÃ©seau (congestion)
             â””â”€â”€â”€â”€â”€â”€â”€â”€ Limitation rÃ©cepteur (flux)
```

Dans cette section, nous nous concentrons exclusivement sur le **contrÃ´le de flux** et la gestion de **rwnd**.

## Le problÃ¨me Ã  rÃ©soudre

### ScÃ©nario sans contrÃ´le de flux

```
Ã‰metteur rapide (1 Gbps)          RÃ©cepteur lent (100 Mbps)
     â”‚                                      â”‚
     â”‚                                      â”‚ Buffer : 64 Ko
     â”‚                                      â”‚
     â”‚ â•â•â• DonnÃ©es Ã  1 Gbps â•â•â•â•â•â•â•â•â•â•â•â•â•â•> â”‚
     â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•> â”‚ ğŸ’¥ Overflow !
     â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•> â”‚
     â”‚                                      â”‚
     â”‚                                      â”‚ DonnÃ©es perdues
     â”‚                                      â”‚ Buffer plein
     â”‚                                      â”‚ Application ne lit pas assez vite
```

**ConsÃ©quences** :
- ğŸ’€ Perte de donnÃ©es (dÃ©bordement de buffer)
- ğŸ”„ Retransmissions inutiles
- ğŸ“‰ Performance dÃ©gradÃ©e
- âš¡ Gaspillage de bande passante

### Le besoin de rÃ©gulation

```
Ce qu'il faut :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Le rÃ©cepteur doit pouvoir dire "STOP"
2. L'Ã©metteur doit respecter cette limite
3. MÃ©canisme dynamique (buffer se vide/remplit)
4. Pas de perte de donnÃ©es
```

## La fenÃªtre de rÃ©ception (rwnd)

### DÃ©finition

La **fenÃªtre de rÃ©ception** (receive window, rwnd) est la quantitÃ© de donnÃ©es que le rÃ©cepteur peut encore accepter dans son buffer.

```
Buffer de rÃ©ception :

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ][                            â”‚
â”‚  DonnÃ©es reÃ§ues        Espace libre                â”‚
â”‚  pas encore lues       = rwnd                      â”‚
â”‚  par l'application                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â–²                    â–²
   â”‚                    â”‚
   â”‚                    â””â”€ rwnd annoncÃ© dans l'ACK
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es en attente
```

### Calcul de rwnd

```
rwnd = Taille totale du buffer - DonnÃ©es non lues

Exemple :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Buffer total : 65536 octets (64 Ko)
DonnÃ©es reÃ§ues non lues : 32768 octets (32 Ko)

rwnd = 65536 - 32768 = 32768 octets

Annonce dans ACK : Window = 32768
```

### Annonce de la fenÃªtre

Le rÃ©cepteur annonce **rwnd** dans chaque segment TCP qu'il envoie.

```
Segment TCP envoyÃ© par le rÃ©cepteur :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEQ = 5000                             â”‚
â”‚ ACK = 10000                            â”‚
â”‚ Window Size = 32768  â† rwnd            â”‚
â”‚ Flags : ACK                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Signification pour l'Ã©metteur :
"Tu peux m'envoyer jusqu'Ã  32768 octets
 sans attendre d'ACK"
```

## MÃ©canisme de contrÃ´le de flux

### Fonctionnement de base

```
Ã‰tape par Ã©tape :

1. RÃ©cepteur calcule son espace disponible (rwnd)
2. RÃ©cepteur annonce rwnd dans chaque ACK
3. Ã‰metteur limite ses envois Ã  rwnd
4. Application lit les donnÃ©es â†’ buffer se libÃ¨re
5. rwnd augmente
6. Ã‰metteur peut envoyer plus
```

### Exemple dÃ©taillÃ©

```
Configuration initiale :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ã‰metteur : Veut envoyer 100 Ko
RÃ©cepteur : Buffer de 64 Ko

T=0ms : Ã‰tat initial
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RÃ©cepteur                           Ã‰metteur
   â”‚                                    â”‚
   â”‚ Buffer : [                    ]    â”‚
   â”‚ rwnd = 64 Ko                       â”‚
   â”‚                                    â”‚
   â”‚ ACK, WIN=65536 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                    â”‚
   â”‚                                    â”‚ Peut envoyer 64 Ko


T=10ms : Ã‰metteur envoie 64 Ko (rafale)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚                                    â”‚
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 64 Ko de donnÃ©esâ”‚
   â”‚                                    â”‚
   â”‚ Buffer : [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]    â”‚
   â”‚ rwnd = 0 Ko (plein !)              â”‚
   â”‚                                    â”‚
   â”‚ ACK, WIN=0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ ğŸ›‘ STOP
   â”‚                                    â”‚
   â”‚                                    â”‚ Ne peut plus envoyer


T=50ms : Application lit 32 Ko
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ Application : read(32 Ko)          â”‚
   â”‚ Buffer : [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]            â”‚
   â”‚ rwnd = 32 Ko (libÃ©rÃ©)              â”‚
   â”‚                                    â”‚
   â”‚ Window Update, WIN=32768 â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                    â”‚
   â”‚                                    â”‚ Peut envoyer 32 Ko


T=60ms : Ã‰metteur envoie 32 Ko
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 32 Ko de donnÃ©esâ”‚
   â”‚                                    â”‚
   â”‚ Buffer : [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]    â”‚
   â”‚ rwnd = 0 Ko                        â”‚
   â”‚                                    â”‚
   â”‚ ACK, WIN=0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ ğŸ›‘ STOP
   â”‚                                    â”‚


T=100ms : Application lit 64 Ko
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ Application : read(64 Ko)          â”‚
   â”‚ Buffer : [                    ]    â”‚
   â”‚ rwnd = 64 Ko (tout libÃ©rÃ©)         â”‚
   â”‚                                    â”‚
   â”‚ Window Update, WIN=65536 â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                    â”‚
   â”‚                                    â”‚ Peut envoyer 64 Ko


T=110ms : Ã‰metteur envoie 4 Ko restants
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 4 Ko de donnÃ©es â”‚
   â”‚                                    â”‚
   â”‚ Buffer : [â–ˆ]                       â”‚
   â”‚ rwnd = 60 Ko                       â”‚
   â”‚                                    â”‚
   â”‚ ACK, WIN=61440 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                    â”‚
   â”‚                                    â”‚ âœ“ Transfert terminÃ©
```

### Visualisation du buffer

```
Ã‰tat du buffer au fil du temps :

T=0 : [â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] rwnd=64 Ko
      |------ 100% libre --------------|

T=10: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] rwnd=0 Ko
      |------ 100% occupÃ© -------------|

T=50: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] rwnd=32 Ko
      |--- occupÃ© ---|--- libre ------|
           50%            50%

T=100:[â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] rwnd=64 Ko
      |------ 100% libre --------------|

T=110:[â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] rwnd=60 Ko
      |â–ˆ|------- 94% libre ----------|
      6%
```

## Variables et Ã©tats

### Variables TCP pour le contrÃ´le de flux

```
CÃ´tÃ© RÃ©cepteur :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RCV.WND  : FenÃªtre de rÃ©ception annoncÃ©e (rwnd)
RCV.BUFF : Taille totale du buffer
RCV.USER : Octets lus par l'application

Formule :
RCV.WND = RCV.BUFF - (RCV.NXT - RCV.USER)


CÃ´tÃ© Ã‰metteur :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SND.WND : FenÃªtre d'envoi (reÃ§ue du rÃ©cepteur)
SND.UNA : Premier octet non acquittÃ©
SND.NXT : Prochain octet Ã  envoyer

Limite d'envoi :
SND.NXT â‰¤ SND.UNA + SND.WND
```

### Exemple de calcul

```
Ã‰tat du rÃ©cepteur :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RCV.BUFF = 65536 octets (64 Ko)
RCV.NXT = 10000 (prochain octet attendu)
RCV.USER = 5000 (dernier octet lu par l'app)

DonnÃ©es en buffer non lues :
= RCV.NXT - RCV.USER
= 10000 - 5000
= 5000 octets

rwnd disponible :
= RCV.BUFF - 5000
= 65536 - 5000
= 60536 octets

Annonce : WIN = 60536
```

## FenÃªtre nulle (Zero Window)

### DÃ©tection et traitement

Quand le buffer du rÃ©cepteur est plein, il annonce **rwnd = 0**.

```
ScÃ©nario Zero Window :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RÃ©cepteur                           Ã‰metteur
   â”‚                                    â”‚
   â”‚ Buffer plein (app lente)           â”‚
   â”‚ rwnd = 0                           â”‚
   â”‚                                    â”‚
   â”‚ ACK, WIN=0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                    â”‚
   â”‚                                    â”‚ ğŸ›‘ ArrÃªt complet
   â”‚                                    â”‚ DÃ©marre timer ZWP
   â”‚                                    â”‚
   â”‚                                    â”‚
   â”‚ Application bloquÃ©e ou lente...    â”‚
   â”‚                                    â”‚
   â”‚                                    â”‚

ProblÃ¨me potentiel :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Si le rÃ©cepteur ne renvoie jamais de mise Ã  jour ?
â†’ Deadlock ! L'Ã©metteur attend indÃ©finiment
```

### Zero Window Probe (ZWP)

L'Ã©metteur envoie pÃ©riodiquement des **sondes** pour vÃ©rifier l'Ã©tat du buffer.

```
T=0 : Zero Window annoncÃ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RÃ©cepteur                           Ã‰metteur
   â”‚ ACK, WIN=0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                      â”‚ DÃ©marre timer ZWP
   â”‚                                      â”‚ Intervalle : 5s

T=5s : Premier Zero Window Probe
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ZWP (SEQ=10000, 1 o) â”‚
   â”‚                                      â”‚
   â”‚ Buffer toujours plein                â”‚
   â”‚ ACK, WIN=0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                      â”‚ Prochain probe : 10s

T=15s : DeuxiÃ¨me Zero Window Probe
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ZWP (SEQ=10000, 1 o) â”‚
   â”‚                                      â”‚
   â”‚ Application a enfin lu !             â”‚
   â”‚ rwnd = 32768                         â”‚
   â”‚ ACK, WIN=32768 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ âœ“ DÃ©blocage !
   â”‚                                      â”‚
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es â”€â”€â”€â”€â”€ â”‚ Reprise normale
```

**CaractÃ©ristiques du ZWP** :

```
Structure du probe :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEQ = Prochain octet Ã  envoyer     â”‚
â”‚ Longueur = 1 octet                 â”‚
â”‚ Flags : ACK                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Pourquoi 1 octet ?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Provoque une rÃ©ponse du rÃ©cepteur
- Minimal (n'aggrave pas la situation)
- Peut Ãªtre acceptÃ© mÃªme si buffer presque plein

Intervalles (croissance exponentielle) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1er probe :  5 secondes
2e probe  : 10 secondes
3e probe  : 20 secondes
4e probe  : 40 secondes
5e probe  : 60 secondes (max)

Ensuite : toutes les 60 secondes
Timeout total : Peut aller jusqu'Ã  plusieurs minutes
```

### Persist Timer

Le timer qui gÃ¨re les Zero Window Probes s'appelle le **Persist Timer**.

```
Configuration Linux :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Timeout max pour persist timer
/proc/sys/net/ipv4/tcp_retries2
15  (par dÃ©faut)

Abandon aprÃ¨s environ :
~15 minutes sans rÃ©ouverture de fenÃªtre

Calcul :
5 + 10 + 20 + 40 + 60Ã—N â‰ˆ 900 secondes
```

## Window Update

### Annonce de rÃ©ouverture

Quand l'application lit des donnÃ©es, le buffer se libÃ¨re et le rÃ©cepteur peut annoncer une fenÃªtre plus grande.

```
Window Update :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Segment envoyÃ© uniquement pour mettre Ã  jour rwnd
Pas de nouvelles donnÃ©es
Pas besoin d'acquitter de nouvelles donnÃ©es

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEQ = 5000 (inchangÃ©)              â”‚
â”‚ ACK = 10000 (inchangÃ©)             â”‚
â”‚ Window Size = 32768  (â†‘ augmentÃ©)  â”‚
â”‚ Flags : ACK                        â”‚
â”‚ Longueur : 0 octet                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Exemple dÃ©taillÃ©

```
T=0 : FenÃªtre normale
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RÃ©cepteur                            Ã‰metteur
   â”‚ Buffer : [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]            â”‚
   â”‚ rwnd = 32 Ko                       â”‚
   â”‚ ACK=10000, WIN=32768 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>  â”‚
   â”‚                                    â”‚

T=10ms : RÃ©ception de 32 Ko
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 32 Ko â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
   â”‚ Buffer : [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]        â”‚
   â”‚ rwnd = 0 Ko                        â”‚
   â”‚ ACK=42768, WIN=0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                    â”‚

T=50ms : Application lit 16 Ko
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ read(16384)                        â”‚
   â”‚ Buffer : [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘]          â”‚
   â”‚ rwnd = 16 Ko                       â”‚
   â”‚                                    â”‚
   â”‚ Window Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
   â”‚ ACK=42768, WIN=16384 (nouveau)     â”‚
   â”‚                                    â”‚
   â”‚                                    â”‚ Peut envoyer 16 Ko

T=60ms : Ã‰metteur profite de l'ouverture
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 16 Ko â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
   â”‚ Buffer : [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]        â”‚
   â”‚ rwnd = 0 Ko                        â”‚
```

## Silly Window Syndrome (SWS)

### Le problÃ¨me

Quand de petites fenÃªtres sont annoncÃ©es et utilisÃ©es de maniÃ¨re inefficace.

```
ScÃ©nario problÃ©matique :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RÃ©cepteur lit 100 octets
â†’ Annonce WIN=100
â†’ Ã‰metteur envoie 100 octets

Segment rÃ©sultant :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ IP header  : 20 octets         â”‚
â”‚ TCP header : 20 octets         â”‚
â”‚ DonnÃ©es    : 100 octets        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Total : 140 octets sur le rÃ©seau

Overhead : 40/140 = 28.5% ! ğŸ˜±

Si rÃ©pÃ©tÃ© 1000 fois :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DonnÃ©es utiles : 100 Ko
Overhead : 40 Ko
Total rÃ©seau : 140 Ko

Gaspillage : 40% de bande passante !
```

### CÃ´tÃ© rÃ©cepteur : Clark's Algorithm

Le rÃ©cepteur ne doit annoncer une fenÃªtre > 0 que si l'espace libre est significatif.

```
RÃ¨gle de Clark :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
N'annoncer WIN > 0 que si :

rwnd â‰¥ min(MSS, 50% du buffer total)

Exemple :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Buffer total : 64 Ko
MSS : 1460 octets

Seuil = min(1460, 32768) = 1460 octets

Application lit 500 octets :
rwnd = 500 octets
500 < 1460 â†’ Continuer Ã  annoncer WIN=0

Application lit encore 1000 octets :
rwnd = 1500 octets
1500 â‰¥ 1460 â†’ Annoncer WIN=1500 âœ“
```

**ImplÃ©mentation** :

```
Code conceptuel :

if (buffer_free < min(MSS, buffer_total / 2)) {
    // Espace insuffisant
    advertise_window = 0;  // Force Zero Window
} else {
    // Espace significatif
    advertise_window = buffer_free;
}
```

### CÃ´tÃ© Ã©metteur : Nagle's Algorithm

L'Ã©metteur ne doit pas envoyer de petits segments si possible.

```
RÃ¨gle de Nagle :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Envoyer immÃ©diatement SI :
1. Segment plein (len â‰¥ MSS)
   OU
2. Aucune donnÃ©e en vol (tous les ACK reÃ§us)
   OU
3. Flag PSH activÃ© (push explicite)

SINON : Accumuler jusqu'Ã  remplir MSS ou recevoir ACK


Exemple sans Nagle :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Application Ã©crit : "H" â†’ Segment 41 octets
Application Ã©crit : "e" â†’ Segment 41 octets
Application Ã©crit : "l" â†’ Segment 41 octets
Application Ã©crit : "l" â†’ Segment 41 octets
Application Ã©crit : "o" â†’ Segment 41 octets

5 segments = 205 octets pour 5 octets utiles ! ğŸ’€


Exemple avec Nagle :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Application Ã©crit : "H" â†’ Accumuler
Application Ã©crit : "e" â†’ Accumuler
Application Ã©crit : "l" â†’ Accumuler
Application Ã©crit : "l" â†’ Accumuler
Application Ã©crit : "o" â†’ Accumuler

ACK reÃ§u ou timeout â†’ Segment 45 octets

1 segment = 45 octets pour 5 octets utiles âœ“
Ã‰conomie : 78% !
```

### DÃ©sactivation de Nagle

Pour certaines applications (temps rÃ©el), Nagle est contre-productif.

```c
// DÃ©sactiver Nagle (TCP_NODELAY)
int flag = 1;
setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
           &flag, sizeof(int));

Applications concernÃ©es :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ SSH / Terminal interactif
  â†’ Chaque frappe doit Ãªtre envoyÃ©e immÃ©diatement

â€¢ Jeux en ligne
  â†’ Latence critique, petits paquets frÃ©quents

â€¢ Trading haute frÃ©quence
  â†’ Chaque microseconde compte

â€¢ VoIP / Streaming temps rÃ©el
  â†’ DÃ©lai inacceptable
```

**Compromis** :

```
Avec Nagle :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+ EfficacitÃ© rÃ©seau (moins de segments)
+ Moins d'overhead
- Latence accrue (attente d'accumulation)

Sans Nagle (TCP_NODELAY) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+ Latence minimale
+ RÃ©activitÃ© maximale
- Plus de segments
- Plus d'overhead
```

## Interaction avec Delayed ACK

### Le problÃ¨me de l'interaction

Nagle et Delayed ACK peuvent crÃ©er un dÃ©lai indÃ©sirable ensemble.

```
ScÃ©nario problÃ©matique :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Client (Nagle actif)            Serveur (Delayed ACK actif)
   â”‚                                    â”‚
   â”‚ RequÃªte (40 octets) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                    â”‚
   â”‚ Toutes donnÃ©es envoyÃ©es            â”‚ ReÃ§oit, dÃ©marre timer
   â”‚ Nagle : attente ACK                â”‚ Delayed ACK : attente 200ms
   â”‚                                    â”‚
   â”‚ Attente...                         â”‚ Attente...
   â”‚                                    â”‚
   â”‚                         (200ms)    â”‚
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”‚
   â”‚                                    â”‚
   â”‚ DonnÃ©es suivantes (100 octets) â”€â”€â”€>â”‚
   â”‚                                    â”‚
   â”‚                         (200ms)    â”‚
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”‚

Latence artificielle : 200ms Ã  chaque Ã©change ! ğŸ’€
```

### Solution

```
Option 1 : DÃ©sactiver Nagle (TCP_NODELAY)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, ...)

Option 2 : DÃ©sactiver Delayed ACK (rare)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
setsockopt(sock, IPPROTO_TCP, TCP_QUICKACK, ...)
(Temporaire, se rÃ©active automatiquement)

Option 3 : Cork/Uncork (Linux)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Accumuler plusieurs writes
setsockopt(sock, IPPROTO_TCP, TCP_CORK, 1);
write(sock, data1, len1);
write(sock, data2, len2);
write(sock, data3, len3);
// Envoyer tout d'un coup
setsockopt(sock, IPPROTO_TCP, TCP_CORK, 0);
```

## Buffer management

### Taille du buffer de rÃ©ception

```
Configuration des buffers :

Par socket (application) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &size, sizeof(size));

Exemple :
int bufsize = 131072;  // 128 Ko
setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize));


SystÃ¨me (Linux) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/proc/sys/net/ipv4/tcp_rmem
Format : min default max

# Exemple
echo "4096 131072 6291456" > /proc/sys/net/ipv4/tcp_rmem
#      4 Ko  128 Ko  6 Mo
#      min  dÃ©faut  max
```

### Auto-tuning

Le noyau Linux ajuste automatiquement les buffers selon les conditions.

```
Configuration auto-tuning :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/proc/sys/net/ipv4/tcp_moderate_rcvbuf
1  (activÃ© par dÃ©faut)

Fonctionnement :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Le kernel observe :
- DÃ©bit de rÃ©ception
- RTT
- Utilisation du buffer

Et ajuste dynamiquement :
Buffer = DÃ©bit Ã— RTT Ã— facteur_sÃ©curitÃ©

Exemple :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
DÃ©bit mesurÃ© : 100 Mbps
RTT : 50 ms
BDP = 100 Mbps Ã— 0.05s = 625 Ko

Buffer ajustÃ© : ~1 Mo (avec marge)
```

### Limites systÃ¨me

```
Limites globales (Linux) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Maximum pour SO_RCVBUF
/proc/sys/net/core/rmem_max
212992  (208 Ko par dÃ©faut)

# Maximum TCP auto-tuning
/proc/sys/net/ipv4/tcp_rmem (3e valeur)
6291456  (6 Mo par dÃ©faut)

# MÃ©moire totale TCP
/proc/sys/net/ipv4/tcp_mem
Format : low pressure high (en pages de 4 Ko)

Augmenter pour haute performance :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo "134217728" > /proc/sys/net/core/rmem_max  # 128 Mo
echo "4096 87380 134217728" > /proc/sys/net/ipv4/tcp_rmem
```

## Exemples de scÃ©narios

### ScÃ©nario 1 : Application lente

```
Application qui ne lit pas assez vite :

T=0 : Connexion Ã©tablie
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RÃ©cepteur                             Ã‰metteur
   â”‚ Buffer : 64 Ko libre                 â”‚
   â”‚ WIN=65536 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚

T=10ms : RÃ©ception rapide
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 64 Ko â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
   â”‚ Buffer : [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]      â”‚
   â”‚ WIN=0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚

T=0.01s-10s : Application ne lit RIEN
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ Application bloquÃ©e/lente            â”‚
   â”‚ Buffer reste plein                   â”‚
   â”‚                                      â”‚
   â”‚ <â”€â”€â”€â”€â”€â”€ ZWP toutes les 5-60s â”€â”€â”€â”€â”€â”€  â”‚
   â”‚ WIN=0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚ WIN=0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚ WIN=0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚

T=10s : Application se rÃ©veille
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ read(65536)                          â”‚
   â”‚ Buffer : [                    ]      â”‚
   â”‚ WIN=65536 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
   â”‚                                      â”‚
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ Reprise

DurÃ©e de blocage : 10 secondes
Cause : Application, pas TCP ! âœ“
```

### ScÃ©nario 2 : TÃ©lÃ©chargement avec buffer petit

```
TÃ©lÃ©chargement 10 Mo
Liaison : 100 Mbps
Buffer rÃ©cepteur : 16 Ko (petit)

Analyse :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
BDP = 100 Mbps Ã— 50 ms = 625 Ko
Buffer = 16 Ko

Buffer << BDP ! âš ï¸


DÃ©roulement :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T=0 : Ã‰metteur envoie 16 Ko
     FenÃªtre pleine
     Attente ACK

T=50ms : ACK reÃ§u
         Application a lu 16 Ko
         Ã‰metteur envoie 16 Ko
         FenÃªtre pleine
         Attente ACK

Cycle : 50 ms par 16 Ko

DÃ©bit effectif :
= 16 Ko / 0.05s
= 320 Ko/s
= 2.56 Mbps

Utilisation liaison : 2.56 / 100 = 2.5% ! ğŸ’€

Solution :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Augmenter buffer Ã  625 Ko minimum
â†’ DÃ©bit passerait Ã  ~100 Mbps âœ“
```

### ScÃ©nario 3 : Streaming vidÃ©o

```
Streaming 4K (25 Mbps)
RTT : 50 ms
Buffer : 256 Ko

Analyse :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
BDP = 25 Mbps Ã— 0.05s = 156 Ko
Buffer = 256 Ko

Buffer > BDP âœ“ (OK)


Comportement :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ã‰metteur envoie flux constant Ã  25 Mbps
Buffer jamais plein (application consomme vite)
rwnd reste Ã©levÃ© (>= 100 Ko)
Pas de Zero Window
Pas de blocage

Performance : Optimale âœ“

Si application dÃ©codage lent :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Buffer se remplit progressivement
rwnd diminue
Peut atteindre Zero Window
â†’ Lecture vidÃ©o saccadÃ©e (buffering)
```

## Diagnostic et monitoring

### Commandes de diagnostic

```bash
# Voir l'Ã©tat des buffers (ss)
ss -tin

# Sortie exemple :
# tcp ESTAB 0  32768  192.168.1.10:54321  93.184.216.34:443
#     ts sack cubic wscale:7,7 rto:204 rtt:3.5/1.75
#     rcv_space:29200 rcv_ssthresh:29200
#     â–²                â–²
#     â”‚                â””â”€ Seuil slow start
#     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Espace buffer rÃ©ception

# DÃ©tail des champs importants :
# rcv_space : Taille actuelle du buffer RX (auto-tunÃ©)
# rcv_ssthresh : Seuil pour ajustement
# rcv_rtt : RTT cÃ´tÃ© rÃ©ception
```

### Netstat et statistiques

```bash
# Statistiques globales TCP
netstat -s | grep -i window

# Sortie exemple :
# 1234 times the listen queue of a socket overflowed
# 5678 times receiver scheduled too late for direct processing
# 12 times zero window was announced
# 45 times window update sent

# InterprÃ©ter :
# - "zero window" Ã©levÃ© â†’ RÃ©cepteurs surchargÃ©s
# - "window update" Ã©levÃ© â†’ Buffers sous pression
```

### Analyse avec Wireshark

```
Filtres Wireshark utiles :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Zero Window
tcp.window_size == 0

# Window Update
tcp.analysis.window_update

# Window Full
tcp.analysis.window_full

# Zero Window Probe
tcp.analysis.zero_window_probe


Exemple de capture :
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Frame 234: [TCP Window Full]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Source: 192.168.1.10
Destination: 93.184.216.34
Window: 0
[Expert Info: Window is full]

Frame 235: [TCP Zero Window]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Source: 93.184.216.34
Destination: 192.168.1.10
Acknowledgment: 12345
Window: 0  â† ProblÃ¨me !
[Expert Info: Zero window]

Frame 236: [TCP Zero Window Probe]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Source: 192.168.1.10
Destination: 93.184.216.34
Sequence: 12345
Length: 1  â† Probe de 1 octet
[Expert Info: Zero window probe]

Frame 237: [TCP Window Update]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Source: 93.184.216.34
Destination: 192.168.1.10
Window: 32768  â† RÃ©ouverture
[Expert Info: Window update]
```

### Graphiques de fenÃªtre

```
Wireshark : Statistics â†’ TCP Stream Graphs â†’ Window Scaling

Visualisation :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Window Size
    â”‚
64Koâ”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘
    â”‚
32Koâ”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â”‚
 0  â”‚         â†‘      â†‘        â†‘
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Temps
              â”‚      â”‚        â”‚
              â”‚      â”‚        â””â”€ Application lente
              â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LibÃ©ration buffer
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Zero Window

InterprÃ©tation :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Plateau Ã  0 : Zero Window (problÃ¨me)
- Variations rapides : Application rÃ©active
- Plateau Ã©levÃ© : Bonne performance
- Dents de scie : Lecture intermittente
```

## Tuning pour diffÃ©rents cas d'usage

### Web Server (nombreuses connexions courtes)

```bash
# Buffers modÃ©rÃ©s (128 Ko par dÃ©faut)
sysctl -w net.ipv4.tcp_rmem="4096 131072 6291456"
sysctl -w net.ipv4.tcp_wmem="4096 16384 4194304"

# Activer auto-tuning
sysctl -w net.ipv4.tcp_moderate_rcvbuf=1

# Activer Window Scaling
sysctl -w net.ipv4.tcp_window_scaling=1

# RÃ©duire timeout Zero Window Probe
# (les connexions bloquÃ©es sont rapidement abandonnÃ©es)
```

### Transfert de gros fichiers (FTP, backup)

```bash
# Buffers trÃ¨s larges (16-64 Mo)
sysctl -w net.core.rmem_max=67108864  # 64 Mo
sysctl -w net.core.wmem_max=67108864
sysctl -w net.ipv4.tcp_rmem="4096 87380 67108864"
sysctl -w net.ipv4.tcp_wmem="4096 65536 67108864"

# Auto-tuning agressif
sysctl -w net.ipv4.tcp_moderate_rcvbuf=1

# Window Scaling essentiel
sysctl -w net.ipv4.tcp_window_scaling=1

# Augmenter mÃ©moire TCP totale
sysctl -w net.ipv4.tcp_mem="8388608 12582912 16777216"
#                            low     pression  high (pages 4Ko)
```

### Streaming / Temps rÃ©el

```bash
# Buffers moyens (256-512 Ko)
sysctl -w net.ipv4.tcp_rmem="8192 262144 4194304"

# DÃ©sactiver Nagle pour faible latence
# (fait par l'application via TCP_NODELAY)

# Quick ACK pour rÃ©duire latence
# (fait par l'application via TCP_QUICKACK)

# PrioritÃ© sur latence vs throughput
```

### Satellite / Haute latence

```bash
# Buffers Ã©normes (RTT Ã©levÃ©)
# Exemple : 10 Mbps, RTT 600ms
# BDP = 10 Mbps Ã— 0.6s = 6 Mb = 750 Ko

sysctl -w net.core.rmem_max=16777216  # 16 Mo
sysctl -w net.ipv4.tcp_rmem="4096 87380 16777216"

# Window Scale obligatoire
sysctl -w net.ipv4.tcp_window_scaling=1

# Timestamps pour PAWS
sysctl -w net.ipv4.tcp_timestamps=1
```

## ProblÃ¨mes courants

### ProblÃ¨me 1 : Zero Window frÃ©quent

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Wireshark montre beaucoup de [TCP Zero Window]
Transferts trÃ¨s lents

Diagnostic :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ss -tin | grep rcv_space
# Valeurs faibles (< 64 Ko)

Causes possibles :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Application lente (CPU, I/O)
2. Buffer trop petit
3. Auto-tuning dÃ©sactivÃ©

Solutions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Optimiser application (profiling)
2. Augmenter buffers :
   sysctl -w net.ipv4.tcp_rmem="4096 131072 16777216"
3. Activer auto-tuning :
   sysctl -w net.ipv4.tcp_moderate_rcvbuf=1
4. VÃ©rifier CPU/mÃ©moire du systÃ¨me
```

### ProblÃ¨me 2 : Silly Window Syndrome

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Wireshark montre beaucoup de petits segments (< 100 octets)
Overhead rÃ©seau Ã©levÃ©

Diagnostic :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
tcpdump -i eth0 -nn 'tcp and less 100'
# Beaucoup de trafic

Causes :
â”€â”€â”€â”€â”€â”€â”€â”€
1. Application Ã©crit par petits morceaux
2. Nagle dÃ©sactivÃ© (TCP_NODELAY)
3. FenÃªtre trÃ¨s petite annoncÃ©e

Solutions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Buffering applicatif :
   char buffer[4096];
   // Accumuler avant write()

2. TCP_CORK (Linux) :
   setsockopt(sock, IPPROTO_TCP, TCP_CORK, 1);
   // Plusieurs writes
   setsockopt(sock, IPPROTO_TCP, TCP_CORK, 0);

3. VÃ©rifier que Nagle est actif
   (Ne pas utiliser TCP_NODELAY sauf nÃ©cessaire)
```

### ProblÃ¨me 3 : Window Scale pas nÃ©gociÃ©

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FenÃªtre limitÃ©e Ã  64 Ko malgrÃ© buffers larges
Performance limitÃ©e sur liaisons longue distance

Diagnostic :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
tcpdump lors du handshake
# VÃ©rifier prÃ©sence "wscale" dans SYN

Causes :
â”€â”€â”€â”€â”€â”€â”€â”€
1. Window Scaling dÃ©sactivÃ©
2. Firewall/middlebox casse l'option
3. Vieille implÃ©mentation TCP

Solutions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Activer Window Scaling :
   sysctl -w net.ipv4.tcp_window_scaling=1

2. VÃ©rifier pare-feu :
   # Ne doit pas stripper les options TCP

3. Tester sans firewall intermÃ©diaire
```

## Performance et calculs

### Calcul du dÃ©bit maximum

```
Avec contrÃ´le de flux :

DÃ©bit max = FenÃªtre / RTT

Exemples :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Window = 64 Ko, RTT = 100 ms
   DÃ©bit = 65536 / 0.1 = 655360 octets/s
         = 5.2 Mbps

2. Window = 1 Mo, RTT = 50 ms
   DÃ©bit = 1048576 / 0.05 = 20971520 octets/s
         = 167 Mbps

3. Window = 8 Mo, RTT = 100 ms
   DÃ©bit = 8388608 / 0.1 = 83886080 octets/s
         = 671 Mbps
```

### Impact du RTT

```
FenÃªtre fixe de 1 Mo :

RTT     DÃ©bit max
â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€
10 ms   800 Mbps
50 ms   160 Mbps
100 ms   80 Mbps
200 ms   40 Mbps
500 ms   16 Mbps

Plus le RTT est Ã©levÃ©, plus la fenÃªtre doit Ãªtre grande !
```

### FenÃªtre optimale

```
Pour saturer une liaison de B bps avec RTT de R secondes :

FenÃªtre optimale = B Ã— R

Exemples :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1 Gbps, RTT 50 ms :
FenÃªtre = 1 000 000 000 Ã— 0.05 / 8
        = 6 250 000 octets
        â‰ˆ 6 Mo

100 Mbps, RTT 200 ms :
FenÃªtre = 100 000 000 Ã— 0.2 / 8
        = 2 500 000 octets
        â‰ˆ 2.4 Mo

10 Mbps, RTT 600 ms (satellite) :
FenÃªtre = 10 000 000 Ã— 0.6 / 8
        = 750 000 octets
        â‰ˆ 730 Ko
```

## RÃ©sumÃ©

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CONTRÃ”LE DE FLUX TCP                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  But : ProtÃ©ger le RÃ‰CEPTEUR contre la surcharge        â”‚
â”‚                                                         â”‚
â”‚  MÃ©canisme :                                            â”‚
â”‚    â€¢ RÃ©cepteur annonce rwnd (fenÃªtre disponible)        â”‚
â”‚    â€¢ Ã‰metteur limite envois Ã  rwnd                      â”‚
â”‚    â€¢ rwnd varie selon buffer et application             â”‚
â”‚                                                         â”‚
â”‚  Formule :                                              â”‚
â”‚    rwnd = Buffer total - DonnÃ©es non lues               â”‚
â”‚                                                         â”‚
â”‚  Zero Window :                                          â”‚
â”‚    â€¢ Buffer plein â†’ rwnd = 0                            â”‚
â”‚    â€¢ Ã‰metteur arrÃªte d'envoyer                          â”‚
â”‚    â€¢ Zero Window Probes pÃ©riodiques                     â”‚
â”‚    â€¢ Window Update quand buffer libÃ©rÃ©                  â”‚
â”‚                                                         â”‚
â”‚  Silly Window Syndrome :                                â”‚
â”‚    â€¢ ProblÃ¨me : Petites fenÃªtres inefficaces            â”‚
â”‚    â€¢ Solution rÃ©cepteur : Clark's Algorithm             â”‚
â”‚    â€¢ Solution Ã©metteur : Nagle's Algorithm              â”‚
â”‚                                                         â”‚
â”‚  Optimisation :                                         â”‚
â”‚    â€¢ Buffers adaptÃ©s au BDP                             â”‚
â”‚    â€¢ Auto-tuning activÃ©                                 â”‚
â”‚    â€¢ Window Scale pour > 64 Ko                          â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Conclusion

Le contrÃ´le de flux est essentiel pour :

**âœ… Avantages** :
- ProtÃ¨ge le rÃ©cepteur contre la surcharge
- Ã‰vite les pertes dues au dÃ©bordement de buffer
- S'adapte dynamiquement aux capacitÃ©s de l'application
- Fonctionne de maniÃ¨re transparente

**ğŸ¯ Points clÃ©s** :

1. **rwnd** : FenÃªtre de rÃ©ception annoncÃ©e dans chaque ACK
2. **Zero Window** : MÃ©canisme d'arrÃªt quand buffer plein
3. **ZWP** : Sondes pour dÃ©tecter rÃ©ouverture de fenÃªtre
4. **SWS** : Ã‰viter les petites fenÃªtres inefficaces
5. **Buffer sizing** : Doit Ãªtre â‰¥ BDP pour performance optimale
6. **Auto-tuning** : Ajustement automatique recommandÃ©

**Formule fondamentale** :

```
DÃ©bit max = FenÃªtre / RTT

Pour saturer la liaison :
FenÃªtre â‰¥ Bande passante Ã— RTT
```

**Distinction importante** :

```
ContrÃ´le de flux (rwnd) :
â””â”€ ProtÃ¨ge le RÃ‰CEPTEUR
   â””â”€ BasÃ© sur le buffer disponible
      â””â”€ AnnoncÃ© dans chaque segment

ContrÃ´le de congestion (cwnd) :
â””â”€ ProtÃ¨ge le RÃ‰SEAU
   â””â”€ BasÃ© sur l'Ã©tat du rÃ©seau
      â””â”€ CalculÃ© par l'Ã©metteur (prochaine section)
```

Le contrÃ´le de flux, combinÃ© au contrÃ´le de congestion, permet Ã  TCP de maintenir un Ã©quilibre dÃ©licat entre performance maximale et protection des ressources.

Dans la prochaine section, nous explorerons le **contrÃ´le de congestion**, le mÃ©canisme complÃ©mentaire qui protÃ¨ge le rÃ©seau contre la surcharge.

---

**Prochaine section** : 4.5.8 ContrÃ´le de congestion : slow start, congestion avoidance

â­ï¸ [ContrÃ´le de congestion : slow start, congestion avoidance](/04-couche-transport/05.8-tcp-controle-congestion.md)
