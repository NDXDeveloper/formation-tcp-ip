ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 4.5.4 Fermeture de connexion : 4-way handshake

## Introduction

Tout comme TCP Ã©tablit une connexion de maniÃ¨re formelle avec le 3-way handshake, il la termine de faÃ§on tout aussi structurÃ©e avec le **4-way handshake** (poignÃ©e de main Ã  quatre voies). Cette procÃ©dure garantit que toutes les donnÃ©es en transit sont correctement reÃ§ues avant de fermer dÃ©finitivement la connexion.

Contrairement Ã  l'Ã©tablissement qui nÃ©cessite 3 segments, la fermeture en requiert **4** pour une raison fondamentale : TCP est **full-duplex** (bidirectionnel), et chaque direction doit Ãªtre fermÃ©e indÃ©pendamment.

```
Ã‰tablissement (3-way) :          Fermeture (4-way) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     SYN â†’                            FIN â†’
  â† SYN-ACK                         â† ACK
     ACK â†’                            FIN â†
                                   â†’ ACK

  3 segments                      4 segments
```

## Pourquoi 4 segments au lieu de 3 ?

### Nature bidirectionnelle de TCP

TCP Ã©tablit un **canal bidirectionnel** oÃ¹ chaque direction est indÃ©pendante :

```
Client                          Serveur
   â”‚                                â”‚
   â”‚â•â•â•â•â•â•â• Sens 1 â•â•â•â•â•â•â•â•â•â•â•â•â•â•>  â”‚  Client â†’ Serveur
   â”‚                                â”‚
   â”‚<â•â•â•â•â•â•â• Sens 2 â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚  Serveur â†’ Client
   â”‚                                â”‚

Chaque sens a :
- Ses propres numÃ©ros de sÃ©quence
- Son propre contrÃ´le de flux
- Sa propre fermeture indÃ©pendante
```

### Fermeture asymÃ©trique

Un cÃ´tÃ© peut vouloir arrÃªter d'envoyer des donnÃ©es tout en continuant Ã  en recevoir :

```
Exemple : TÃ©lÃ©chargement de fichier

Client                           Serveur
   â”‚ "GET /file.zip"                 â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>   â”‚
   â”‚                                 â”‚
   â”‚ "OK, voici le fichier..."       â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
   â”‚                                 â”‚
   â”‚ FIN (je n'enverrai plus rien)   â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>   â”‚
   â”‚                                 â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  â† Serveur continue !
   â”‚<â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€ FIN (terminÃ©) â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
   â”‚                                 â”‚
   â”‚ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
```

## Les quatre Ã©tapes du 4-way handshake

### Vue d'ensemble

```
Client                                    Serveur
  â”‚                                          â”‚
  â”‚  Ã‰tat: ESTABLISHED                       â”‚  Ã‰tat: ESTABLISHED
  â”‚                                          â”‚
  â”‚ â‘  FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚  "Je n'ai plus de donnÃ©es Ã  envoyer"     â”‚
  â”‚  Ã‰tat: FIN-WAIT-1                        â”‚  Ã‰tat: CLOSE-WAIT
  â”‚                                          â”‚
  â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â‘¡ â”‚
  â”‚  "J'ai bien reÃ§u ton FIN"                â”‚
  â”‚  Ã‰tat: FIN-WAIT-2                        â”‚
  â”‚                                          â”‚
  â”‚                                          â”‚  L'application traite
  â”‚                                          â”‚  les donnÃ©es restantes
  â”‚                                          â”‚
  â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FIN â”€â”€â‘¢ â”‚
  â”‚  "Moi aussi j'ai fini"                   â”‚
  â”‚                       Ã‰tat: LAST-ACK     â”‚
  â”‚                                          â”‚
  â”‚ â‘£ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚  "J'ai bien reÃ§u ton FIN"                â”‚
  â”‚  Ã‰tat: TIME-WAIT                         â”‚  Ã‰tat: CLOSED
  â”‚                                          â”‚
  â”‚  Attente 2Ã—MSL (60-120s)                 â”‚
  â”‚                                          â”‚
  â”‚  Ã‰tat: CLOSED                            â”‚
```

### Ã‰tape 1 : FIN (Client â†’ Serveur)

Le client (ou celui qui initie la fermeture) envoie un segment avec le flag **FIN** activÃ©.

```
Segment FIN :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Port Source      : 54321                 â”‚
â”‚ Port Destination : 443                   â”‚
â”‚ NumÃ©ro SEQ       : 5000                  â”‚
â”‚ NumÃ©ro ACK       : 8000                  â”‚
â”‚ Flags            : FIN = 1, ACK = 1      â”‚
â”‚ Window Size      : 65535                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Signification** :
- "Je n'ai plus de donnÃ©es Ã  envoyer"
- "Mais je peux encore en recevoir"
- Le numÃ©ro de sÃ©quence pointe sur le dernier octet + 1

**Ã‰tat du client** : `FIN-WAIT-1` (attente de l'ACK du serveur)

**Important** : Le flag FIN **consomme un numÃ©ro de sÃ©quence**, comme le SYN.

```
Si le dernier octet de donnÃ©es envoyÃ© Ã©tait 4999 :
FIN aura SEQ = 5000
Le prochain ACK attendu sera ACK = 5001
```

### Ã‰tape 2 : ACK (Serveur â†’ Client)

Le serveur acquitte la rÃ©ception du FIN.

```
Segment ACK :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Port Source      : 443                   â”‚
â”‚ Port Destination : 54321                 â”‚
â”‚ NumÃ©ro SEQ       : 8000                  â”‚
â”‚ NumÃ©ro ACK       : 5001                  â”‚  â† SEQ du FIN + 1
â”‚ Flags            : ACK = 1               â”‚
â”‚ Window Size      : 65535                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Signification** :
- "J'ai bien reÃ§u ton FIN"
- "Tu peux arrÃªter d'envoyer"
- "Mais moi, je continue peut-Ãªtre..."

**Ã‰tats** :
- Client : `FIN-WAIT-2` (attente du FIN du serveur)
- Serveur : `CLOSE-WAIT` (en attente que l'application termine)

**Point critique** : Ã€ ce stade, la connexion est en **half-close** :
- Client â†’ Serveur : âŒ FermÃ© (plus de donnÃ©es)
- Serveur â†’ Client : âœ“ Ouvert (donnÃ©es possibles)

### Ã‰tape 3 : FIN (Serveur â†’ Client)

Quand le serveur a fini de traiter et d'envoyer ses donnÃ©es, il envoie son propre FIN.

```
Segment FIN :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Port Source      : 443                   â”‚
â”‚ Port Destination : 54321                 â”‚
â”‚ NumÃ©ro SEQ       : 9500                  â”‚
â”‚ NumÃ©ro ACK       : 5001                  â”‚
â”‚ Flags            : FIN = 1, ACK = 1      â”‚
â”‚ Window Size      : 0                     â”‚  â† Souvent 0
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Signification** :
- "J'ai fini d'envoyer mes donnÃ©es"
- "Tu peux fermer complÃ¨tement"

**Ã‰tats** :
- Client : toujours `FIN-WAIT-2`
- Serveur : `LAST-ACK` (attente du dernier acquittement)

### Ã‰tape 4 : ACK (Client â†’ Serveur)

Le client envoie le dernier acquittement.

```
Segment ACK final :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Port Source      : 54321                 â”‚
â”‚ Port Destination : 443                   â”‚
â”‚ NumÃ©ro SEQ       : 5001                  â”‚
â”‚ NumÃ©ro ACK       : 9501                  â”‚  â† SEQ du FIN + 1
â”‚ Flags            : ACK = 1               â”‚
â”‚ Window Size      : 0                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Signification** :
- "J'ai bien reÃ§u ton FIN"
- "Connexion terminÃ©e de mon cÃ´tÃ©"

**Ã‰tats finaux** :
- Client : `TIME-WAIT` (attente de sÃ©curitÃ© de 2Ã—MSL)
- Serveur : `CLOSED` (immÃ©diatement)

## Diagramme temporel complet

```
Temps    Client (192.168.1.10:54321)         Serveur (93.184.216.34:443)
  â”‚
  0      Ã‰tat: ESTABLISHED                   Ã‰tat: ESTABLISHED
  â”‚      Application appelle close()
  â”‚         â”‚                                    â”‚
  â”‚         â”‚ â‘ â”€â”€â”€â”€â”€â”€â”€â”€ FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚         â”‚ SEQ=5000, ACK=8000                 â”‚
 10ms       â”‚ Flags: FIN, ACK                    â”‚
  â”‚         â”‚                                    â”‚
  â”‚      Ã‰tat: FIN-WAIT-1                    Ã‰tat: CLOSE-WAIT
  â”‚         â”‚                                    â”‚
  â”‚         â”‚                                    â”‚ Notifie l'application
  â”‚         â”‚                                    â”‚ (EOF sur recv())
  â”‚         â”‚                                    â”‚
  â”‚         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â‘¡ â”‚
  â”‚         â”‚           SEQ=8000, ACK=5001       â”‚
 35ms       â”‚           Flags: ACK               â”‚
  â”‚         â”‚                                    â”‚
  â”‚      Ã‰tat: FIN-WAIT-2                        â”‚
  â”‚         â”‚                                    â”‚
  â”‚         â”‚                                    â”‚ Application continue
  â”‚         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚ si nÃ©cessaire
  â”‚         â”‚           SEQ=8000, 1000 octets    â”‚
 50ms       â”‚           Flags: ACK               â”‚
  â”‚         â”‚                                    â”‚
  â”‚         â”‚ â”€â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>  â”‚
  â”‚         â”‚ SEQ=5001, ACK=9000                 â”‚
 55ms       â”‚                                    â”‚
  â”‚         â”‚                                    â”‚
  â”‚         â”‚                                    â”‚ Application termine
  â”‚         â”‚                                    â”‚ appelle close()
  â”‚         â”‚                                    â”‚
  â”‚         â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€ FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â‘¢ â”‚
  â”‚         â”‚           SEQ=9500, ACK=5001       â”‚
 100ms      â”‚           Flags: FIN, ACK          â”‚
  â”‚         â”‚                                    â”‚
  â”‚                                          Ã‰tat: LAST-ACK
  â”‚         â”‚                                    â”‚
  â”‚         â”‚ â‘£â”€â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚         â”‚ SEQ=5001, ACK=9501                 â”‚
 102ms      â”‚ Flags: ACK                         â”‚
  â”‚         â”‚                                    â”‚
  â”‚      Ã‰tat: TIME-WAIT                     Ã‰tat: CLOSED âœ“
  â”‚         â”‚                                    â”‚
  â”‚         â”‚ Attente 2Ã—MSL (60-120s)            â”‚
  â”‚         â”‚                                    â”‚
 60s+102ms  â”‚                                    â”‚
  â”‚      Ã‰tat: CLOSED âœ“                          â”‚
```

**Observations** :
- DurÃ©e totale du handshake : ~100ms (2 RTT)
- Le client reste en TIME-WAIT pendant 60-120 secondes
- Le serveur passe immÃ©diatement en CLOSED

## Les Ã©tats de fermeture

### Diagramme de transition des Ã©tats

```
                    ESTABLISHED
                         â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                         â”‚
       close() ou                  reÃ§oit FIN
       FIN reÃ§u                    envoie ACK
            â”‚                         â”‚
            â–¼                         â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚FIN-WAIT-1â”‚            â”‚ CLOSE-WAIT  â”‚
      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
           â”‚                         â”‚
      reÃ§oit ACK                 close()
           â”‚                    envoie FIN
           â–¼                         â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
      â”‚FIN-WAIT-2â”‚                   â”‚
      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                   â”‚
           â”‚                         â–¼
      reÃ§oit FIN              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      envoie ACK              â”‚  LAST-ACK   â”‚
           â”‚                  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
           â”‚                         â”‚
           â”‚                    reÃ§oit ACK
           â”‚                         â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  TIME-WAIT   â”‚
               â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                Timeout 2Ã—MSL
                      â”‚
                      â–¼
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ CLOSED â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Description des Ã©tats

#### FIN-WAIT-1
```
Ã‰tat : Attente de l'ACK du FIN envoyÃ©
DurÃ©e : Quelques millisecondes (1 RTT typiquement)
Transition : â†’ FIN-WAIT-2 quand ACK reÃ§u
```

#### FIN-WAIT-2
```
Ã‰tat : Attente du FIN de l'autre cÃ´tÃ©
DurÃ©e : Variable (dÃ©pend de l'application distante)
ProblÃ¨me : Si l'autre cÃ´tÃ© ne ferme jamais â†’ timeout
Transition : â†’ TIME-WAIT quand FIN reÃ§u
```

**Configuration du timeout FIN-WAIT-2** :

```bash
# Linux : timeout par dÃ©faut 60 secondes
cat /proc/sys/net/ipv4/tcp_fin_timeout
60

# RÃ©duire Ã  30 secondes
sysctl -w net.ipv4.tcp_fin_timeout=30
```

#### CLOSE-WAIT
```
Ã‰tat : L'autre cÃ´tÃ© a fermÃ© sa direction
DurÃ©e : Jusqu'Ã  ce que l'application locale ferme
Action : L'application doit appeler close()
ProblÃ¨me : Si l'application ne ferme pas â†’ fuite de sockets
```

**ProblÃ¨me courant** : Accumulation de connexions en CLOSE-WAIT

```bash
# VÃ©rifier les connexions en CLOSE-WAIT
ss -tan state close-wait

# Si beaucoup de CLOSE-WAIT :
# â†’ Bug applicatif (l'app ne ferme pas les sockets)
```

#### LAST-ACK
```
Ã‰tat : Attente du dernier ACK
DurÃ©e : Quelques millisecondes (1 RTT)
Transition : â†’ CLOSED quand ACK reÃ§u
```

#### TIME-WAIT
```
Ã‰tat : Attente de sÃ©curitÃ© aprÃ¨s fermeture
DurÃ©e : 2Ã—MSL (Maximum Segment Lifetime)
       = 60-120 secondes typiquement
But : Absorber les segments retardÃ©s
Transition : â†’ CLOSED aprÃ¨s timeout
```

C'est l'Ã©tat le plus problÃ©matique en production. Nous l'Ã©tudierons en dÃ©tail ci-dessous.

## L'Ã©tat TIME-WAIT : pourquoi et comment ?

### Pourquoi TIME-WAIT ?

L'Ã©tat TIME-WAIT rÃ©sout deux problÃ¨mes critiques :

#### ProblÃ¨me 1 : Perte du dernier ACK

```
ScÃ©nario sans TIME-WAIT :

Client                           Serveur
   â”‚                                â”‚
   â”‚ FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>   â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK    â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FIN    â”‚
   â”‚                                â”‚
   â”‚ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€X       â”‚  â† ACK perdu !
   â”‚ CLOSED immÃ©diatement           â”‚
   â”‚                                â”‚  Timeout, retransmission
   â”‚         ????          <â”€â”€â”€ FIN â”‚
   â”‚ Port fermÃ©                     â”‚
   â”‚ RST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
   â”‚                                â”‚  ğŸ’¥ Fermeture brutale !

Avec TIME-WAIT :

Client                          Serveur
   â”‚                                â”‚
   â”‚ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€X       â”‚  â† ACK perdu
   â”‚ TIME-WAIT (60s)                â”‚
   â”‚                                â”‚  Timeout, retransmission
   â”‚         OK !          <â”€â”€â”€ FIN â”‚
   â”‚ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚  âœ“ Retransmis
   â”‚                                â”‚  CLOSED
   â”‚ Continue TIME-WAIT             â”‚
```

#### ProblÃ¨me 2 : Segments retardÃ©s d'anciennes connexions

```
ProblÃ¨me : RÃ©utilisation rapide du mÃªme quintuplet

Sans TIME-WAIT :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
t=0s    : Connexion 1 : (IP_A:1000 â†’ IP_B:80)
          DonnÃ©es : SEQ=5000
          Fermeture
t=0.1s  : Connexion 2 : (IP_A:1000 â†’ IP_B:80)  â† MÃªme ports !
          Nouvelle connexion commence SEQ=1000
t=0.5s  : âš ï¸ Segment retardÃ© de Connexion 1 arrive !
          SEQ=5000 avec anciennes donnÃ©es
          ğŸ’¥ Confusion ! Corruption de donnÃ©es !

Avec TIME-WAIT :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
t=0s    : Connexion 1 ferme
          TIME-WAIT pendant 60s
t=0-60s : RÃ©utilisation du port 1000 impossible
          Les anciens segments expireront (TTL)
t=60s   : Port 1000 libÃ©rÃ©, rÃ©utilisation sÃ»re
```

### DurÃ©e de TIME-WAIT

```
TIME-WAIT = 2 Ã— MSL

MSL (Maximum Segment Lifetime) :
- Temps maximum qu'un segment peut exister sur Internet
- Valeur typique : 30-60 secondes
- 2Ã—MSL : 60-120 secondes

Pourquoi 2Ã—MSL ?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MSL 1 : Pour que l'ACK final arrive
MSL 2 : Pour que la retransmission FIN arrive et soit ACK
```

**Configuration systÃ¨me** :

```bash
# Linux : MSL configurÃ© dans le kernel
# /include/net/tcp.h
#define TCP_TIMEWAIT_LEN (60*HZ)  /* 60 secondes */

# BSD : Traditionellement 2Ã—MSL = 2Ã—60s = 120s
# Moderne : Souvent rÃ©duit Ã  60s
```

### Le problÃ¨me des serveurs Ã  forte charge

Sur un serveur web trÃ¨s sollicitÃ© :

```
ScÃ©nario : 10 000 requÃªtes/seconde

Chaque requÃªte HTTP/1.0 :
- Nouvelle connexion TCP
- Ã‰change HTTP
- Fermeture connexion
- Serveur en TIME-WAIT pendant 60s

Calcul :
â”€â”€â”€â”€â”€â”€â”€â”€
10 000 req/s Ã— 60s = 600 000 connexions en TIME-WAIT !

Chaque socket consomme :
- MÃ©moire kernel (~4 Ko)
- EntrÃ©e dans la table de connexions
- Limite systÃ¨me : ~65000 ports locaux

RÃ©sultat : Ã‰puisement des ressources ğŸ’¥
```

**SymptÃ´mes** :

```bash
# VÃ©rifier le nombre de TIME-WAIT
ss -tan state time-wait | wc -l
543210  â† Trop Ã©levÃ© !

# Erreur typique dans les logs
bind: Cannot assign requested address
accept: Too many open files

# Application ne peut plus accepter de connexions
```

### Solutions au problÃ¨me TIME-WAIT

#### Solution 1 : SO_REUSEADDR

Permet de rÃ©utiliser un port en TIME-WAIT pour un nouveau bind().

```c
// Code serveur
int opt = 1;
setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
bind(sock, ...);
```

**Usage** : Surtout pour redÃ©marrer rapidement un serveur.

#### Solution 2 : SO_LINGER

Force la fermeture immÃ©diate sans TIME-WAIT.

```c
struct linger sl;
sl.l_onoff = 1;     // Activer
sl.l_linger = 0;    // Timeout 0 = fermeture immÃ©diate (RST)
setsockopt(sock, SOL_SOCKET, SO_LINGER, &sl, sizeof(sl));
```

**âš ï¸ Danger** :
- Perte potentielle de donnÃ©es en transit
- Pas de TIME-WAIT â†’ risque de segments retardÃ©s
- Ã€ utiliser avec prÃ©caution !

#### Solution 3 : tcp_tw_reuse (Linux)

Permet de rÃ©utiliser les sockets en TIME-WAIT pour de **nouvelles connexions sortantes**.

```bash
# Activer (cÃ´tÃ© client seulement)
sysctl -w net.ipv4.tcp_tw_reuse=1

# Ne fonctionne QUE pour les connexions sortantes
# Utilise les timestamps TCP pour Ã©viter les problÃ¨mes
```

**MÃ©canisme** :

```
Connexion sortante :
Client cherche un port local libre
â†’ Port en TIME-WAIT trouvÃ©
â†’ VÃ©rifie timestamp : nouvelle connexion > ancienne ?
â†’ Si oui : rÃ©utilisation sÃ»re
â†’ Si non : cherche un autre port
```

#### Solution 4 : tcp_tw_recycle (DÃ‰PRÃ‰CIÃ‰)

```bash
# âŒ NE PLUS UTILISER
# sysctl -w net.ipv4.tcp_tw_recycle=1

# RetirÃ© depuis Linux 4.12
# Causait des problÃ¨mes avec NAT et load balancers
```

#### Solution 5 : Connexions persistantes (HTTP/1.1)

Ã‰viter de fermer/rouvrir les connexions :

```
HTTP/1.0 (connexion par requÃªte) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RequÃªte 1 : Connexion â†’ GET â†’ RÃ©ponse â†’ Fermeture
RequÃªte 2 : Connexion â†’ GET â†’ RÃ©ponse â†’ Fermeture
RequÃªte 3 : Connexion â†’ GET â†’ RÃ©ponse â†’ Fermeture

â†’ 3 TIME-WAIT


HTTP/1.1 (connexion persistante) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Connexion â†’ GET â†’ RÃ©ponse
         â†’ GET â†’ RÃ©ponse
         â†’ GET â†’ RÃ©ponse
         â†’ Fermeture

â†’ 1 seul TIME-WAIT pour 3 requÃªtes âœ“
```

**En-tÃªte HTTP** :

```http
Connection: keep-alive
Keep-Alive: timeout=5, max=100
```

#### Solution 6 : Augmenter la plage de ports

```bash
# Linux : plage de ports Ã©phÃ©mÃ¨res par dÃ©faut
cat /proc/sys/net/ipv4/ip_local_port_range
32768   60999  # ~28000 ports

# Augmenter la plage
echo "10000 65000" > /proc/sys/net/ipv4/ip_local_port_range
# â†’ 55000 ports disponibles
```

## Half-Close : fermeture partielle

TCP permet Ã  une application de fermer l'envoi tout en continuant Ã  recevoir.

### Principe

```
Application A                    Application B
     â”‚                                â”‚
     â”‚ DonnÃ©es â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es   â”‚
     â”‚                                â”‚
     â”‚ shutdown(SHUT_WR)              â”‚
     â”‚ = Ferme l'envoi seulement      â”‚
     â”‚                                â”‚
     â”‚ FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK  â”‚
     â”‚                                â”‚
     â”‚ Plus d'envoi possible âŒ       â”‚
     â”‚ Mais rÃ©ception OK âœ“            â”‚
     â”‚                                â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es   â”‚  â† Continue
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es   â”‚
     â”‚ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FIN   â”‚
     â”‚ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
     â”‚                                â”‚
     â”‚ Fermeture complÃ¨te             â”‚
```

### Code exemple

```c
// Fermeture partielle (half-close)
shutdown(sock, SHUT_WR);  // Ferme l'envoi
                          // Envoie FIN
                          // Mais recv() fonctionne encore

// Continuer Ã  recevoir
while ((n = recv(sock, buf, sizeof(buf), 0)) > 0) {
    process(buf, n);
}

// Fermeture complÃ¨te
close(sock);
```

**Options de shutdown** :

```c
SHUT_RD   : Ferme la rÃ©ception (rare)
SHUT_WR   : Ferme l'envoi (half-close classique)
SHUT_RDWR : Ferme les deux (Ã©quivalent Ã  close())
```

### Exemple pratique : Client HTTP

```c
// Client HTTP simple

// 1. Envoyer la requÃªte
send(sock, "GET / HTTP/1.1\r\n...", ...);

// 2. Indiquer fin de la requÃªte
shutdown(sock, SHUT_WR);  // Envoie FIN

// 3. Recevoir la rÃ©ponse complÃ¨te
while ((n = recv(sock, buf, sizeof(buf), 0)) > 0) {
    write(STDOUT_FILENO, buf, n);
}
// recv() retourne 0 quand serveur ferme (FIN reÃ§u)

// 4. Fermeture complÃ¨te
close(sock);
```

## Fermeture brutale avec RST

### Fermeture normale vs brutale

```
Fermeture gracieuse (FIN) :        Fermeture brutale (RST) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Toutes les donnÃ©es envoyÃ©es      â€¢ Abandon immÃ©diat
â€¢ Acquittements complets            â€¢ Pas de garantie
â€¢ 4-way handshake                   â€¢ 1 seul segment RST
â€¢ TIME-WAIT                         â€¢ Pas de TIME-WAIT
â€¢ Propre et fiable âœ“               â€¢ Rapide mais brutal âš¡
```

### Quand TCP envoie un RST

#### Cas 1 : Connexion Ã  un port fermÃ©

```
Client                          Serveur
   â”‚                               â”‚
   â”‚ SYN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>  â”‚
   â”‚                               â”‚ Port 8080 fermÃ© âŒ
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ RST, ACK â”€â”€â”€â”€â”€  â”‚
   â”‚                               â”‚
   â”‚ Connection refused            â”‚
```

#### Cas 2 : Fermeture avec SO_LINGER = 0

```c
struct linger sl;
sl.l_onoff = 1;
sl.l_linger = 0;  // Timeout 0 = RST
setsockopt(sock, SOL_SOCKET, SO_LINGER, &sl, sizeof(sl));
close(sock);  // Envoie RST immÃ©diatement
```

```
Client                          Serveur
   â”‚                               â”‚
   â”‚ RST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>  â”‚
   â”‚                               â”‚
   â”‚ Connexion terminÃ©e brutalementâ”‚
   â”‚ DonnÃ©es potentiellement perdues
```

#### Cas 3 : DonnÃ©es reÃ§ues aprÃ¨s fermeture

```
Client                          Serveur
   â”‚                               â”‚
   â”‚ FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>  â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK   â”‚
   â”‚ close(sock)                   â”‚
   â”‚ Socket fermÃ© localement       â”‚
   â”‚                               â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DonnÃ©es  â”‚  â† DonnÃ©es aprÃ¨s FIN !
   â”‚ RST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  â† Rejet brutal
   â”‚                               â”‚
```

#### Cas 4 : Erreur de protocole

```
Exemples dÃ©clenchant RST :
â€¢ Segment avec mauvais checksum
â€¢ NumÃ©ro de sÃ©quence invalide
â€¢ Connexion introuvable
â€¢ Timeout d'inactivitÃ© (keep-alive)
```

### Segment RST

```
Segment RST :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Port Source      : 54321                 â”‚
â”‚ Port Destination : 443                   â”‚
â”‚ NumÃ©ro SEQ       : 5000                  â”‚
â”‚ NumÃ©ro ACK       : 8000                  â”‚
â”‚ Flags            : RST = 1, ACK = 1      â”‚
â”‚ Pas de donnÃ©es                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ou (si pas de connexion existante) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Flags            : RST = 1               â”‚
â”‚ (ACK peut Ãªtre 0)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Important** :
- RST n'est **jamais acquittÃ©**
- La connexion est **immÃ©diatement terminÃ©e**
- **Pas de TIME-WAIT**
- Les deux cÃ´tÃ©s passent directement Ã  CLOSED

### DÃ©tecter un RST dans le code

```c
// Lecture aprÃ¨s RST
n = recv(sock, buf, sizeof(buf), 0);
if (n < 0) {
    if (errno == ECONNRESET) {
        printf("Connexion rÃ©initialisÃ©e par le peer (RST reÃ§u)\n");
    }
}

// Ã‰criture aprÃ¨s RST
n = send(sock, buf, len, 0);
if (n < 0) {
    if (errno == EPIPE || errno == ECONNRESET) {
        printf("Connexion brisÃ©e\n");
        // Souvent : SIGPIPE aussi envoyÃ© (signal)
    }
}
```

## Fermeture simultanÃ©e

Cas rare : les deux cÃ´tÃ©s ferment en mÃªme temps.

```
Client                         Serveur
   â”‚                              â”‚
   â”‚ FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FIN  â”‚  â† EnvoyÃ© avant de voir le FIN client
   â”‚                              â”‚
   â”‚ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK  â”‚
   â”‚                              â”‚
   â”‚ Les deux passent directement â”‚
   â”‚ en TIME-WAIT                 â”‚
```

**RÃ©sultat** : Les deux cÃ´tÃ©s passent en TIME-WAIT (au lieu d'un seul habituellement).

## Exemple complet : Session HTTP/1.0

```
Session HTTP/1.0 complÃ¨te :

 0ms   Client                          Serveur
       â”‚                                  â”‚
       â”‚ â”€â”€â”€â”€â”€â”€â”€ SYN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
 25ms  â”‚<â”€â”€â”€â”€â”€â”€ SYN-ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
 26ms  â”‚ â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
       â”‚                                  â”‚
       â”‚ âœ“ Connexion Ã©tablie              â”‚
       â”‚                                  â”‚
 27ms  â”‚ â”€â”€â”€â”€ GET / HTTP/1.0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
       â”‚      Host: exemple.com           â”‚
       â”‚                                  â”‚
 52ms  â”‚<â”€â”€â”€â”€ HTTP/1.1 200 OK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
       â”‚<â”€â”€â”€â”€ Content-Length: 1234 â”€â”€â”€â”€â”€â”€â”€â”‚
       â”‚<â”€â”€â”€â”€ <html>... â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
       â”‚                                  â”‚
 77ms  â”‚<â”€â”€â”€â”€â”€â”€â”€ FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  â† Serveur ferme
       â”‚ â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚    (HTTP/1.0)
       â”‚                                  â”‚
 78ms  â”‚ Application lit les donnÃ©es      â”‚
       â”‚ Appelle close()                  â”‚
       â”‚                                  â”‚
 79ms  â”‚ â”€â”€â”€â”€â”€â”€â”€ FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
 104ms â”‚<â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
       â”‚                                  â”‚
       â”‚ TIME-WAIT (60s)                  â”‚  CLOSED
       â”‚                                  â”‚
 60s   â”‚ CLOSED                           â”‚
```

**Notes** :
- Total : ~104ms pour la transaction complÃ¨te
- Serveur initie la fermeture (typique en HTTP/1.0)
- Client entre en TIME-WAIT
- En production, HTTP/1.1 Keep-Alive Ã©vite ces fermetures rÃ©pÃ©tÃ©es

## Capture Wireshark

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frame 42: Client â†’ Serveur [FIN, ACK]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Time: 5.123456
Source: 192.168.1.10
Destination: 93.184.216.34
Protocol: TCP
Info: 54321 â†’ 443 [FIN, ACK] Seq=1234 Ack=5678 Win=65535 Len=0

Transmission Control Protocol
    Source Port: 54321
    Destination Port: 443
    Sequence number: 1234
    Acknowledgment number: 5678
    Header Length: 20 bytes
    Flags: 0x011 (FIN, ACK)
        .... .... .... ...1 = FIN: Set âœ“
        .... .... .... ..0. = SYN: Not set
        .... .... .... .0.. = RST: Not set
        .... .... .... 0... = PSH: Not set
        .... .... ...1 .... = ACK: Set âœ“
    Window size value: 65535
    Checksum: 0x8a3c [correct]

[SEQ/ACK analysis]
    This is a FIN segment

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frame 43: Serveur â†’ Client [ACK]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Time: 5.148770
Source: 93.184.216.34
Destination: 192.168.1.10
Protocol: TCP
Info: 443 â†’ 54321 [ACK] Seq=5678 Ack=1235 Win=65535 Len=0

Transmission Control Protocol
    Acknowledgment number: 1235  â† SEQ du FIN + 1
    Flags: 0x010 (ACK)

[SEQ/ACK analysis]
    This is an ACK to the segment in frame: 42

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frame 44: Serveur â†’ Client [FIN, ACK]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Time: 5.234567
Source: 93.184.216.34
Destination: 192.168.1.10
Protocol: TCP
Info: 443 â†’ 54321 [FIN, ACK] Seq=5678 Ack=1235 Win=0 Len=0

Transmission Control Protocol
    Flags: 0x011 (FIN, ACK)
    Window size value: 0  â† Souvent 0 lors de FIN

[SEQ/ACK analysis]
    This is a FIN segment

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frame 45: Client â†’ Serveur [ACK]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Time: 5.235355
Source: 192.168.1.10
Destination: 93.184.216.34
Protocol: TCP
Info: 54321 â†’ 443 [ACK] Seq=1235 Ack=5679 Win=65535 Len=0

Transmission Control Protocol
    Acknowledgment number: 5679  â† SEQ du FIN + 1
    Flags: 0x010 (ACK)

[SEQ/ACK analysis]
    This is an ACK to the segment in frame: 44
    [TCP Analysis Flags]
        âœ“ This is a TCP FIN acknowledgment
```

## Diagnostic et dÃ©pannage

### Commandes utiles

```bash
# Voir toutes les connexions et leurs Ã©tats
ss -tan

# Filtrer par Ã©tat
ss -tan state fin-wait-1
ss -tan state fin-wait-2
ss -tan state close-wait
ss -tan state last-ack
ss -tan state time-wait

# Compter les connexions en TIME-WAIT
ss -tan state time-wait | wc -l

# Statistiques globales
ss -s
TCP:   1234 (estab 456, timewait 678, closed 890)

# Avec netstat (ancien mais toujours utile)
netstat -an | grep TIME_WAIT | wc -l
netstat -an | grep CLOSE_WAIT
```

### ProblÃ¨mes courants

#### 1. Trop de TIME-WAIT

**SymptÃ´me** :
```bash
ss -s
TCP: timewait 45000  â† ProblÃ¨me !
```

**Causes** :
- Trop de connexions courtes (HTTP/1.0)
- Serveur Ã  forte charge
- Pas de keep-alive

**Solutions** :
```bash
# Activer tcp_tw_reuse (client)
sysctl -w net.ipv4.tcp_tw_reuse=1

# Augmenter les ports disponibles
echo "10000 65000" > /proc/sys/net/ipv4/ip_local_port_range

# Application : utiliser keep-alive HTTP/1.1
Connection: keep-alive
```

#### 2. Accumulation de CLOSE-WAIT

**SymptÃ´me** :
```bash
ss -tan state close-wait | wc -l
15000  â† Bug applicatif !
```

**Cause** : L'application ne ferme pas les sockets aprÃ¨s avoir reÃ§u un FIN.

**Code buguÃ©** :
```python
# Python - Bug
sock.recv(1024)  # ReÃ§oit EOF (FIN)
# ... mais ne ferme jamais sock.close()
# â†’ Socket reste en CLOSE-WAIT indÃ©finiment
```

**Solution** : Toujours fermer les sockets

```python
try:
    data = sock.recv(1024)
    if not data:  # EOF reÃ§u (FIN)
        sock.close()  # â† IMPORTANT !
finally:
    sock.close()
```

#### 3. Connexions bloquÃ©es en FIN-WAIT-2

**SymptÃ´me** :
```bash
ss -tan state fin-wait-2 | wc -l
5000
```

**Cause** : L'autre cÃ´tÃ© n'envoie jamais de FIN (application qui ne ferme pas ou crash).

**Solution** :
```bash
# RÃ©duire le timeout FIN-WAIT-2
sysctl -w net.ipv4.tcp_fin_timeout=30  # Au lieu de 60s
```

#### 4. RST inattendus

**SymptÃ´mes dans les logs** :
```
Connection reset by peer
Broken pipe
ECONNRESET
```

**Causes possibles** :
- Firewall qui coupe la connexion
- Application qui utilise SO_LINGER avec timeout 0
- Timeout applicatif cÃ´tÃ© serveur
- DonnÃ©es envoyÃ©es aprÃ¨s FIN reÃ§u

**Debug** :
```bash
# Capturer les RST avec tcpdump
tcpdump -i eth0 'tcp[tcpflags] & tcp-rst != 0'

# Analyser dans Wireshark :
# Filters â†’ tcp.flags.reset==1
```

## Optimisations modernes

### HTTP/2 et HTTP/3

HTTP/2 et HTTP/3 rÃ©duisent drastiquement les fermetures de connexions :

```
HTTP/1.1 sans keep-alive :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RequÃªte 1 : Connexion â†’ GET â†’ Fermeture
RequÃªte 2 : Connexion â†’ GET â†’ Fermeture
â†’ Beaucoup de TIME-WAIT


HTTP/1.1 avec keep-alive :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Connexion â†’ GET â†’ GET â†’ GET â†’ Fermeture
â†’ Moins de TIME-WAIT


HTTP/2 :
â”€â”€â”€â”€â”€â”€â”€â”€
1 connexion TCP
Multiplexage de plusieurs streams
Connexion maintenue longtemps
â†’ TrÃ¨s peu de TIME-WAIT


HTTP/3 (QUIC over UDP) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Pas de TCP !
Pas de 3-way handshake
Pas de 4-way handshake
Pas de TIME-WAIT
â†’ ProblÃ¨me complÃ¨tement Ã©vitÃ© âœ“
```

### TCP Fast Close

Proposition (non standard) pour accÃ©lÃ©rer la fermeture :

```
4-way handshake traditionnel :   Fast Close :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FIN â†’                            FIN â†’
â† ACK                            â† FIN, ACK (combinÃ©)
â† FIN                            ACK â†’
ACK â†’
                                 3 segments au lieu de 4
4 segments, 2 RTT                2 RTT aussi, mais moins de segments
```

## RÃ©sumÃ© des Ã©tats et transitions

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Ã‰TAT          â”‚  QUI      â”‚  SIGNIFICATION                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ESTABLISHED    â”‚ Les deux  â”‚ Connexion active               â”‚
â”‚ FIN-WAIT-1     â”‚ Initiateurâ”‚ FIN envoyÃ©, attend ACK         â”‚
â”‚ FIN-WAIT-2     â”‚ Initiateurâ”‚ ACK reÃ§u, attend FIN distant   â”‚
â”‚ CLOSE-WAIT     â”‚ Passif    â”‚ FIN reÃ§u, app doit fermer      â”‚
â”‚ LAST-ACK       â”‚ Passif    â”‚ FIN envoyÃ©, attend ACK         â”‚
â”‚ TIME-WAIT      â”‚ Initiateurâ”‚ Attente sÃ©curitÃ© (2Ã—MSL)       â”‚
â”‚ CLOSED         â”‚ Les deux  â”‚ Connexion terminÃ©e             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Conclusion

La fermeture de connexion TCP est un processus sophistiquÃ© qui garantit :

**âœ… Avantages** :
- Toutes les donnÃ©es sont transmises et acquittÃ©es
- Fermeture gracieuse et propre
- Protection contre les segments retardÃ©s (TIME-WAIT)
- Support du half-close (transmission unidirectionnelle)

**âš ï¸ CoÃ»ts** :
- 4 segments rÃ©seau (vs 3 pour l'ouverture)
- 2 RTT minimum pour la fermeture complÃ¨te
- TIME-WAIT de 60-120s qui consomme des ressources
- ComplexitÃ© d'implÃ©mentation

**Points clÃ©s Ã  retenir** :

1. **4 segments** : FIN â†’ ACK â†’ FIN â†’ ACK
2. **Bidirectionnel** : Chaque sens se ferme indÃ©pendamment
3. **TIME-WAIT** : Ã‰tat critique de 60-120s cÃ´tÃ© initiateur
4. **CLOSE-WAIT** : NÃ©cessite action de l'application
5. **RST** : Fermeture brutale sans garanties
6. **Half-close** : Possible avec `shutdown()`
7. **Optimisations** : Keep-alive, HTTP/2, augmentation de ports

La comprÃ©hension du processus de fermeture est cruciale pour :
- ğŸ› Diagnostiquer les problÃ¨mes de connexion
- âš¡ Optimiser les serveurs haute performance
- ğŸ›¡ï¸ Ã‰viter les fuites de ressources
- ğŸ“Š Dimensionner correctement les systÃ¨mes

Dans la prochaine section, nous explorerons en dÃ©tail les **numÃ©ros de sÃ©quence et acquittements**, mÃ©canismes au cÅ“ur de la fiabilitÃ© de TCP.

---

**Prochaine section** : 4.5.5 NumÃ©ros de sÃ©quence et acquittements

â­ï¸ [NumÃ©ros de sÃ©quence et acquittements](/04-couche-transport/05.5-tcp-numeros-sequence.md)
