ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 4.4.1 CaractÃ©ristiques et cas d'usage

## Introduction

UDP possÃ¨de un ensemble de caractÃ©ristiques qui le distinguent radicalement de TCP. Ces caractÃ©ristiques, qui peuvent sembler Ãªtre des limitations au premier abord, sont en rÃ©alitÃ© des **choix de conception dÃ©libÃ©rÃ©s** qui rendent UDP parfaitement adaptÃ© Ã  certains types d'applications.

Dans cette section, nous allons analyser en profondeur chaque caractÃ©ristique d'UDP et explorer les cas d'usage concrets oÃ¹ ces propriÃ©tÃ©s deviennent des avantages dÃ©cisifs.

## CaractÃ©ristiques fondamentales d'UDP

### 1. Communication sans connexion (Connectionless)

#### Description

UDP est un protocole **sans connexion** (connectionless). Il n'y a aucune phase d'Ã©tablissement ou de fermeture de connexion.

**ConsÃ©quences pratiques** :

```
Avec TCP :
  Client                          Serveur
    â”‚                                â”‚
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€ SYN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  \
    â”‚<â”€â”€â”€â”€â”€â”€SYN+ACKâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   â”‚ Handshake
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  /  (dÃ©lai : ~50-100ms)
    â”‚                                â”‚
    â”‚â”€â”€â”€â”€â”€â”€ DonnÃ©es â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Ã‰change
    â”‚<â”€â”€â”€â”€â”€ DonnÃ©es â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
    â”‚                                â”‚
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€ FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  \
    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   â”‚ Fermeture
    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€ FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   â”‚ (dÃ©lai : ~50-100ms)
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  /

Avec UDP :
  Client                          Serveur
    â”‚                                â”‚
    â”‚â”€â”€â”€â”€â”€â”€ Datagramme â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Envoi immÃ©diat
    â”‚<â”€â”€â”€â”€â”€ Datagramme â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  RÃ©ponse immÃ©diate
    â”‚                                â”‚
```

#### Avantages

- âœ… **Latence rÃ©duite** : Pas de dÃ©lai d'Ã©tablissement de connexion
- âœ… **Overhead minimal** : Ã‰conomie de 7 paquets (3 handshake + 4 fermeture)
- âœ… **SimplicitÃ©** : Le code est plus simple, moins de gestion d'Ã©tat

#### Exemple concret : RequÃªte DNS

```python
import socket
import time

# DNS query pour google.com
dns_query = b'\xab\xcd\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00' \
            b'\x06google\x03com\x00\x00\x01\x00\x01'

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(2)

start = time.time()

# Envoi immÃ©diat de la requÃªte (pas de connexion)
sock.sendto(dns_query, ("8.8.8.8", 53))

# RÃ©ception de la rÃ©ponse
response, _ = sock.recvfrom(512)

end = time.time()

print(f"Temps de rÃ©solution DNS : {(end - start) * 1000:.2f} ms")
# Typiquement : 15-30 ms

sock.close()
```

**RÃ©sultat typique** : 15-30 ms pour une rÃ©solution DNS complÃ¨te.

**Avec TCP, le mÃªme Ã©change prendrait** : 80-150 ms (incluant le handshake et la fermeture).

Pour une simple requÃªte DNS, **TCP multiplierait la latence par 4-5**.

### 2. Non fiabilitÃ© (Unreliable)

#### Description

UDP **ne garantit pas la livraison** des datagrammes. Un datagramme peut :
- Se perdre complÃ¨tement
- ÃŠtre ignorÃ© si corrompu
- Ne jamais Ãªtre retransmis

**Aucun mÃ©canisme de retransmission automatique n'existe dans UDP**.

#### Analogie : Lancer des balles de tennis

```
Vous (expÃ©diteur) lancez 10 balles de tennis Ã  un ami (rÃ©cepteur)
Ã  l'autre bout d'un terrain.

Avec UDP :
  â€¢ Vous lancez les 10 balles
  â€¢ Votre ami en attrape 8
  â€¢ 2 tombent au sol
  â€¢ Vous ne savez pas combien il en a attrapÃ©
  â€¢ Vous ne relancez pas les balles perdues

Avec TCP :
  â€¢ Vous lancez une balle
  â€¢ Votre ami crie "J'ai la 1 !"
  â€¢ Vous lancez la deuxiÃ¨me
  â€¢ Votre ami crie "J'ai la 2 !"
  â€¢ Si une balle tombe, il crie "Relance la 5 !"
  â€¢ Vous Ãªtes sÃ»r qu'il a tout reÃ§u
```

#### Taux de perte typiques

Sur Internet :
- **RÃ©seau stable** : 0.1-1% de perte
- **Wi-Fi** : 1-5% de perte
- **RÃ©seau mobile (4G/5G)** : 2-10% de perte
- **RÃ©seau congestionnÃ©** : 10-30% de perte

#### Exemple concret : Streaming audio

```
Podcast en streaming (128 kbps) :
  â€¢ DurÃ©e : 30 minutes
  â€¢ DonnÃ©es : ~28 MB
  â€¢ Datagrammes : ~20 000 datagrammes

Avec 1% de perte :
  â€¢ Datagrammes perdus : ~200
  â€¢ Impact sur l'audio : Micro-coupures imperceptibles
  â€¢ Acceptable ? OUI

Avec TCP :
  â€¢ Les 200 paquets perdus seraient retransmis
  â€¢ Blocage des paquets suivants en attente
  â€¢ Latence variable : pics Ã  500+ ms
  â€¢ Audio saccadÃ© et dÃ©calÃ©
  â€¢ Acceptable ? NON
```

**Conclusion** : Pour l'audio en temps rÃ©el, **mieux vaut perdre 1% que tout retransmettre**.

### 3. Pas de garantie d'ordre (Unordered)

#### Description

Les datagrammes UDP peuvent arriver **dans un ordre diffÃ©rent** de celui d'envoi. UDP livre les datagrammes dans l'ordre oÃ¹ ils arrivent au niveau IP, sans tentative de rÃ©ordonnancement.

#### Visualisation

```
Envoi par l'application :
  Datagramme A â†’ Datagramme B â†’ Datagramme C â†’ Datagramme D

Transit dans le rÃ©seau :
  â€¢ A emprunte route 1 (rapide)
  â€¢ B emprunte route 2 (lente)
  â€¢ C emprunte route 1 (rapide)
  â€¢ D emprunte route 2 (lente)

RÃ©ception par l'application :
  Datagramme A â†’ Datagramme C â†’ Datagramme B â†’ Datagramme D
                      â†‘              â†‘
                    DÃ©sordre !     DÃ©sordre !
```

#### Exemple concret : Jeu multijoueur

```python
# Serveur de jeu envoie les positions de tous les joueurs

# Frame 1 (t=0ms)
send_udp({
    "frame": 1,
    "players": [
        {"id": 1, "x": 100, "y": 200},
        {"id": 2, "x": 150, "y": 300}
    ]
})

# Frame 2 (t=16ms)
send_udp({
    "frame": 2,
    "players": [
        {"id": 1, "x": 102, "y": 201},
        {"id": 2, "x": 152, "y": 301}
    ]
})

# Frame 3 (t=32ms)
send_udp({
    "frame": 3,
    "players": [
        {"id": 1, "x": 104, "y": 202},
        {"id": 2, "x": 154, "y": 302}
    ]
})
```

**RÃ©ception possible** : Frame 1 â†’ Frame 3 â†’ Frame 2

**Solution applicative** : Le client vÃ©rifie le numÃ©ro de frame et ignore les frames obsolÃ¨tes.

```python
# CÃ´tÃ© client
last_frame_processed = 0

def on_receive_udp(data):
    frame_num = data["frame"]

    if frame_num > last_frame_processed:
        # Frame plus rÃ©cente, on l'applique
        update_player_positions(data["players"])
        last_frame_processed = frame_num
    else:
        # Frame ancienne, on l'ignore
        print(f"Frame {frame_num} ignorÃ©e (obsolÃ¨te)")
```

**Philosophie** : Dans un jeu, **une vieille position est inutile**. Autant l'ignorer et passer Ã  la suivante.

### 4. Pas de contrÃ´le de flux

#### Description

UDP n'a **aucun mÃ©canisme de contrÃ´le de flux**. L'expÃ©diteur peut envoyer aussi vite qu'il le souhaite, mÃªme si le rÃ©cepteur ne peut pas suivre.

#### ProblÃ¨me potentiel : Buffer overflow

```
ExpÃ©diteur puissant (serveur) : 1 Gbps
RÃ©cepteur lent (smartphone) : 10 Mbps

Sans contrÃ´le de flux :
  Serveur envoie : 1000 datagrammes/seconde
  Smartphone peut traiter : 100 datagrammes/seconde

  Buffer du smartphone :
    [Datagramme 1][Datagramme 2]...[Datagramme 100] â† PLEIN

  Datagrammes 101-1000 : PERDUS (buffer plein)
```

#### Solution applicative : Rate limiting

```python
import time

def send_video_stream(sock, video_data, target_bitrate):
    """
    Envoie un flux vidÃ©o avec contrÃ´le de dÃ©bit applicatif
    """
    bytes_per_second = target_bitrate / 8
    chunk_size = 1400  # Taille d'un datagramme
    delay_per_chunk = chunk_size / bytes_per_second

    for chunk in video_data:
        sock.sendto(chunk, destination)
        time.sleep(delay_per_chunk)  # Ralentir l'envoi
```

**L'application doit implÃ©menter son propre contrÃ´le de dÃ©bit**.

### 5. Pas de contrÃ´le de congestion

#### Description

UDP n'a **aucun mÃ©canisme de contrÃ´le de congestion**. Il continue d'envoyer au mÃªme rythme mÃªme si le rÃ©seau est saturÃ©.

#### ProblÃ¨me pour le rÃ©seau

```
ScÃ©nario : Routeur intermÃ©diaire avec lien Ã  100 Mbps

Trafic entrant :
  â€¢ 50 flux TCP : 80 Mbps (s'adaptent automatiquement)
  â€¢ 10 flux UDP : 50 Mbps (n'adaptent pas)

Total : 130 Mbps â†’ Le routeur doit choisir quoi droper

RÃ©sultat typique :
  â€¢ TCP dÃ©tecte la congestion et rÃ©duit Ã  60 Mbps
  â€¢ UDP continue Ã  50 Mbps
  â€¢ Total : 110 Mbps â†’ encore trop

Cycle vicieux :
  â€¢ TCP rÃ©duit encore (40 Mbps)
  â€¢ UDP reste Ã  50 Mbps
  â€¢ UDP "Ã©touffe" TCP
```

**ConsÃ©quence** : Les flux UDP peuvent Ãªtre **Ã©goÃ¯stes** et pÃ©naliser les flux TCP.

#### ResponsabilitÃ© Ã©thique

Les applications UDP ont une **responsabilitÃ© Ã©thique** de ne pas saturer le rÃ©seau.

**Bonnes pratiques** :

```python
class ResponsibleUDPSender:
    def __init__(self):
        self.rate = 1_000_000  # 1 Mbps initial
        self.packet_loss_rate = 0.0

    def on_feedback(self, lost_packets, total_packets):
        """Ajuste le dÃ©bit basÃ© sur les pertes"""
        self.packet_loss_rate = lost_packets / total_packets

        if self.packet_loss_rate > 0.05:  # Plus de 5% de perte
            self.rate *= 0.8  # RÃ©duire de 20%
        elif self.packet_loss_rate < 0.01:  # Moins de 1% de perte
            self.rate *= 1.1  # Augmenter de 10%

    def send(self, data):
        # Envoyer Ã  self.rate
        pass
```

### 6. Messagerie orientÃ©e message (Message-oriented)

#### Description

UDP prÃ©serve les **frontiÃ¨res des messages**. Chaque `sendto()` correspond Ã  un datagramme distinct qui sera reÃ§u en un seul `recvfrom()`.

#### Comparaison avec TCP

```python
# AVEC TCP (Stream-oriented)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ExpÃ©diteur envoie 3 messages
sock.send(b"Message1")
sock.send(b"Message2")
sock.send(b"Message3")

# RÃ©cepteur peut recevoir de plusieurs faÃ§ons :
data = sock.recv(1024)
# PossibilitÃ© 1 : b"Message1Message2Message3" (tout d'un coup)
# PossibilitÃ© 2 : b"Message1Mess" (puis "age2Message3" au recv suivant)
# PossibilitÃ© 3 : b"M" (puis "essage1Message2" puis "Message3")

# L'application doit dÃ©limiter les messages elle-mÃªme !


# AVEC UDP (Message-oriented)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ExpÃ©diteur envoie 3 messages
sock.sendto(b"Message1", dest)
sock.sendto(b"Message2", dest)
sock.sendto(b"Message3", dest)

# RÃ©cepteur reÃ§oit TOUJOURS des messages complets
data1, addr = sock.recvfrom(1024)  # b"Message1"
data2, addr = sock.recvfrom(1024)  # b"Message2"
data3, addr = sock.recvfrom(1024)  # b"Message3"

# Les frontiÃ¨res des messages sont prÃ©servÃ©es !
```

#### Avantage pratique

```python
# Protocole de communication simple avec UDP
import json

def send_command(sock, command, params):
    """Envoie une commande structurÃ©e"""
    message = json.dumps({
        "command": command,
        "params": params
    }).encode()
    sock.sendto(message, server_address)

def receive_command(sock):
    """ReÃ§oit une commande complÃ¨te"""
    data, addr = sock.recvfrom(4096)
    command = json.loads(data.decode())
    return command, addr

# Utilisation
send_command(sock, "MOVE", {"x": 100, "y": 200})
send_command(sock, "FIRE", {"angle": 45})

# RÃ©ception : chaque commande arrive complÃ¨te
cmd1, _ = receive_command(sock)  # {"command": "MOVE", ...}
cmd2, _ = receive_command(sock)  # {"command": "FIRE", ...}
```

**Avec TCP, il faudrait implÃ©menter un protocole de dÃ©limitation** (longueur, sÃ©parateur, etc.).

### 7. Taille maximale d'un datagramme

#### Limites thÃ©oriques

- **Champ longueur UDP** : 16 bits â†’ Maximum 65 535 octets
- **En-tÃªte UDP** : 8 octets
- **DonnÃ©es maximum** : 65 535 - 8 = **65 527 octets**

#### Limites pratiques

En rÃ©alitÃ©, les datagrammes UDP sont limitÃ©s par :

1. **MTU (Maximum Transmission Unit)** : GÃ©nÃ©ralement 1500 octets (Ethernet)
2. **Fragmentation IP** : Ã‰viter absolument

```
Datagramme UDP de 5000 octets :
  â†“
FragmentÃ© en 4 paquets IP :
  â€¢ Paquet 1 : 1500 octets
  â€¢ Paquet 2 : 1500 octets
  â€¢ Paquet 3 : 1500 octets
  â€¢ Paquet 4 : 500 octets

ProblÃ¨me : Si UN SEUL fragment se perd, TOUT le datagramme est perdu.

Avec 1% de perte par paquet :
  â€¢ ProbabilitÃ© de perte d'au moins un fragment : ~4%
  â€¢ Le datagramme complet a 4% de chances d'Ãªtre perdu !
```

#### Taille recommandÃ©e

**Meilleure pratique** : Rester sous la MTU pour Ã©viter la fragmentation.

```
MTU Ethernet : 1500 octets
- En-tÃªte IP : 20 octets (minimum)
- En-tÃªte UDP : 8 octets
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DonnÃ©es UDP max : 1472 octets

Recommandation conservatrice : 1400 octets
(laisse de la marge pour encapsulation VPN, tunnels, etc.)
```

#### Exemple : Streaming vidÃ©o

```python
def send_video_frame(sock, frame_data, destination):
    """
    Envoie une frame vidÃ©o en la fragmentant en datagrammes UDP
    """
    MAX_UDP_PAYLOAD = 1400
    frame_id = generate_frame_id()

    # Fragmenter la frame
    chunks = [
        frame_data[i:i+MAX_UDP_PAYLOAD]
        for i in range(0, len(frame_data), MAX_UDP_PAYLOAD)
    ]

    # Envoyer chaque fragment
    for chunk_id, chunk in enumerate(chunks):
        packet = struct.pack(
            '>IHH',  # frame_id, chunk_id, total_chunks
            frame_id,
            chunk_id,
            len(chunks)
        ) + chunk

        sock.sendto(packet, destination)
```

## Cas d'usage dÃ©taillÃ©s d'UDP

Maintenant que nous avons analysÃ© les caractÃ©ristiques d'UDP, explorons les cas d'usage oÃ¹ ces propriÃ©tÃ©s deviennent des atouts.

### Cas 1 : DNS (Domain Name System)

#### Pourquoi UDP ?

- âœ… **RequÃªtes courtes** : Une requÃªte DNS tient dans un seul datagramme
- âœ… **Latence critique** : Chaque milliseconde compte
- âœ… **Volume Ã©levÃ©** : Des milliards de requÃªtes par jour
- âœ… **Perte acceptable** : Le client peut facilement renvoyer la requÃªte

#### Fonctionnement

```
Client : "Quelle est l'IP de www.example.com ?"

1. CrÃ©ation requÃªte DNS (50-100 octets)
2. Envoi UDP vers serveur DNS (8.8.8.8:53)
3. Attente rÃ©ponse (timeout 2-5 secondes)
4. Si pas de rÃ©ponse : renvoyer requÃªte
5. RÃ©ception rÃ©ponse (50-500 octets)
6. Extraction de l'IP

Temps total typique : 15-50 ms
```

#### Code exemple

```python
import socket
import struct

def dns_query(domain, dns_server="8.8.8.8"):
    """RequÃªte DNS simple en UDP"""

    # CrÃ©er la requÃªte DNS
    transaction_id = 0xABCD
    flags = 0x0100  # RequÃªte standard
    questions = 1

    # En-tÃªte DNS
    header = struct.pack('>HHHHHH',
                         transaction_id, flags,
                         questions, 0, 0, 0)

    # Question : domaine + type A + classe IN
    question = b''
    for part in domain.split('.'):
        question += bytes([len(part)]) + part.encode()
    question += b'\x00'  # Fin du nom
    question += struct.pack('>HH', 1, 1)  # Type A, Classe IN

    query = header + question

    # Envoyer via UDP
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(2)

    try:
        sock.sendto(query, (dns_server, 53))
        response, _ = sock.recvfrom(512)

        # Parser la rÃ©ponse (simplifiÃ©)
        # ... extraction de l'IP ...

        return "IP trouvÃ©e"
    except socket.timeout:
        return "Timeout - Renvoyer la requÃªte"
    finally:
        sock.close()

# Utilisation
result = dns_query("www.example.com")
```

#### Statistiques rÃ©elles

- **Google Public DNS (8.8.8.8)** : ~400 milliards de requÃªtes par jour
- **Latence moyenne** : 20-30 ms
- **Avec TCP** : Latence serait 3-4Ã— supÃ©rieure
- **Ã‰conomie** : Des millions d'heures de latence Ã©vitÃ©es chaque jour

### Cas 2 : Streaming vidÃ©o/audio en temps rÃ©el

#### Pourquoi UDP ?

- âœ… **Temps rÃ©el** : Latence <150 ms requise
- âœ… **Pertes acceptables** : Une image perdue sur 1000 est invisible
- âœ… **Throughput Ã©levÃ©** : VidÃ©o HD = 5-10 Mbps
- âœ… **Pas de retransmission** : Vieilles donnÃ©es inutiles

#### Protocoles utilisÃ©s

**RTP (Real-time Transport Protocol)** : Protocole au-dessus d'UDP pour le streaming

```
Application (Zoom, Discord)
         â†“
    RTP (sÃ©quenÃ§age, timestamps)
         â†“
    UDP (transport)
         â†“
    IP (routage)
```

#### Exemple : VisioconfÃ©rence

```
Flux vidÃ©o 720p @ 30 FPS :
  â€¢ Bitrate : 2 Mbps
  â€¢ Images par seconde : 30
  â€¢ Taille par image : ~8 KB
  â€¢ Datagrammes par image : ~6 (1400 octets chacun)
  â€¢ Datagrammes par seconde : ~180

Avec 2% de perte UDP :
  â€¢ Datagrammes perdus : ~4 par seconde
  â€¢ Impact : Quelques artefacts visuels imperceptibles
  â€¢ ExpÃ©rience : Fluide

Avec TCP :
  â€¢ 2% de perte â†’ retransmissions
  â€¢ Blocage en attente des retransmissions
  â€¢ Latence : pics Ã  500-1000 ms
  â€¢ ExpÃ©rience : SaccadÃ©, dÃ©calÃ©, inutilisable
```

#### Code conceptuel

```python
import socket
import time

class VideoStreamer:
    def __init__(self, destination, bitrate=2_000_000):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.destination = destination
        self.bitrate = bitrate
        self.sequence = 0

    def send_frame(self, frame_data):
        """Envoie une frame vidÃ©o"""
        timestamp = int(time.time() * 1000)

        # DÃ©couper en chunks
        chunks = self._split_frame(frame_data, 1400)

        for chunk in chunks:
            # En-tÃªte RTP simplifiÃ©
            header = struct.pack('>IIH',
                                 self.sequence,
                                 timestamp,
                                 len(chunks))

            packet = header + chunk
            self.sock.sendto(packet, self.destination)
            self.sequence += 1

        # ContrÃ´le de dÃ©bit
        self._rate_limit()

    def _rate_limit(self):
        """Limiter le dÃ©bit d'envoi"""
        # Calcul pour respecter le bitrate
        pass
```

### Cas 3 : Jeux multijoueurs en ligne

#### Pourquoi UDP ?

- âœ… **Latence ultra-faible** : <50 ms requis pour compÃ©titif
- âœ… **Mises Ã  jour frÃ©quentes** : 20-60 fois par seconde
- âœ… **DonnÃ©es Ã©phÃ©mÃ¨res** : Position Ã  t=100ms inutile Ã  t=150ms
- âœ… **Bande passante limitÃ©e** : Joueurs sur mobile/Wi-Fi

#### Architecture typique

```
Client (Joueur)                    Serveur de jeu
     â”‚                                   â”‚
     â”‚  Ã‰tat local (position, angle)     â”‚
     â”‚                                   â”‚
     â”‚â”€â”€â”€â”€â”€â”€ Update @60Hz â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚   {pos: [x, y], angle: 45}        â”‚
     â”‚                                   â”‚
     â”‚<â”€â”€â”€â”€â”€ World State @20Hz â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚   {players: [...], objects: [...]}â”‚
     â”‚                                   â”‚
```

**Philosophie** :
- **Client vers serveur** : Envoie souvent les actions du joueur (60 Hz)
- **Serveur vers clients** : Envoie l'Ã©tat du monde (20-30 Hz)
- **Perte gÃ©rÃ©e** : Interpolation et extrapolation cÃ´tÃ© client

#### Gestion intelligente des pertes

```python
class GameClient:
    def __init__(self):
        self.last_positions = {}  # Historique des positions

    def on_receive_state(self, game_state):
        """ReÃ§oit l'Ã©tat du monde"""
        current_time = time.time()

        for player in game_state["players"]:
            player_id = player["id"]

            # Stocker la position
            self.last_positions[player_id] = {
                "pos": player["pos"],
                "velocity": player["velocity"],
                "time": current_time
            }

    def get_player_position(self, player_id):
        """
        Obtient la position d'un joueur
        Utilise extrapolation si donnÃ©es anciennes
        """
        if player_id not in self.last_positions:
            return None

        data = self.last_positions[player_id]
        age = time.time() - data["time"]

        if age < 0.05:  # DonnÃ©es rÃ©centes (< 50ms)
            return data["pos"]
        else:
            # Extrapolation basÃ©e sur la vÃ©locitÃ©
            return [
                data["pos"][0] + data["velocity"][0] * age,
                data["pos"][1] + data["velocity"][1] * age
            ]
```

#### Statistiques d'un jeu populaire (ex: Fortnite)

```
Trafic par joueur :
  â€¢ Upload : 10-30 KB/s
  â€¢ Download : 50-100 KB/s
  â€¢ Latence cible : <50 ms
  â€¢ Taux de perte acceptable : <3%

Avec 100 joueurs sur un serveur :
  â€¢ Bande passante serveur : 5-10 MB/s
  â€¢ Paquets par seconde : ~10,000
  â€¢ Tout en UDP
```

### Cas 4 : VoIP (Voice over IP)

#### Pourquoi UDP ?

- âœ… **Latence conversationnelle** : <150 ms pour dialogue naturel
- âœ… **Perte masquable** : PLC (Packet Loss Concealment)
- âœ… **DÃ©bit constant** : ~64 kbps par flux audio
- âœ… **InteractivitÃ©** : Conversation bidirectionnelle

#### Codecs audio et tolÃ©rance aux pertes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Codecs VoIP et tolÃ©rance                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Codec      â”‚ Bitrate  â”‚ QualitÃ©    â”‚ Perte max OK    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ G.711      â”‚ 64 kbps  â”‚ Excellente â”‚ 1-2%            â”‚
â”‚ G.729      â”‚ 8 kbps   â”‚ Bonne      â”‚ 2-5%            â”‚
â”‚ Opus       â”‚ 16-64    â”‚ Excellente â”‚ 5-10%           â”‚
â”‚ Speex      â”‚ 8-24     â”‚ Bonne      â”‚ 3-5%            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Techniques de masquage de perte

```python
class VoIPReceiver:
    def __init__(self):
        self.jitter_buffer = []
        self.last_sequence = 0

    def on_receive_packet(self, packet):
        """ReÃ§oit un paquet audio"""
        sequence = packet["sequence"]
        audio_data = packet["audio"]

        # DÃ©tecter perte
        if sequence != self.last_sequence + 1:
            lost_count = sequence - self.last_sequence - 1
            print(f"Perte dÃ©tectÃ©e : {lost_count} paquets")

            # PLC : GÃ©nÃ©rer du son de remplacement
            for _ in range(lost_count):
                synthetic_audio = self.generate_plc()
                self.play_audio(synthetic_audio)

        # Jouer l'audio reÃ§u
        self.play_audio(audio_data)
        self.last_sequence = sequence

    def generate_plc(self):
        """
        Packet Loss Concealment
        GÃ©nÃ¨re de l'audio synthÃ©tique pour masquer la perte
        """
        # Techniques :
        # - RÃ©pÃ©ter le dernier paquet
        # - Interpoler entre paquets
        # - Silence
        # - Bruit blanc attÃ©nuÃ©
        return synthesized_audio
```

#### Exemple rÃ©el : Appel Skype

```
Appel vocal Skype :
  â€¢ Codec : Opus @ 32 kbps
  â€¢ Paquets : 50 par seconde (20 ms d'audio chacun)
  â€¢ Taille paquet : ~80 octets
  â€¢ Latence totale : 50-100 ms

Pertes observÃ©es :
  â€¢ RÃ©seau stable : 0.5-1%
  â€¢ Wi-Fi : 1-3%
  â€¢ Mobile : 2-5%

QualitÃ© perÃ§ue :
  â€¢ <2% perte : Excellente
  â€¢ 2-5% perte : Bonne (artefacts rares)
  â€¢ 5-10% perte : Acceptable (artefacts notables)
  â€¢ >10% perte : DÃ©gradÃ©e
```

### Cas 5 : DHCP (Dynamic Host Configuration Protocol)

#### Pourquoi UDP ?

- âœ… **Bootstrap** : Le client n'a pas encore d'IP !
- âœ… **Broadcast** : RequÃªte envoyÃ©e Ã  tous sur le rÃ©seau local
- âœ… **Transaction simple** : 4 messages (DORA)
- âœ… **FiabilitÃ© applicative** : Timeout et retry

#### Le processus DORA

```
Client (0.0.0.0)                    Serveur DHCP (192.168.1.1)
     â”‚                                        â”‚
     â”‚â”€â”€â”€â”€ DISCOVER (broadcast) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
     â”‚    "Y a-t-il un serveur DHCP ?"        â”‚
     â”‚    Source: 0.0.0.0:68                  â”‚
     â”‚    Dest: 255.255.255.255:67            â”‚
     â”‚                                        â”‚
     â”‚<â”€â”€â”€â”€ OFFER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚    "Voici 192.168.1.100"               â”‚
     â”‚                                        â”‚
     â”‚â”€â”€â”€â”€ REQUEST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚    "J'accepte 192.168.1.100"           â”‚
     â”‚                                        â”‚
     â”‚<â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚    "C'est confirmÃ© !"                  â”‚
     â”‚                                        â”‚
   Maintenant: 192.168.1.100
```

**Tout cela en UDP** : 4 datagrammes, ~200 ms total.

#### Gestion de la fiabilitÃ©

```python
def dhcp_discover(interface):
    """Envoie un DHCP DISCOVER et attend un OFFER"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.settimeout(5)

    discover_packet = create_dhcp_discover()

    # Tentatives avec backoff exponentiel
    for attempt in range(4):
        try:
            # Envoyer DISCOVER en broadcast
            sock.sendto(discover_packet,
                       ('255.255.255.255', 67))

            # Attendre OFFER
            data, server = sock.recvfrom(1024)
            return parse_dhcp_offer(data)

        except socket.timeout:
            timeout = 5 * (2 ** attempt)  # 5, 10, 20, 40 secondes
            print(f"Timeout, retry dans {timeout}s...")
            time.sleep(timeout)

    return None  # Ã‰chec aprÃ¨s 4 tentatives
```

### Cas 6 : IoT et capteurs

#### Pourquoi UDP ?

- âœ… **Ressources limitÃ©es** : Capteurs avec peu de mÃ©moire/CPU
- âœ… **Batterie** : UDP consomme moins d'Ã©nergie que TCP
- âœ… **DonnÃ©es pÃ©riodiques** : Mesures toutes les X secondes
- âœ… **Perte tolÃ©rable** : Manquer une mesure n'est pas critique

#### Exemple : Capteurs de tempÃ©rature

```python
class TemperatureSensor:
    def __init__(self, sensor_id, gateway_address):
        self.sensor_id = sensor_id
        self.gateway = gateway_address
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    def send_reading(self, temperature, humidity):
        """Envoie une mesure au gateway"""
        timestamp = int(time.time())

        # Paquet compact (12 octets)
        packet = struct.pack('>IHff',
                            self.sensor_id,    # 4 bytes
                            timestamp & 0xFFFF,# 2 bytes
                            temperature,       # 4 bytes
                            humidity)          # 4 bytes

        # Envoi UDP (pas de ACK attendu)
        self.sock.sendto(packet, self.gateway)
        # Ã‰conomie d'Ã©nergie : pas d'attente, sleep immÃ©diatement

    def run(self):
        """Boucle principale du capteur"""
        while True:
            temp = read_temperature_sensor()
            humidity = read_humidity_sensor()

            self.send_reading(temp, humidity)

            # Sleep 5 minutes
            time.sleep(300)
```

**Consommation Ã©nergÃ©tique comparÃ©e** :

```
Transmission TCP :
  â€¢ Handshake : 50 ms actif
  â€¢ Envoi donnÃ©es : 10 ms actif
  â€¢ Fermeture : 50 ms actif
  â€¢ Total : 110 ms actif par transmission

Transmission UDP :
  â€¢ Envoi donnÃ©es : 10 ms actif
  â€¢ Total : 10 ms actif par transmission

Ã‰conomie : 90% de temps actif en moins
â†’ Batterie dure 10Ã— plus longtemps !
```

### Cas 7 : Monitoring et mÃ©triques (SNMP, StatsD)

#### Pourquoi UDP ?

- âœ… **Volume Ã©levÃ©** : Des milliers de mÃ©triques par seconde
- âœ… **Fire and forget** : Le monitoring ne doit pas ralentir l'application
- âœ… **Perte acceptable** : Manquer une mÃ©trique parmi 1000 est OK
- âœ… **Pas de back-pressure** : L'application ne bloque jamais

#### Exemple : StatsD

```python
import socket

class StatsDClient:
    def __init__(self, host='localhost', port=8125):
        self.addr = (host, port)
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    def increment(self, metric, value=1):
        """IncrÃ©mente un compteur"""
        message = f"{metric}:{value}|c"
        self.sock.sendto(message.encode(), self.addr)
        # Pas d'attente de rÃ©ponse, on continue immÃ©diatement

    def timing(self, metric, ms):
        """Enregistre une durÃ©e"""
        message = f"{metric}:{ms}|ms"
        self.sock.sendto(message.encode(), self.addr)

    def gauge(self, metric, value):
        """Enregistre une valeur"""
        message = f"{metric}:{value}|g"
        self.sock.sendto(message.encode(), self.addr)

# Utilisation dans une application web
statsd = StatsDClient()

@app.route('/api/users')
def get_users():
    start = time.time()

    # Logique mÃ©tier
    users = fetch_users()

    # Enregistrer les mÃ©triques
    duration = (time.time() - start) * 1000
    statsd.timing('api.users.response_time', duration)
    statsd.increment('api.users.requests')

    return jsonify(users)
```

**Avantages** :
- Zero impact sur la performance de l'application
- Pas de risque de bloquer sur l'envoi de mÃ©triques
- Si le serveur de mÃ©triques est down, l'application continue

### Cas 8 : Services de dÃ©couverte (mDNS, SSDP)

#### Pourquoi UDP ?

- âœ… **Multicast** : DÃ©couvrir tous les services d'un coup
- âœ… **Zeroconf** : Pas de configuration prÃ©alable
- âœ… **RÃ©seau local** : FiabilitÃ© naturellement Ã©levÃ©e
- âœ… **LÃ©ger** : Pas besoin de TCP

#### Exemple : mDNS (Multicast DNS)

```python
import socket
import struct

MDNS_ADDRESS = '224.0.0.251'
MDNS_PORT = 5353

def discover_services(service_type='_http._tcp.local'):
    """DÃ©couvre les services HTTP sur le rÃ©seau local"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)

    # Construire la requÃªte mDNS
    query = build_mdns_query(service_type)

    # Envoyer en multicast
    sock.sendto(query, (MDNS_ADDRESS, MDNS_PORT))

    # Ã‰couter les rÃ©ponses pendant 2 secondes
    sock.settimeout(2)
    services = []

    try:
        while True:
            data, addr = sock.recvfrom(1024)
            service = parse_mdns_response(data)
            services.append(service)
    except socket.timeout:
        pass

    return services

# DÃ©couvrir toutes les imprimantes rÃ©seau
printers = discover_services('_ipp._tcp.local')
for printer in printers:
    print(f"Imprimante trouvÃ©e : {printer['name']} Ã  {printer['ip']}")
```

## CritÃ¨res de choix : UDP vs TCP

### Matrice de dÃ©cision

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Quand choisir UDP ?                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  âœ… Latence < 150 ms critique                            â”‚
â”‚  âœ… Temps rÃ©el requis                                    â”‚
â”‚  âœ… DonnÃ©es Ã©phÃ©mÃ¨res (vieilles = inutiles)              â”‚
â”‚  âœ… Perte de 1-5% acceptable                             â”‚
â”‚  âœ… Messages courts et indÃ©pendants                      â”‚
â”‚  âœ… Volume trÃ¨s Ã©levÃ© (>1000 msg/sec)                    â”‚
â”‚  âœ… Broadcast/Multicast nÃ©cessaire                       â”‚
â”‚  âœ… Overhead doit Ãªtre minimal                           â”‚
â”‚  âœ… ContrÃ´le applicatif de la fiabilitÃ© souhaitÃ©         â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Quand choisir TCP ?                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  âœ… FiabilitÃ© absolue requise                            â”‚
â”‚  âœ… Ordre des donnÃ©es important                          â”‚
â”‚  âœ… Transfert de fichiers                                â”‚
â”‚  âœ… Transactions financiÃ¨res                             â”‚
â”‚  âœ… Latence variable acceptable                          â”‚
â”‚  âœ… DonnÃ©es volumineuses (>1 MB)                         â”‚
â”‚  âœ… Perte de donnÃ©es = Ã©chec                             â”‚
â”‚  âœ… Pas de compÃ©tence en protocoles rÃ©seau               â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Tableau comparatif dÃ©taillÃ©

| CritÃ¨re | UDP | TCP |
|---------|-----|-----|
| **Latence initiale** | Nulle (envoi immÃ©diat) | ~50-100 ms (handshake) |
| **Overhead par paquet** | 8 octets | 20-60 octets |
| **FiabilitÃ©** | Aucune garantie | 100% garantie |
| **Ordre** | Non garanti | Garanti |
| **ContrÃ´le de flux** | Non | Oui (fenÃªtre) |
| **ContrÃ´le de congestion** | Non | Oui (slow start, etc.) |
| **FrontiÃ¨res messages** | PrÃ©servÃ©es | Non (stream) |
| **Broadcast/Multicast** | Oui | Non |
| **ComplexitÃ© code** | Simple | Plus complexe |
| **Use case principal** | Temps rÃ©el | Transfert fiable |

## Bonnes pratiques pour UDP

### 1. ImplÃ©menter des timeouts

```python
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(2.0)  # 2 secondes

try:
    data, addr = sock.recvfrom(1024)
except socket.timeout:
    print("Pas de rÃ©ponse dans les 2 secondes")
    # Renvoyer la requÃªte ou abandonner
```

### 2. NumÃ©roter les messages

```python
sequence_number = 0

def send_message(sock, data, dest):
    global sequence_number

    # Ajouter numÃ©ro de sÃ©quence
    packet = struct.pack('>I', sequence_number) + data
    sock.sendto(packet, dest)

    sequence_number += 1
```

### 3. ImplÃ©menter des ACK si nÃ©cessaire

```python
def send_reliable_udp(sock, data, dest, max_retries=3):
    """Envoi UDP avec ACK application"""
    message_id = generate_id()
    packet = struct.pack('>I', message_id) + data

    for attempt in range(max_retries):
        sock.sendto(packet, dest)

        try:
            # Attendre ACK
            sock.settimeout(1.0)
            ack, _ = sock.recvfrom(64)
            ack_id = struct.unpack('>I', ack[:4])[0]

            if ack_id == message_id:
                return True  # SuccÃ¨s
        except socket.timeout:
            print(f"Retry {attempt + 1}/{max_retries}")

    return False  # Ã‰chec aprÃ¨s retries
```

### 4. Limiter le dÃ©bit d'envoi

```python
import time

class RateLimiter:
    def __init__(self, rate_bps):
        self.rate = rate_bps
        self.last_send = time.time()

    def send(self, sock, data, dest):
        # Calculer le dÃ©lai nÃ©cessaire
        bytes_to_send = len(data)
        delay = bytes_to_send * 8 / self.rate

        # Attendre si nÃ©cessaire
        now = time.time()
        elapsed = now - self.last_send
        if elapsed < delay:
            time.sleep(delay - elapsed)

        # Envoyer
        sock.sendto(data, dest)
        self.last_send = time.time()
```

### 5. GÃ©rer la taille des datagrammes

```python
def fragment_data(data, max_size=1400):
    """Fragmente les donnÃ©es en chunks UDP-safe"""
    return [
        data[i:i+max_size]
        for i in range(0, len(data), max_size)
    ]

def send_large_data(sock, data, dest):
    chunks = fragment_data(data)

    for i, chunk in enumerate(chunks):
        header = struct.pack('>HH', i, len(chunks))
        sock.sendto(header + chunk, dest)
```

## Conclusion

UDP est un protocole **volontairement minimaliste** qui dÃ©lÃ¨gue la responsabilitÃ© de la fiabilitÃ© Ã  l'application. Cette approche le rend parfait pour :

**Applications temps rÃ©el** oÃ¹ la vitesse prime sur la perfection :
- VoIP, visioconfÃ©rences
- Jeux en ligne
- Streaming en direct

**Services lÃ©gers** oÃ¹ l'overhead de TCP est disproportionnÃ© :
- DNS, DHCP
- Monitoring, mÃ©triques
- DÃ©couverte de services

**Cas spÃ©ciaux** impossibles avec TCP :
- Broadcast et multicast
- Bootstrap (DHCP sans IP)

**Points clÃ©s Ã  retenir** :
- UDP ne garantit **rien**, mais est **rapide**
- L'application doit gÃ©rer la fiabilitÃ© si nÃ©cessaire
- Parfait pour donnÃ©es Ã©phÃ©mÃ¨res et temps rÃ©el
- Requiert une conception applicative rÃ©flÃ©chie

Dans la section suivante, nous examinerons en dÃ©tail le format d'un datagramme UDP pour comprendre sa structure interne et son en-tÃªte de seulement 8 octets.

---

**Ã€ retenir** :

- âœ… UDP = **minimaliste** : 8 octets d'en-tÃªte seulement
- âœ… **Sans connexion** : Pas de handshake, envoi immÃ©diat
- âœ… **Non fiable** : Pertes possibles, pas de retransmission
- âœ… **Pas d'ordre** : RÃ©ception potentiellement dÃ©sordonnÃ©e
- âœ… **Message-oriented** : FrontiÃ¨res des messages prÃ©servÃ©es
- âœ… **Cas d'usage** : Temps rÃ©el, DNS, VoIP, gaming, IoT
- âœ… **ResponsabilitÃ©** : L'application gÃ¨re la fiabilitÃ© si nÃ©cessaire
- âœ… **Taille recommandÃ©e** : â‰¤1400 octets pour Ã©viter fragmentation
- âœ… **Bonnes pratiques** : Timeouts, numÃ©rotation, rate limiting

â­ï¸ [Format du datagramme UDP](/04-couche-transport/04.2-udp-format-datagramme.md)
