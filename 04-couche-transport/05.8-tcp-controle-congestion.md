ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 4.5.8 ContrÃ´le de congestion : slow start, congestion avoidance

## Introduction

Le **contrÃ´le de congestion** est l'un des mÃ©canismes les plus sophistiquÃ©s et critiques de TCP. Il permet Ã  TCP de dÃ©tecter et de rÃ©agir Ã  la congestion du rÃ©seau, garantissant ainsi la stabilitÃ© d'Internet tout entier.

Sans contrÃ´le de congestion, un Ã©metteur rapide pourrait saturer le rÃ©seau, causant :
- ğŸ’¥ DÃ©bordement des files d'attente des routeurs
- ğŸ“‰ Pertes massives de paquets
- ğŸ”„ Retransmissions en cascade
- âš¡ Effondrement de congestion (congestion collapse)

```
Distinction fondamentale :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ContrÃ´le de FLUX :                 ContrÃ´le de CONGESTION :
â””â”€ ProtÃ¨ge le RÃ‰CEPTEUR           â””â”€ ProtÃ¨ge le RÃ‰SEAU
   â””â”€ Variable : rwnd                â””â”€ Variable : cwnd
      â””â”€ AnnoncÃ©e par rÃ©cepteur         â””â”€ CalculÃ©e par Ã©metteur
         â””â”€ Buffer plein ?                  â””â”€ RÃ©seau saturÃ© ?

FenÃªtre effective = min(rwnd, cwnd)
                        â”‚      â”‚
                        â”‚      â””â”€ Limitation rÃ©seau
                        â””â”€â”€â”€â”€â”€â”€â”€â”€ Limitation rÃ©cepteur
```

## Le problÃ¨me de la congestion

### Effondrement de congestion

Sans contrÃ´le de congestion, le rÃ©seau peut s'effondrer complÃ¨tement.

```
ScÃ©nario catastrophique :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Routeur avec file d'attente de 100 paquets :

Ã‰tat normal (50% utilisation) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [P1][P2][P3]...[P50][    ]   â”‚  Traitement fluide
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  50% plein                       DÃ©lai faible

DÃ©but de congestion (90%) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [P1][P2][P3]...[P90][    ]   â”‚  File qui se remplit
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  90% plein                       DÃ©lai augmente

Congestion sÃ©vÃ¨re (100%) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [P1][P2][P3]...[P100]        â”‚  File pleine
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  100% plein

Nouveau paquet arrive :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [P1][P2][P3]...[P100]  [X]   â”‚  ğŸ’¥ DROP !
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ©action sans contrÃ´le :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ã‰metteur : Timeout â†’ Retransmission
Tous les Ã©metteurs font pareil
â†’ Plus de paquets dans un rÃ©seau dÃ©jÃ  saturÃ©
â†’ Plus de pertes
â†’ Plus de retransmissions
â†’ Effondrement total ! ğŸ’€

DÃ©bit utile â†’ 0
Latence â†’ âˆ
```

### Courbe de performance rÃ©seau

```
DÃ©bit utile (Goodput)
    â”‚
    â”‚     â•±â”€â”€â”€â”€â•²
    â”‚    â•±      â•²
    â”‚   â•±        â•²
Max â”‚  â•±          â•²
    â”‚ â•±            â•²___
    â”‚â•±                  â•²___
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Charge offerte
      â”‚       â”‚        â”‚
      â”‚       â”‚        â””â”€ Effondrement
      â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Point optimal
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Sous-utilisation

Zone 1 (0-70%) : LinÃ©aire
  â†’ Plus d'envois = plus de dÃ©bit âœ“

Zone 2 (70-100%) : Saturation
  â†’ DÃ©bit max atteint
  â†’ Latence augmente âš ï¸

Zone 3 (>100%) : Effondrement
  â†’ DÃ©bit utile diminue !
  â†’ Paquets retransmis occupent le rÃ©seau
  â†’ Cercle vicieux ğŸ’€
```

### Signaux de congestion

TCP dÃ©tecte la congestion via deux signaux principaux :

```
Signal 1 : TIMEOUT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACK non reÃ§u dans le dÃ©lai RTO
â†’ Perte prÃ©sumÃ©e
â†’ Congestion SÃ‰VÃˆRE probable

Signal 2 : 3 ACK DUPLIQUÃ‰S
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Trois ACK identiques consÃ©cutifs
â†’ Perte dÃ©tectÃ©e rapidement
â†’ Congestion MODÃ‰RÃ‰E probable

Distinction :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Timeout        : TrÃ¨s grave (rÃ©seau trÃ¨s congestionnÃ©)
Dup ACK        : Moins grave (perte isolÃ©e)
â†’ RÃ©actions diffÃ©rentes
```

## Variables du contrÃ´le de congestion

### cwnd (Congestion Window)

La **fenÃªtre de congestion** est la variable clÃ©, maintenue par l'Ã©metteur.

```
cwnd (Congestion Window) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Taille : En octets (ou en MSS)
RÃ´le : Limite d'envoi basÃ©e sur l'Ã©tat du rÃ©seau
Calcul : Par l'Ã©metteur SEUL
Ã‰tat initial : Petit (typiquement 1-10 MSS)

Exemple :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd = 14600 octets
MSS = 1460 octets

Nombre de segments en vol max :
= 14600 / 1460 = 10 segments

Si cwnd = 1 MSS :
â†’ Peut envoyer 1 seul segment sans ACK
â†’ TrÃ¨s conservateur (slow start initial)
```

### ssthresh (Slow Start Threshold)

Le **seuil de slow start** dÃ©termine quand passer de la croissance exponentielle Ã  linÃ©aire.

```
ssthresh (Slow Start Threshold) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Taille : En octets
RÃ´le : FrontiÃ¨re entre slow start et congestion avoidance
Valeur initiale : TrÃ¨s Ã©levÃ©e (souvent 65535 ou infini)
Mise Ã  jour : Quand congestion dÃ©tectÃ©e

Comportement :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Si cwnd < ssthresh :
  â†’ Slow Start (croissance exponentielle)

Si cwnd â‰¥ ssthresh :
  â†’ Congestion Avoidance (croissance linÃ©aire)

Exemple :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Initial : ssthresh = 65535 octets
Perte dÃ©tectÃ©e Ã  cwnd = 40000 octets
â†’ ssthresh = 40000 / 2 = 20000 octets
â†’ cwnd rÃ©initialisÃ©
```

### Relation avec rwnd

```
FenÃªtre d'envoi effective :

effectiveWindow = min(cwnd, rwnd)

Exemples :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Cas 1 : RÃ©seau limitant
cwnd = 14600 octets
rwnd = 65536 octets
â†’ effectiveWindow = 14600 octets
  (limitÃ© par rÃ©seau)

Cas 2 : RÃ©cepteur limitant
cwnd = 65536 octets
rwnd = 8192 octets
â†’ effectiveWindow = 8192 octets
  (limitÃ© par rÃ©cepteur)

Cas 3 : Ã‰quilibrÃ©
cwnd = 32768 octets
rwnd = 32768 octets
â†’ effectiveWindow = 32768 octets
  (optimal)
```

## Slow Start (dÃ©marrage lent)

### Principe

Le **slow start** commence avec une fenÃªtre trÃ¨s petite et la **double Ã  chaque RTT**.

```
Pourquoi "slow" ?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Nom historique : ComparÃ© Ã  envoyer immÃ©diatement
avec fenÃªtre maximale (l'approche naÃ¯ve)

En rÃ©alitÃ© : Croissance EXPONENTIELLE
â†’ TrÃ¨s rapide !
```

### Fonctionnement dÃ©taillÃ©

```
RÃ¨gle de Slow Start :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Pour chaque ACK reÃ§u :
  cwnd = cwnd + MSS

RÃ©sultat :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Si N segments acquittÃ©s en un RTT :
  cwnd augmente de N Ã— MSS
â†’ cwnd double Ã  chaque RTT

Exemple avec MSS = 1000 octets :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RTT 0 : cwnd = 1000 (1 MSS)
        Envoie : 1 segment

RTT 1 : ReÃ§oit 1 ACK
        cwnd = 1000 + 1000 = 2000 (2 MSS)
        Envoie : 2 segments

RTT 2 : ReÃ§oit 2 ACK
        cwnd = 2000 + 1000 + 1000 = 4000 (4 MSS)
        Envoie : 4 segments

RTT 3 : ReÃ§oit 4 ACK
        cwnd = 4000 + 4Ã—1000 = 8000 (8 MSS)
        Envoie : 8 segments

RTT 4 : cwnd = 16000 (16 MSS)
RTT 5 : cwnd = 32000 (32 MSS)
RTT 6 : cwnd = 64000 (64 MSS)

Croissance : 1 â†’ 2 â†’ 4 â†’ 8 â†’ 16 â†’ 32 â†’ 64
             Exponentielle ! âš¡
```

### Visualisation graphique

```
cwnd (MSS)
    â”‚
 64 â”‚                                 â•±
    â”‚                               â•±
 32 â”‚                             â•±
    â”‚                           â•±
 16 â”‚                         â•±
    â”‚                       â•±
  8 â”‚                     â•±
    â”‚                   â•±
  4 â”‚                 â•±
    â”‚               â•±
  2 â”‚             â•±
    â”‚           â•±
  1 â”‚         â•±
    â”‚       â•±
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Temps (RTT)
    0   1   2   3   4   5   6

    Phase : Slow Start
    Croissance : Exponentielle
    Doublement Ã  chaque RTT
```

### Exemple chronologique dÃ©taillÃ©

```
Configuration :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MSS = 1460 octets
RTT = 100 ms
cwnd initial = 1 MSS = 1460 octets
ssthresh = 65535 octets (trÃ¨s Ã©levÃ©)

Timeline :
â•â•â•â•â•â•â•â•â•â•

T=0ms : Ã‰tat initial
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd = 1460 (1 MSS)
Peut envoyer : 1 segment

Envoi :
  SEQ=1000, 1460 octets


T=100ms : Premier ACK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACK=2460 reÃ§u

cwnd = 1460 + 1460 = 2920 (2 MSS)
Peut envoyer : 2 segments

Envoi :
  SEQ=2460, 1460 octets
  SEQ=3920, 1460 octets


T=200ms : Deux ACK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACK=3920 reÃ§u â†’ cwnd += 1460 = 4380
ACK=5380 reÃ§u â†’ cwnd += 1460 = 5840 (4 MSS)

Peut envoyer : 4 segments

Envoi :
  SEQ=5380, 1460 octets
  SEQ=6840, 1460 octets
  SEQ=8300, 1460 octets
  SEQ=9760, 1460 octets


T=300ms : Quatre ACK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd passe de 5840 Ã  11680 (8 MSS)

Peut envoyer : 8 segments


T=400ms : Huit ACK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd passe de 11680 Ã  23360 (16 MSS)

Peut envoyer : 16 segments


T=500ms : Seize ACK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd passe de 23360 Ã  46720 (32 MSS)

Peut envoyer : 32 segments


T=600ms : Trente-deux ACK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd passe de 46720 Ã  93440 (64 MSS)

âš ï¸ cwnd > ssthresh = 65535
â†’ Transition vers Congestion Avoidance !
```

### Condition d'arrÃªt du Slow Start

```
Slow Start s'arrÃªte quand :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. cwnd â‰¥ ssthresh
   â†’ Passe en Congestion Avoidance

2. Perte dÃ©tectÃ©e (timeout ou 3 dup ACK)
   â†’ RÃ©duction de cwnd
   â†’ Mise Ã  jour ssthresh
   â†’ RedÃ©marre Slow Start

3. rwnd atteint
   â†’ LimitÃ© par rÃ©cepteur
```

## Congestion Avoidance (Ã©vitement de congestion)

### Principe

Une fois **cwnd â‰¥ ssthresh**, TCP passe en mode **Congestion Avoidance** avec une croissance **linÃ©aire**.

```
Objectif :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Explorer prudemment la capacitÃ© du rÃ©seau
sans provoquer de congestion

Croissance :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Augmentation de 1 MSS par RTT (au lieu de doubler)
```

### Algorithme AIMD

TCP utilise **AIMD** (Additive Increase Multiplicative Decrease) :

```
AIMD (Additive Increase Multiplicative Decrease) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Additive Increase (AI) :
  cwnd = cwnd + MSS Ã— (MSS / cwnd)

  Pour chaque ACK reÃ§u :
    cwnd += MSS / (cwnd / MSS)

  RÃ©sultat : +1 MSS par RTT


Multiplicative Decrease (MD) :
  En cas de perte :
    ssthresh = cwnd / 2
    cwnd = ssthresh (ou 1 MSS selon l'algorithme)

  RÃ©sultat : Division par 2


Exemple :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd = 10 MSS
Pour chaque ACK : cwnd += MSS / 10 = 0.1 MSS
AprÃ¨s 10 ACK (1 RTT) : cwnd = 11 MSS

Perte dÃ©tectÃ©e :
cwnd = 10 MSS â†’ ssthresh = 5 MSS
                cwnd = 5 MSS (ou 1 MSS)
```

### Fonctionnement dÃ©taillÃ©

```
RÃ¨gle de Congestion Avoidance :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Pour chaque ACK reÃ§u :
  cwnd = cwnd + MSS Ã— MSS / cwnd

Simplification :
  IncrÃ©ment par ACK = MSSÂ² / cwnd


Exemple avec cwnd = 8760 octets, MSS = 1460 :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Segments en vol = 8760 / 1460 = 6 segments

Pour chaque ACK reÃ§u :
  increment = 1460 Ã— 1460 / 8760
            = 2131600 / 8760
            â‰ˆ 243 octets

AprÃ¨s 6 ACK (1 RTT complet) :
  cwnd = 8760 + 6 Ã— 243
       = 8760 + 1458
       â‰ˆ 10218 octets
       â‰ˆ 8760 + 1 MSS âœ“

Croissance : +1 MSS par RTT (linÃ©aire)
```

### Visualisation graphique

```
cwnd (MSS)
    â”‚
    â”‚              â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”‚            â•±
    â”‚          â•±   Congestion Avoidance
    â”‚        â•±     (linÃ©aire)
    â”‚      â•±
    â”‚    â•±
    â”‚  â•±  Slow Start
    â”‚â•±    (exponentiel)
    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Temps (RTT)
    0    2    4    6    8    10   12
                  â–²
                  â”‚
              ssthresh
```

### Exemple chronologique

```
Configuration :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd = 65536 octets (45 MSS)
ssthresh = 65536 octets
MSS = 1460 octets
RTT = 100 ms

cwnd â‰¥ ssthresh â†’ Mode Congestion Avoidance


T=0ms : Ã‰tat initial
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd = 65536 octets (45 MSS)
Envoie : 45 segments


T=100ms : 45 ACK reÃ§us
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Pour chaque ACK :
  cwnd += 1460 Ã— 1460 / 65536
       â‰ˆ 32 octets

Total aprÃ¨s 45 ACK :
  cwnd = 65536 + 45 Ã— 32
       = 65536 + 1440
       â‰ˆ 66976 octets (46 MSS)

Augmentation : +1 MSS en 1 RTT âœ“


T=200ms : 46 ACK reÃ§us
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd â‰ˆ 68416 octets (47 MSS)

Augmentation : +1 MSS


T=300ms : 47 ACK reÃ§us
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwnd â‰ˆ 69876 octets (48 MSS)

Croissance linÃ©aire continue...
```

## DÃ©tection et rÃ©action aux pertes

### Fast Retransmit

RÃ©action rapide aux **3 ACK dupliquÃ©s**.

```
ScÃ©nario :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Ã‰metteur                        RÃ©cepteur
   â”‚                                â”‚
   â”‚ â‘  SEQ=1000 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚ âœ“
   â”‚ â‘¡ SEQ=1460 â”€â”€â”€â”€â”€â”€X            â”‚ âŒ Perdu
   â”‚ â‘¢ SEQ=2920 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚ âœ“ (hors ordre)
   â”‚ â‘£ SEQ=4380 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚ âœ“ (hors ordre)
   â”‚ â‘¤ SEQ=5840 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚ âœ“ (hors ordre)
   â”‚                                â”‚
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1460 â”‚ (pour â‘ )
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1460 â”‚ (dup 1, attend â‘¡)
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1460 â”‚ (dup 2)
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=1460 â”‚ (dup 3) ğŸš¨
   â”‚                                â”‚
   â”‚ âš¡ Fast Retransmit !           â”‚
   â”‚ â‘¡ SEQ=1460 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚ âœ“ Retransmis
   â”‚                                â”‚
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=5840 â”‚ Tout reÃ§u !
```

### Fast Recovery

AprÃ¨s Fast Retransmit, TCP entre en **Fast Recovery** au lieu de redÃ©marrer Slow Start.

```
Fast Recovery (RFC 2581, TCP Reno) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. DÃ©tection de 3 dup ACK
2. ssthresh = cwnd / 2
3. cwnd = ssthresh + 3 Ã— MSS
4. Pour chaque dup ACK additionnel : cwnd += MSS
5. Retransmission du segment perdu
6. Quand nouvel ACK arrive : cwnd = ssthresh

Avantage :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ne retombe pas Ã  1 MSS
Continue d'envoyer Ã  dÃ©bit rÃ©duit
RÃ©cupÃ©ration plus rapide âœ“


Exemple :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ã‰tat avant perte :
  cwnd = 40 MSS
  ssthresh = 65535 octets

3 dup ACK dÃ©tectÃ©s :
  ssthresh = 40 / 2 = 20 MSS
  cwnd = 20 + 3 = 23 MSS

Chaque dup ACK supplÃ©mentaire :
  cwnd += 1 MSS
  (autorise envoi de nouveaux segments)

Nouvel ACK (perte rÃ©cupÃ©rÃ©e) :
  cwnd = ssthresh = 20 MSS
  Reprend Congestion Avoidance
```

### Timeout (RTO)

RÃ©action trÃ¨s conservatrice au **timeout**.

```
Timeout = Congestion SÃ‰VÃˆRE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RÃ©action :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. ssthresh = cwnd / 2
2. cwnd = 1 MSS (retour au dÃ©but !)
3. RedÃ©marre Slow Start
4. Double le RTO (exponential backoff)


Exemple :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ã‰tat avant timeout :
  cwnd = 40 MSS
  ssthresh = 65535 octets
  RTO = 200 ms

Timeout se produit :
  ssthresh = 40 / 2 = 20 MSS
  cwnd = 1 MSS
  RTO = 400 ms

RedÃ©marre Slow Start :
  RTT 1 : cwnd = 1 MSS
  RTT 2 : cwnd = 2 MSS
  RTT 3 : cwnd = 4 MSS
  ...
  Jusqu'Ã  cwnd = 20 MSS (ssthresh)
  Puis Congestion Avoidance

DeuxiÃ¨me timeout (si Ã©chec) :
  RTO = 800 ms
  cwnd = 1 MSS
  ...
```

## Algorithmes de contrÃ´le de congestion

### TCP Tahoe (1988)

Le premier algorithme complet.

```
TCP Tahoe :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Phases :
1. Slow Start
2. Congestion Avoidance
3. Fast Retransmit

RÃ©action aux pertes :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Timeout OU 3 dup ACK :
  â†’ ssthresh = cwnd / 2
  â†’ cwnd = 1 MSS
  â†’ Slow Start

ProblÃ¨me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3 dup ACK = congestion modÃ©rÃ©e
Mais rÃ©action identique au timeout !
â†’ Trop conservateur âš ï¸
```

### TCP Reno (1990)

AmÃ©lioration majeure avec Fast Recovery.

```
TCP Reno :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Phases :
1. Slow Start
2. Congestion Avoidance
3. Fast Retransmit
4. Fast Recovery â† Nouveau !

RÃ©action aux pertes :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Timeout :
  â†’ ssthresh = cwnd / 2
  â†’ cwnd = 1 MSS
  â†’ Slow Start

3 dup ACK :
  â†’ ssthresh = cwnd / 2
  â†’ cwnd = ssthresh + 3 MSS
  â†’ Fast Recovery
  â†’ Puis Congestion Avoidance

AmÃ©lioration :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Distingue perte sÃ©vÃ¨re (timeout)
de perte modÃ©rÃ©e (dup ACK)
â†’ RÃ©cupÃ©ration plus rapide âœ“
```

### TCP NewReno (1999)

AmÃ©liore la gestion de pertes multiples.

```
TCP NewReno :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ProblÃ¨me de Reno :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Si plusieurs segments perdus dans une fenÃªtre :
  â†’ Reno sort de Fast Recovery trop tÃ´t
  â†’ Retombe en Slow Start
  â†’ Performance dÃ©gradÃ©e

Solution NewReno :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Reste en Fast Recovery jusqu'Ã  ce que
TOUS les segments de la fenÃªtre soient ACK

Utilise "partial ACK" :
  ACK qui acquitte de nouveaux octets
  mais pas tout ce qui Ã©tait en vol
  â†’ Indique perte supplÃ©mentaire
  â†’ Retransmet sans sortir de Fast Recovery
```

### TCP CUBIC (2008) - Linux par dÃ©faut

OptimisÃ© pour rÃ©seaux haute vitesse et longue distance.

```
TCP CUBIC :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ProblÃ¨me de Reno/NewReno :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AIMD linÃ©aire trop lent pour retrouver
le dÃ©bit optimal sur rÃ©seaux modernes

Solution CUBIC :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fonction cubique pour croissance de cwnd

Formule :
  cwnd = C Ã— (t - K)Â³ + Wmax

  OÃ¹ :
  - C : constante (0.4)
  - t : temps depuis derniÃ¨re perte
  - K : point d'inflexion
  - Wmax : cwnd au moment de la perte


Comportement :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cwnd
    â”‚       â•±â”€â”€â”€â”€â”€â”€â”€â”€  Wmax
    â”‚      â•±    â•±
    â”‚     â”‚   â•±   Croissance rapide
    â”‚    â”‚  â•±    (exploration)
    â”‚   â”‚ â•±
    â”‚  â”‚â•±  Croissance lente
    â”‚ â•±â”‚   (prudence prÃ¨s de Wmax)
    â”‚â•± â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Temps
    Perte    K (point Wmax)

Phases :
1. AprÃ¨s perte : Croissance rapide vers Wmax
2. PrÃ¨s de Wmax : Croissance prudente
3. Au-delÃ  de Wmax : Exploration agressive

Avantages :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ RÃ©cupÃ©ration rapide aprÃ¨s perte
âœ“ Bon pour haute bande passante
âœ“ IndÃ©pendant du RTT (fairness)
```

### BBR (Bottleneck Bandwidth and RTT) - 2016

Approche rÃ©volutionnaire basÃ©e sur le modÃ¨le du rÃ©seau.

```
BBR (Google) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Changement de paradigme :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ne se base PAS sur les pertes !
Se base sur :
  1. Bande passante du goulot (bottleneck)
  2. RTT minimal

ModÃ¨le :
â”€â”€â”€â”€â”€â”€â”€â”€
DÃ©bit optimal = BtlBw (bande passante goulot)
DonnÃ©es en vol = BtlBw Ã— RTprop (RTT minimal)


Phases :
â”€â”€â”€â”€â”€â”€â”€â”€

1. STARTUP (Slow Start amÃ©liorÃ©)
   â†’ Croissance exponentielle
   â†’ DÃ©tecte plafond de bande passante

2. DRAIN
   â†’ Vide les files d'attente
   â†’ RÃ©duit donnÃ©es en vol

3. PROBE_BW (75% du temps)
   â†’ Oscille autour de l'optimal
   â†’ +25% / -25% pour tester

4. PROBE_RTT (cycle de 10s)
   â†’ RÃ©duit cwnd pour mesurer RTprop
   â†’ Ã‰vite bufferbloat


Avantages :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Latence faible (vide les buffers)
âœ“ Haut dÃ©bit (utilisation optimale)
âœ“ Pas de perte nÃ©cessaire pour s'adapter
âœ“ Excellent pour longue distance

InconvÃ©nients :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âš ï¸ Peut Ãªtre agressif avec Reno/CUBIC
âš ï¸ NÃ©cessite bonne implÃ©mentation
```

### Comparaison des algorithmes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Algorithme â”‚  AnnÃ©e â”‚ CaractÃ©ristiques                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Tahoe      â”‚  1988  â”‚ Premier complet, conservateur     â”‚
â”‚ Reno       â”‚  1990  â”‚ Fast Recovery, standard           â”‚
â”‚ NewReno    â”‚  1999  â”‚ Gestion pertes multiples          â”‚
â”‚ CUBIC      â”‚  2008  â”‚ Haute vitesse, dÃ©faut Linux       â”‚
â”‚ BBR        â”‚  2016  â”‚ BasÃ© modÃ¨le, faible latence       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰volution de cwnd aprÃ¨s perte :

cwnd
    â”‚
    â”‚ Tahoe â”€â”€â”€â”€â”€â”€â•²___â•±â”€â”€â”€â”€
    â”‚ Reno  â”€â”€â”€â”€â”€â”€â•²_â•±â”€â”€â”€â”€â”€â”€
    â”‚ CUBIC â”€â”€â”€â”€â”€â”€â•²â•±â”€â”€â”€â”€â”€â”€â”€
    â”‚ BBR   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (ne baisse pas sur perte)
    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Temps
               Perte
```

## Exemple complet avec graphiques

### ScÃ©nario : Transfert avec pertes

```
Configuration :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Algorithme : TCP Reno
MSS = 1460 octets
RTT = 100 ms
ssthresh initial = 65536 octets (45 MSS)


Timeline dÃ©taillÃ©e :
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Phase 1 : Slow Start (T=0 Ã  T=600ms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

T=0   : cwnd = 1 MSS
T=100 : cwnd = 2 MSS
T=200 : cwnd = 4 MSS
T=300 : cwnd = 8 MSS
T=400 : cwnd = 16 MSS
T=500 : cwnd = 32 MSS
T=600 : cwnd = 64 MSS

cwnd > ssthresh (45 MSS)
â†’ Passage en Congestion Avoidance


Phase 2 : Congestion Avoidance (T=700 Ã  T=1200ms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

T=700  : cwnd = 65 MSS
T=800  : cwnd = 66 MSS
T=900  : cwnd = 67 MSS
T=1000 : cwnd = 68 MSS
T=1100 : cwnd = 69 MSS
T=1200 : cwnd = 70 MSS


Phase 3 : Perte dÃ©tectÃ©e (3 dup ACK Ã  T=1250ms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Ã‰tat avant perte :
  cwnd = 70 MSS
  ssthresh = 45 MSS

3 dup ACK dÃ©tectÃ©s :
  ssthresh = 70 / 2 = 35 MSS
  cwnd = 35 + 3 = 38 MSS

Fast Recovery :
  Dup ACK 4 : cwnd = 39 MSS
  Dup ACK 5 : cwnd = 40 MSS

Nouvel ACK (rÃ©cupÃ©ration) :
  cwnd = ssthresh = 35 MSS
  Reprend Congestion Avoidance


Phase 4 : Congestion Avoidance (T=1300 Ã  T=1800ms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

T=1300 : cwnd = 36 MSS
T=1400 : cwnd = 37 MSS
T=1500 : cwnd = 38 MSS
T=1600 : cwnd = 39 MSS
T=1700 : cwnd = 40 MSS
T=1800 : cwnd = 41 MSS


Phase 5 : Timeout Ã  T=1850ms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Ã‰tat avant timeout :
  cwnd = 41 MSS
  ssthresh = 35 MSS

Timeout :
  ssthresh = 41 / 2 â‰ˆ 20 MSS
  cwnd = 1 MSS
  RTO doublÃ©


Phase 6 : Slow Start (T=1850 Ã  T=2250ms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

T=1950 : cwnd = 2 MSS
T=2050 : cwnd = 4 MSS
T=2150 : cwnd = 8 MSS
T=2250 : cwnd = 16 MSS
T=2350 : cwnd = 32 MSS

cwnd > ssthresh (20 MSS)
â†’ Passage en Congestion Avoidance

Croissance linÃ©aire reprend...
```

### Graphique complet

```
cwnd (MSS)
    â”‚
 70 â”‚             â•±â”€â”€â•®
    â”‚           â•±    â”‚         Congestion
 60 â”‚         â•±      â”‚         Avoidance
    â”‚       â•±        â”‚         (linÃ©aire)
 50 â”‚     â•±          â”‚
    â”‚   â•±            â”‚
 45 â”‚  â•± ssthresh    â•°â”€â•®  â† Fast Recovery
 40 â”‚ â•±                 â”‚
 35 â”‚â•±                  â•°â”€â”€â•®
 30 â”‚                      â”‚ Congestion
 20 â”‚ Slow                 â”‚ Avoidance
    â”‚ Start                â•°â”€â”€â”€â•²
 10 â”‚ (exp.)                   â”‚â•²___
    â”‚                           â”‚    â•²â•±â”€â”€
  1 â”‚                           â”‚ Timeout
    â”‚                           â”‚ + Slow
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€> Temps (ms)
    0   400   800  1200 1600 2000 2400
              â”‚    â”‚         â”‚
              â”‚    â”‚         â””â”€ Timeout (RTO)
              â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3 dup ACK
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ssthresh atteint
```

## Configuration et tuning

### Choix de l'algorithme (Linux)

```bash
# Voir l'algorithme actuel
sysctl net.ipv4.tcp_congestion_control
# cubic (dÃ©faut)

# Algorithmes disponibles
sysctl net.ipv4.tcp_available_congestion_control
# reno cubic bbr

# Changer pour BBR
sysctl -w net.ipv4.tcp_congestion_control=bbr

# Ou dans /etc/sysctl.conf
echo "net.ipv4.tcp_congestion_control=bbr" >> /etc/sysctl.conf

# Activer BBR (nÃ©cessite module kernel)
modprobe tcp_bbr
echo "tcp_bbr" >> /etc/modules-load.d/modules.conf
```

### ParamÃ¨tres de contrÃ´le de congestion

```bash
# Slow Start aprÃ¨s idle (connexion inactive)
sysctl net.ipv4.tcp_slow_start_after_idle
# 1 (activÃ© par dÃ©faut)

# DÃ©sactiver si connexions longues :
sysctl -w net.ipv4.tcp_slow_start_after_idle=0


# Initial cwnd (nombre de segments)
ip route change default via 192.168.1.1 initcwnd 10
# DÃ©faut : 10 segments (RFC 6928)
# Ancien : 3 ou 4 segments


# Seuil initial ssthresh
# (gÃ©nÃ©ralement trÃ¨s Ã©levÃ©, pas configurable directement)


# ECN (Explicit Congestion Notification)
sysctl net.ipv4.tcp_ecn
# 0 = dÃ©sactivÃ©
# 1 = activÃ© si l'autre cÃ´tÃ© supporte
# 2 = toujours activÃ©

sysctl -w net.ipv4.tcp_ecn=1
```

### ParamÃ¨tres CUBIC

```bash
# ParamÃ¨tres CUBIC (experts seulement)
sysctl net.ipv4.tcp_cubic_beta
# 717 (facteur de rÃ©duction : 0.717)

# Hystart (dÃ©tection rapide de bande passante)
sysctl net.ipv4.tcp_cubic_hystart
# 1 (activÃ©)

sysctl net.ipv4.tcp_cubic_hystart_low_window
# 16 (fenÃªtre minimale pour hystart)
```

### ParamÃ¨tres BBR

```bash
# BBR automatiquement configurÃ©
# Peu de paramÃ¨tres Ã  ajuster

# Activer pacing (crucial pour BBR)
sysctl net.ipv4.tcp_pacing_ss_ratio
# 200 (ratio slow start)

sysctl net.ipv4.tcp_pacing_ca_ratio
# 120 (ratio congestion avoidance)

# Noack SACK delay
sysctl net.ipv4.tcp_noack_sack_delay
# 40 (ms)
```

## Diagnostic et monitoring

### Commandes utiles

```bash
# Voir les statistiques de retransmission
ss -ti

# Sortie exemple :
tcp ESTAB 0  0  192.168.1.10:54321  93.184.216.34:443
     cubic wscale:7,7 rto:204 rtt:3.5/1.75 ato:40
     mss:1460 pmtu:1500 rcvmss:1460 advmss:1460
     cwnd:10 ssthresh:7 bytes_acked:123456
     bytes_received:654321 segs_out:789
     segs_in:456 data_segs_out:678
     data_segs_in:345 send 28.7Mbps
     lastsnd:1 lastrcv:1 lastack:1
     pacing_rate 34.5Mbps delivery_rate 25.3Mbps
     busy:5280ms unacked:0 retrans:0/2 â† Important !
     â–²                â–²              â–²
     â”‚                â”‚              â””â”€ Retransmissions
     â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Slow start threshold
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Congestion window


# Netstat pour statistiques globales
netstat -s | grep -i retrans
# 12345 segments retransmitted
# 678 fast retransmits
# 234 retransmits in slow start


# Monitoring en temps rÃ©el
watch -n 1 'ss -ti | grep -A 10 ESTAB'
```

### Analyse avec Wireshark

```
Filtres Wireshark :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Retransmissions
tcp.analysis.retransmission

# Fast Retransmit
tcp.analysis.fast_retransmission

# Dup ACK
tcp.analysis.duplicate_ack

# Out-of-Order
tcp.analysis.out_of_order


Graphiques :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Statistics â†’ TCP Stream Graphs â†’ Time-Sequence (Stevens)

Visualisation cwnd :
- Pente des segments envoyÃ©s = cwnd
- Plateaux = attente ACK (fenÃªtre pleine)
- RÃ©duction brutale = perte dÃ©tectÃ©e

Statistics â†’ TCP Stream Graphs â†’ Round Trip Time

Visualisation RTT :
- Augmentation RTT = congestion naissante
- RTT stable = rÃ©seau sain
```

### Exemple de capture

```
Frame 1234: [TCP Previous segment not captured]
Frame 1235: [TCP Retransmission]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Time: 5.234567
Source: 192.168.1.10
Destination: 93.184.216.34
Sequence: 12345 (relative)
Length: 1460

[SEQ/ACK analysis]
    [This is a retransmission]
    [RTO: 0.200 seconds]
    [Original segment in frame: 1150]


Frame 1236-1238: [TCP Dup ACK]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Three duplicate ACKs detected
[Expert Info: Duplicate ACK]
[This is duplicate ACK #3]


Frame 1239: [TCP Fast Retransmission]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[Expert Info: Fast retransmission]
[Original transmission in frame: 1151]
[The RTO for this segment was: 0.015 seconds]

â†’ Fast Retransmit dÃ©tectÃ© (3 dup ACK)
â†’ RÃ©cupÃ©ration rapide vs timeout
```

## ProblÃ¨mes courants et solutions

### ProblÃ¨me 1 : Retransmissions excessives

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ss -s
TCP: retrans:5/100 (5%)
â†’ Taux de retransmission > 1% = problÃ¨me

Causes :
â”€â”€â”€â”€â”€â”€â”€â”€
1. RÃ©seau congestionnÃ©
2. Pertes physiques (WiFi, cÃ¢bles)
3. Algorithme inadaptÃ©
4. Buffer routeur trop petit/grand

Diagnostic :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# VÃ©rifier congestion
ping -c 100 destination
# RTT trÃ¨s variable = congestion

# VÃ©rifier pertes physiques
mtr destination
# Pertes constantes sur un saut = problÃ¨me physique

Solutions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Si congestion rÃ©seau :
   - Augmenter capacitÃ©
   - Limiter dÃ©bit applicatif
   - QoS/prioritisation

2. Si pertes physiques :
   - VÃ©rifier cÃ¢bles
   - AmÃ©liorer signal WiFi
   - Changer matÃ©riel dÃ©fectueux

3. Si algorithme :
   - Tester BBR au lieu de CUBIC
   - Activer ECN
```

### ProblÃ¨me 2 : Throughput limitÃ©

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Bande passante disponible : 100 Mbps
DÃ©bit mesurÃ© : 10 Mbps
Utilisation : 10% seulement

Diagnostic :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ss -ti | grep cwnd
# cwnd:10 ssthresh:7

cwnd = 10 MSS = 14600 octets
RTT = 50 ms

DÃ©bit max thÃ©orique :
= 14600 / 0.05 = 292 Ko/s â‰ˆ 2.3 Mbps

cwnd trop petit ! âš ï¸

Causes :
â”€â”€â”€â”€â”€â”€â”€â”€
1. ssthresh trop bas (pertes frÃ©quentes)
2. Slow Start ne se termine pas
3. rwnd limitant
4. Algorithme inadaptÃ©

Solutions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Augmenter initcwnd :
   ip route change default initcwnd 20

2. Tester BBR :
   sysctl -w net.ipv4.tcp_congestion_control=bbr

3. VÃ©rifier rwnd :
   # Augmenter buffers si nÃ©cessaire

4. DÃ©sactiver slow start after idle :
   sysctl -w net.ipv4.tcp_slow_start_after_idle=0
```

### ProblÃ¨me 3 : Latence Ã©levÃ©e (Bufferbloat)

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RTT normal : 50 ms
RTT pendant transfert : 500 ms ! ğŸ’€

Ping pendant transfert :
64 bytes: icmp_seq=1 time=450 ms

Cause :
â”€â”€â”€â”€â”€â”€â”€
Buffers trop grands dans les routeurs
(bufferbloat)
â†’ Files d'attente pleines
â†’ Latence Ã©levÃ©e
â†’ Mais pas de perte !

TCP continue d'augmenter cwnd
â†’ Aggrave le problÃ¨me

Solutions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. BBR :
   sysctl -w net.ipv4.tcp_congestion_control=bbr
   â†’ BBR dÃ©tecte et vide les buffers

2. ECN :
   sysctl -w net.ipv4.tcp_ecn=1
   â†’ Signal de congestion explicite
   â†’ RÃ©duit cwnd avant perte

3. FQ (Fair Queuing) :
   tc qdisc add dev eth0 root fq
   â†’ Meilleures files d'attente

4. Cake (qdisc moderne) :
   tc qdisc add dev eth0 root cake bandwidth 100mbit
   â†’ Active Queue Management
```

### ProblÃ¨me 4 : Fairness entre flux

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Plusieurs connexions TCP
Certaines obtiennent tout le dÃ©bit
D'autres presque rien

Causes :
â”€â”€â”€â”€â”€â”€â”€â”€
1. RTT diffÃ©rents
   â†’ RTT court = cwnd augmente plus vite
   â†’ Unfair

2. Algorithmes diffÃ©rents
   â†’ BBR vs CUBIC = BBR peut dominer

3. Temps de connexion diffÃ©rents
   â†’ Anciennes connexions dominent

Solutions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. MÃªme algorithme partout :
   # Tous en CUBIC ou tous en BBR

2. Activer pacing :
   # BBR le fait automatiquement
   # Pour CUBIC :
   tc qdisc add dev eth0 root fq pacing

3. Limiter dÃ©bit applicatif :
   # Rate limiting cÃ´tÃ© application

4. RED/AQM dans routeurs :
   # Active Queue Management
   # Suppression alÃ©atoire Ã©quitable
```

## Cas d'usage spÃ©cifiques

### Datacenter (courte distance, haute vitesse)

```bash
# DCTCP (Data Center TCP) - si disponible
sysctl -w net.ipv4.tcp_congestion_control=dctcp

# Ou BBR
sysctl -w net.ipv4.tcp_congestion_control=bbr

# ECN obligatoire pour DCTCP
sysctl -w net.ipv4.tcp_ecn=1

# Initial cwnd Ã©levÃ© (RTT faible)
ip route change default initcwnd 50

# DÃ©sactiver slow start after idle
sysctl -w net.ipv4.tcp_slow_start_after_idle=0
```

### WAN / Internet (longue distance)

```bash
# BBR excellent pour longue distance
sysctl -w net.ipv4.tcp_congestion_control=bbr

# Ou CUBIC avec gros buffers
sysctl -w net.ipv4.tcp_congestion_control=cubic
sysctl -w net.ipv4.tcp_rmem="4096 87380 67108864"
sysctl -w net.ipv4.tcp_wmem="4096 65536 67108864"

# Activer ECN
sysctl -w net.ipv4.tcp_ecn=1

# Timestamps pour PAWS
sysctl -w net.ipv4.tcp_timestamps=1

# Initial cwnd modÃ©rÃ©
ip route change default initcwnd 10
```

### Satellite / TrÃ¨s haute latence

```bash
# BBR idÃ©al (gÃ¨re bien haute latence)
sysctl -w net.ipv4.tcp_congestion_control=bbr

# Buffers Ã©normes (BDP Ã©levÃ©)
sysctl -w net.core.rmem_max=134217728  # 128 Mo
sysctl -w net.ipv4.tcp_rmem="4096 87380 134217728"

# Window Scale obligatoire
sysctl -w net.ipv4.tcp_window_scaling=1

# SACK essentiel
sysctl -w net.ipv4.tcp_sack=1

# DÃ©sactiver slow start after idle
# (reconnexions frÃ©quentes en satellite)
sysctl -w net.ipv4.tcp_slow_start_after_idle=0
```

### Mobile / WiFi (pertes frÃ©quentes)

```bash
# BBR rÃ©siste mieux aux pertes
sysctl -w net.ipv4.tcp_congestion_control=bbr

# Ou CUBIC avec ajustements
sysctl -w net.ipv4.tcp_congestion_control=cubic

# SACK crucial (pertes non congestives)
sysctl -w net.ipv4.tcp_sack=1

# F-RTO (Forward RTO-Recovery)
sysctl -w net.ipv4.tcp_frto=2

# Initial cwnd conservateur
ip route change default initcwnd 3
```

## RÃ©sumÃ©

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           CONTRÃ”LE DE CONGESTION TCP                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  But : ProtÃ©ger le RÃ‰SEAU contre la surcharge            â”‚
â”‚                                                          â”‚
â”‚  Variable clÃ© : cwnd (congestion window)                 â”‚
â”‚                                                          â”‚
â”‚  Phases :                                                â”‚
â”‚                                                          â”‚
â”‚  1. SLOW START                                           â”‚
â”‚     â€¢ Croissance exponentielle (double/RTT)              â”‚
â”‚     â€¢ De 1 MSS jusqu'Ã  ssthresh                          â”‚
â”‚     â€¢ Explore capacitÃ© rapidement                        â”‚
â”‚                                                          â”‚
â”‚  2. CONGESTION AVOIDANCE                                 â”‚
â”‚     â€¢ Croissance linÃ©aire (+1 MSS/RTT)                   â”‚
â”‚     â€¢ Quand cwnd â‰¥ ssthresh                              â”‚
â”‚     â€¢ Explore prudemment                                 â”‚
â”‚                                                          â”‚
â”‚  3. FAST RETRANSMIT                                      â”‚
â”‚     â€¢ DÃ©tection rapide (3 dup ACK)                       â”‚
â”‚     â€¢ Retransmission immÃ©diate                           â”‚
â”‚                                                          â”‚
â”‚  4. FAST RECOVERY                                        â”‚
â”‚     â€¢ Ã‰vite retour Ã  1 MSS                               â”‚
â”‚     â€¢ cwnd = ssthresh + 3                                â”‚
â”‚     â€¢ RÃ©cupÃ©ration rapide                                â”‚
â”‚                                                          â”‚
â”‚  RÃ©action aux pertes :                                   â”‚
â”‚     â€¢ Timeout : cwnd = 1, ssthresh = cwnd/2              â”‚
â”‚     â€¢ 3 dup ACK : cwnd = ssthresh = cwnd/2               â”‚
â”‚                                                          â”‚
â”‚  Algorithmes modernes :                                  â”‚
â”‚     â€¢ CUBIC : DÃ©faut Linux, haute vitesse                â”‚
â”‚     â€¢ BBR : BasÃ© modÃ¨le, faible latence                  â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Conclusion

Le contrÃ´le de congestion est le mÃ©canisme qui permet Ã  TCP et Ã  Internet de fonctionner Ã  grande Ã©chelle.

**Points clÃ©s** :

1. **cwnd** : Variable fondamentale calculÃ©e par l'Ã©metteur
2. **Slow Start** : Croissance exponentielle initiale
3. **Congestion Avoidance** : Croissance linÃ©aire prudente
4. **AIMD** : Augmentation additive, diminution multiplicative
5. **Fast Retransmit/Recovery** : RÃ©cupÃ©ration rapide des pertes
6. **Algorithmes modernes** : CUBIC (dÃ©faut), BBR (optimal)

**Formules importantes** :

```
Slow Start :
  cwnd = cwnd + MSS (par ACK)
  â†’ Double par RTT

Congestion Avoidance :
  cwnd = cwnd + MSSÂ²/cwnd (par ACK)
  â†’ +1 MSS par RTT

Perte (AIMD) :
  ssthresh = cwnd / 2
  cwnd = ssthresh (ou 1 MSS)

DÃ©bit max :
  = min(cwnd, rwnd) / RTT
```

**Recommandations** :

```
RÃ©seau local : CUBIC ou BBR
Internet : BBR
Satellite : BBR
Datacenter : DCTCP ou BBR

Toujours :
âœ“ Window Scaling activÃ©
âœ“ SACK activÃ©
âœ“ Timestamps activÃ©s
âœ“ Auto-tuning activÃ©
âœ“ ECN quand possible
```

Le contrÃ´le de congestion continue d'Ã©voluer. BBR reprÃ©sente un changement de paradigme majeur, et de nouveaux algorithmes (BBRv2, BBRv3) sont en dÃ©veloppement pour amÃ©liorer encore la performance et la fairness.

Dans la prochaine section, nous explorerons les **retransmissions et timers**, mÃ©canismes qui permettent Ã  TCP de dÃ©tecter les pertes et de s'en remettre.

---

**Prochaine section** : 4.5.9 Retransmissions et timers

â­ï¸ [Retransmissions et timers](/04-couche-transport/05.9-tcp-retransmissions.md)
