ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 4.5.9 Retransmissions et timers

## Introduction

Les **retransmissions** sont le mÃ©canisme par lequel TCP garantit la fiabilitÃ© : si un segment est perdu ou corrompu, TCP le retransmet automatiquement. Les **timers** sont les horloges qui dÃ©tectent quand une retransmission est nÃ©cessaire.

Sans retransmissions, TCP ne pourrait pas fonctionner sur Internet oÃ¹ les pertes sont inÃ©vitables :

```
Causes de pertes de paquets :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Congestion (buffers pleins dans les routeurs)
â€¢ Erreurs physiques (interfÃ©rences, cÃ¢bles dÃ©fectueux)
â€¢ Routage instable (paquets abandonnÃ©s)
â€¢ Corruption de donnÃ©es (checksum invalide)
â€¢ Limitations WiFi/mobile

ProbabilitÃ© de perte :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Internet typique : 0.1% - 1%
WiFi : 1% - 5%
Mobile : 5% - 10%

Sur 1000 paquets, 1 Ã  100 peuvent Ãªtre perdus !
Sans retransmission â†’ donnÃ©es incomplÃ¨tes ğŸ’€
```

## DÃ©tection des pertes

TCP dÃ©tecte les pertes de deux maniÃ¨res :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              DÃ‰TECTION DE PERTE TCP                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  MÃ©thode 1 : TIMEOUT (RTO)                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                           â”‚
â”‚  â€¢ ACK non reÃ§u dans le dÃ©lai RTO                      â”‚
â”‚  â€¢ Indique congestion SÃ‰VÃˆRE                           â”‚
â”‚  â€¢ RÃ©action conservatrice                              â”‚
â”‚  â€¢ Temps de dÃ©tection : long (ms Ã  secondes)           â”‚
â”‚                                                        â”‚
â”‚  MÃ©thode 2 : FAST RETRANSMIT (3 dup ACK)               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
â”‚  â€¢ Trois ACK identiques reÃ§us                          â”‚
â”‚  â€¢ Indique perte ISOLÃ‰E                                â”‚
â”‚  â€¢ RÃ©action rapide                                     â”‚
â”‚  â€¢ Temps de dÃ©tection : court (1 RTT)                  â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## RTT (Round-Trip Time)

### DÃ©finition et importance

Le **RTT** (Round-Trip Time) est le temps aller-retour d'un paquet et son acquittement.

```
Mesure du RTT :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Client                          Serveur
   â”‚                               â”‚
T=0â”‚ â”€â”€â”€â”€ Segment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                               â”‚
   â”‚      Temps de propagation     â”‚
   â”‚      + Temps de traitement    â”‚
   â”‚                               â”‚
T=Râ”‚<â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
   â”‚                               â”‚
   RTT = R ms


Composants du RTT :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RTT = Propagation + File d'attente + Traitement

Propagation : Distance / Vitesse lumiÃ¨re
              (incompressible)

File d'attente : DÃ©lai dans les routeurs
                 (variable selon congestion)

Traitement : Temps CPU Ã©metteur/rÃ©cepteur
             (gÃ©nÃ©ralement nÃ©gligeable)
```

### VariabilitÃ© du RTT

Le RTT n'est **pas constant** ; il varie avec les conditions rÃ©seau.

```
Exemple de mesures RTT successives :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Paquet 1 : RTT = 45 ms
Paquet 2 : RTT = 52 ms
Paquet 3 : RTT = 48 ms
Paquet 4 : RTT = 67 ms  â† Congestion ?
Paquet 5 : RTT = 51 ms
Paquet 6 : RTT = 49 ms
Paquet 7 : RTT = 120 ms â† Spike !
Paquet 8 : RTT = 46 ms

Moyenne : ~60 ms
Variation : Large (45-120 ms)

Causes de variation :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Congestion rÃ©seau (files d'attente)
âœ“ Routage dynamique (chemins diffÃ©rents)
âœ“ Charge CPU (traitement variable)
âœ“ InterfÃ©rences WiFi/mobile
```

### Mesure du RTT dans TCP

TCP mesure le RTT en horodatant les segments.

```
MÃ©thode classique (RFC 793) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Ã‰metteur envoie segment avec horodatage
2. RÃ©cepteur renvoie ACK
3. Ã‰metteur calcule : RTT = temps_ACK - temps_envoi

ProblÃ¨me : Retransmissions
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ScÃ©nario ambigu :

T=0   : Envoi segment SEQ=1000
T=200 : Timeout, retransmission SEQ=1000
T=250 : ACK=1460 reÃ§u

Question : ACK pour quelle transmission ?
- PremiÃ¨re (RTT = 250 ms) ?
- DeuxiÃ¨me (RTT = 50 ms) ?

â†’ Impossible Ã  dÃ©terminer !
â†’ Karn's Algorithm : ignorer RTT des retransmissions


Solution moderne : Timestamps TCP
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Option TCP Timestamps (RFC 1323) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TSval : Horodatage Ã©metteur      â”‚
â”‚ TSecr : Echo de l'horodatage     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰metteur :
  Envoie segment avec TSval=12345

RÃ©cepteur :
  Renvoie ACK avec TSecr=12345

Ã‰metteur :
  RTT = Horloge_actuelle - TSval
  Fonctionne mÃªme avec retransmissions âœ“
```

## RTO (Retransmission Timeout)

### DÃ©finition

Le **RTO** est le dÃ©lai aprÃ¨s lequel TCP considÃ¨re qu'un segment est perdu et le retransmet.

```
Logique du RTO :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Si ACK non reÃ§u aprÃ¨s RTO secondes :
  â†’ Segment considÃ©rÃ© perdu
  â†’ Retransmission
  â†’ RÃ©duction cwnd
  â†’ Augmentation RTO (exponential backoff)

ProblÃ¨me du choix de RTO :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RTO trop court :
  âŒ Retransmissions inutiles (spurious)
  âŒ Gaspillage de bande passante
  âŒ Congestion artificielle

RTO trop long :
  âŒ DÃ©tection lente des pertes
  âŒ Performance dÃ©gradÃ©e
  âŒ Mauvaise expÃ©rience utilisateur

RTO optimal :
  âœ“ Juste au-dessus du RTT rÃ©el
  âœ“ Marge pour la variabilitÃ©
  âœ“ S'adapte dynamiquement
```

### Calcul du RTO : Algorithme de Jacobson/Karels

L'algorithme classique (RFC 6298) calcule RTO basÃ© sur RTT mesurÃ© et sa variabilitÃ©.

```
Variables :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SRTT : Smoothed Round-Trip Time (RTT lissÃ©)
RTTVAR : Round-Trip Time Variation (variance du RTT)
RTO : Retransmission Timeout


Initialisation :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SRTT = 0
RTTVAR = 0
RTO = 1 seconde (valeur conservative)


PremiÃ¨re mesure RTT (R) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SRTT = R
RTTVAR = R / 2
RTO = SRTT + 4 Ã— RTTVAR


Mesures suivantes :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î± = 1/8 = 0.125 (poids du nouveau RTT)
Î² = 1/4 = 0.25 (poids de la nouvelle variance)

RTTVAR = (1 - Î²) Ã— RTTVAR + Î² Ã— |SRTT - R|
SRTT = (1 - Î±) Ã— SRTT + Î± Ã— R
RTO = SRTT + 4 Ã— RTTVAR


Contraintes :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RTO_min = 200 ms (Linux) ou 1 seconde (RFC)
RTO_max = 120 secondes
Si RTO < RTO_min : RTO = RTO_min
Si RTO > RTO_max : RTO = RTO_max
```

### Exemple de calcul dÃ©taillÃ©

```
ScÃ©nario : Mesures RTT successives
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Mesure 1 : R = 100 ms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SRTT = 100 ms
RTTVAR = 100 / 2 = 50 ms
RTO = 100 + 4 Ã— 50 = 300 ms


Mesure 2 : R = 120 ms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|SRTT - R| = |100 - 120| = 20 ms

RTTVAR = 0.75 Ã— 50 + 0.25 Ã— 20
       = 37.5 + 5
       = 42.5 ms

SRTT = 0.875 Ã— 100 + 0.125 Ã— 120
     = 87.5 + 15
     = 102.5 ms

RTO = 102.5 + 4 Ã— 42.5
    = 102.5 + 170
    = 272.5 ms


Mesure 3 : R = 80 ms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|SRTT - R| = |102.5 - 80| = 22.5 ms

RTTVAR = 0.75 Ã— 42.5 + 0.25 Ã— 22.5
       = 31.875 + 5.625
       = 37.5 ms

SRTT = 0.875 Ã— 102.5 + 0.125 Ã— 80
     = 89.6875 + 10
     = 99.6875 ms

RTO = 99.6875 + 4 Ã— 37.5
    = 99.6875 + 150
    = 249.6875 ms
    â‰ˆ 250 ms


Mesure 4 : R = 200 ms (spike !)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|SRTT - R| = |99.7 - 200| = 100.3 ms

RTTVAR = 0.75 Ã— 37.5 + 0.25 Ã— 100.3
       = 28.125 + 25.075
       = 53.2 ms

SRTT = 0.875 Ã— 99.7 + 0.125 Ã— 200
     = 87.2375 + 25
     = 112.2375 ms

RTO = 112.2375 + 4 Ã— 53.2
    = 112.2375 + 212.8
    = 325.0375 ms
    â‰ˆ 325 ms

RTO a augmentÃ© pour s'adapter Ã  la variabilitÃ© âœ“
```

### Visualisation de l'adaptation

```
RTT mesurÃ© vs RTO calculÃ© :

ms
    â”‚
400 â”‚                    â•±â”€â”€â”€â”€â•² RTO
    â”‚                  â•±        â•²
350 â”‚                â•±            â•²
    â”‚              â•±                â•²
300 â”‚            â•±                    â•²â”€â”€â”€â”€
    â”‚          â•±
250 â”‚        â•±
    â”‚      â•±                            RTT mesurÃ©
200 â”‚    â•±                           â•±â•²
    â”‚  â•±                           â•±  â•²
150 â”‚â•±                           â•±      â•²
    â”‚                          â•±          â•²
100 â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²â”€â”€â”€â”€â”€â”€â•²â”€â”€â”€â”€â”€â”€â•±              â•²â”€â”€â”€â”€
    â”‚          â•²    â•±â•²    â•±
 50 â”‚           â•²  â•±  â•²  â•±
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Temps
    0    1    2    3    4    5    6    7    8

Observations :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ RTO toujours > RTT (marge de sÃ©curitÃ©)
â€¢ RTO s'adapte Ã  la variabilitÃ©
â€¢ Spike RTT â†’ RTO augmente
â€¢ RTT stable â†’ RTO diminue
```

## MÃ©canisme de retransmission par timeout

### SÃ©quence d'Ã©vÃ©nements

```
Chronologie dÃ©taillÃ©e d'un timeout :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

T=0ms : Ã‰metteur envoie segment
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ã‰metteur                        RÃ©cepteur
   â”‚                               â”‚
   â”‚ SEQ=1000, 1460 octets         â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                               â”‚
   â”‚ DÃ©marre timer RTO=250ms       â”‚
   â”‚ â°                            â”‚


T=0-250ms : Attente de l'ACK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚                                â”‚
   â”‚ Timer en cours...              â”‚
   â”‚ â±ï¸ 50ms                        â”‚
   â”‚ â±ï¸ 100ms                       â”‚
   â”‚ â±ï¸ 150ms                       â”‚
   â”‚ â±ï¸ 200ms                       â”‚
   â”‚ â±ï¸ 250ms â† Timeout !           â”‚


T=250ms : Timeout RTO
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ ğŸ’¥ RTO expirÃ© !               â”‚
   â”‚                               â”‚
   â”‚ Actions :                     â”‚
   â”‚ 1. ssthresh = cwnd / 2        â”‚
   â”‚ 2. cwnd = 1 MSS               â”‚
   â”‚ 3. RTO = RTO Ã— 2 (backoff)    â”‚
   â”‚ 4. Retransmission             â”‚
   â”‚                               â”‚
   â”‚ SEQ=1000, 1460 octets (retr.) â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                               â”‚
   â”‚ Nouveau timer RTO=500ms       â”‚
   â”‚ â°                            â”‚


T=300ms : ACK reÃ§u (enfin !)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=2460
   â”‚                               â”‚
   â”‚ âœ“ Annule timer                â”‚
   â”‚ âœ“ Retransmission rÃ©ussie      â”‚
   â”‚                               â”‚
   â”‚ Reprend avec cwnd=1 MSS       â”‚
   â”‚ (Slow Start)                  â”‚
```

### Exemples de scÃ©narios

#### ScÃ©nario 1 : Perte du segment

```
T=0   : Ã‰metteur envoie SEQ=1000
        RTO=250ms

T=0-5 : Segment perdu dans le rÃ©seau âŒ

T=250 : Timeout !
        Retransmission SEQ=1000
        RTO=500ms (doublÃ©)

T=275 : ACK=1460 reÃ§u âœ“

DÃ©lai total : 275ms
Impact : DÃ©lai de 250ms dÃ» au timeout
```

#### ScÃ©nario 2 : Perte de l'ACK

```
T=0   : Ã‰metteur envoie SEQ=1000
        RTO=250ms

T=25  : Segment arrive au rÃ©cepteur âœ“
        RÃ©cepteur envoie ACK=1460

T=30  : ACK perdu dans le rÃ©seau âŒ

T=250 : Timeout !
        Retransmission SEQ=1000
        RTO=500ms (doublÃ©)

T=275 : Segment arrive (duplicate !)
        RÃ©cepteur renvoie ACK=1460

T=300 : ACK=1460 reÃ§u âœ“

DÃ©lai total : 300ms
Impact : Retransmission inutile (spurious)
        RÃ©cepteur reÃ§oit deux fois le mÃªme segment
```

#### ScÃ©nario 3 : Timeouts en cascade

```
T=0    : Envoi SEQ=1000, RTO=250ms
T=250  : Timeout #1, retr., RTO=500ms
T=750  : Timeout #2, retr., RTO=1000ms
T=1750 : Timeout #3, retr., RTO=2000ms
T=3750 : Timeout #4, retr., RTO=4000ms
T=7750 : Timeout #5, retr., RTO=8000ms
...

Backoff exponentiel :
250 â†’ 500 â†’ 1000 â†’ 2000 â†’ 4000 â†’ 8000 ms

AprÃ¨s 15 tentatives (dÃ©faut Linux) :
Total â‰ˆ 900 secondes (15 minutes)
â†’ Abandon de la connexion
```

## Fast Retransmit (retransmission rapide)

### Principe

Utilise les **ACK dupliquÃ©s** pour dÃ©tecter rapidement une perte sans attendre le timeout.

```
RÃ¨gle du Fast Retransmit :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Si 3 ACK identiques consÃ©cutifs reÃ§us :
  â†’ Segment probablement perdu
  â†’ Retransmission immÃ©diate
  â†’ Pas d'attente du timeout
  â†’ Ã‰conomie de temps âš¡
```

### SÃ©quence dÃ©taillÃ©e

```
Chronologie Fast Retransmit :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

T=0ms : Envoi de 5 segments
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ã‰metteur                          RÃ©cepteur
   â”‚                                  â”‚
   â”‚ â‘  SEQ=1000, 1460 octets â”€â”€â”€â”€â”€>  â”‚ âœ“ ReÃ§u
   â”‚ â‘¡ SEQ=2460, 1460 octets â”€â”€X     â”‚ âŒ Perdu
   â”‚ â‘¢ SEQ=3920, 1460 octets â”€â”€â”€â”€â”€>  â”‚ âœ“ ReÃ§u (hors ordre)
   â”‚ â‘£ SEQ=5380, 1460 octets â”€â”€â”€â”€â”€>  â”‚ âœ“ ReÃ§u (hors ordre)
   â”‚ â‘¤ SEQ=6840, 1460 octets â”€â”€â”€â”€â”€>  â”‚ âœ“ ReÃ§u (hors ordre)


T=25ms : RÃ©cepteur rÃ©pond
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=2460 â”‚ (pour â‘ )
   â”‚                                  â”‚
   â”‚ Buffer : [âœ“][âŒ][âœ“][âœ“][âœ“]        â”‚
   â”‚          Attend SEQ=2460         â”‚


T=50ms : Segments â‘¢â‘£â‘¤ arrivent
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=2460 â”‚ (dup 1, attend â‘¡)
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=2460 â”‚ (dup 2)
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=2460 â”‚ (dup 3) ğŸš¨
   â”‚                                  â”‚
   â”‚ âš¡ 3 dup ACK dÃ©tectÃ©s !          â”‚
   â”‚ Fast Retransmit !                â”‚
   â”‚                                  â”‚
   â”‚ â‘¡ SEQ=2460 (retransmis) â”€â”€â”€â”€â”€>  â”‚ âœ“


T=75ms : RÃ©cupÃ©ration
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ACK=8300 â”‚
   â”‚                                  â”‚
   â”‚ âœ“ Trou comblÃ© !                  â”‚
   â”‚ âœ“ Tous les segments acquittÃ©s    â”‚

Temps total : 75ms
Sans Fast Retransmit : 250ms (timeout)
Gain : 175ms Ã©conomisÃ©s ! âš¡
```

### Avantages et limitations

```
Avantages :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ DÃ©tection rapide (1 RTT au lieu de RTO)
âœ“ Pas de pÃ©nalitÃ© timeout (cwnd pas rÃ©duit Ã  1)
âœ“ Fast Recovery possible
âœ“ Meilleure performance

Limitations :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ NÃ©cessite au moins 3 segments aprÃ¨s la perte
   (sinon pas assez de dup ACK)
âŒ Ne fonctionne que pour la premiÃ¨re perte
   (pertes multiples = problÃ¨me)
âŒ Peut causer retransmissions inutiles
   (rÃ©ordonnancement vs perte)
```

### Pourquoi 3 ACK dupliquÃ©s ?

```
Raison : Distinguer perte de rÃ©ordonnancement
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RÃ©ordonnancement lÃ©ger :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Segments arrivent : â‘  â‘¢ â‘¡ â‘£
ACK envoyÃ©s : ACK(â‘ ) ACK(â‘ ) ACK(â‘£)
                      â†‘ 1 dup seulement
â†’ Normal, pas de retransmission


Perte rÃ©elle :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Segments : â‘  perdu â‘¢ â‘£ â‘¤
ACK : ACK(â‘ ) ACK(â‘ ) ACK(â‘ ) ACK(â‘ )
             dup1   dup2   dup3
â†’ 3 dup = vraiment perdu â†’ retransmettre


Compromis :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ < 3 dup : Trop de retransmissions inutiles
â€¢ > 3 dup : DÃ©tection trop lente
â€¢ 3 dup : Ã‰quilibre optimal (empirique)
```

## SACK et retransmissions sÃ©lectives

### Le problÃ¨me sans SACK

```
Perte de plusieurs segments :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

EnvoyÃ© : â‘  â‘¡ â‘¢ â‘£ â‘¤
Perdu  :    â‘¡    â‘£

Sans SACK :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACK reÃ§u : ACK=position_â‘¡
â†’ Ã‰metteur sait que â‘¡ est perdu
â†’ Mais ne sait PAS si â‘¢â‘£â‘¤ sont arrivÃ©s
â†’ Doit retransmettre â‘¡â‘¢â‘£â‘¤ (tout)
â†’ â‘¢ et â‘¤ sont retransmis inutilement ! ğŸ’€


Avec SACK :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACK reÃ§u : ACK=position_â‘¡, SACK=[â‘¢][â‘¤]
â†’ Ã‰metteur sait que â‘¡ et â‘£ sont perdus
â†’ Sait que â‘¢ et â‘¤ sont arrivÃ©s
â†’ Retransmet SEULEMENT â‘¡ et â‘£ âœ“

Ã‰conomie : 50% de bande passante !
```

### Format SACK

```
Option TCP SACK :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Kind â”‚ Len  â”‚ Left Edge  â”‚ Right Edge â”‚
â”‚  5   â”‚  N   â”‚  (4 bytes) â”‚  (4 bytes) â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Peut contenir jusqu'Ã  4 blocs (3 si timestamps)


Exemple :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACK=2460, SACK=[3920-5380][6840-8300]

Signification :
"J'attends 2460, mais j'ai dÃ©jÃ  reÃ§u :
 - Octets 3920-5379
 - Octets 6840-8299"

Manquants :
 - 2460-3919 (segment â‘¡)
 - 5380-6839 (segment â‘£)
```

### Exemple complet avec SACK

```
Configuration :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MSS = 1460 octets
SACK activÃ©


T=0ms : Envoi initial
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ã‰metteur                          RÃ©cepteur
   â”‚                                  â”‚
   â”‚ â‘  SEQ=1000, 1460 octets â”€â”€â”€â”€â”€>  â”‚ âœ“
   â”‚ â‘¡ SEQ=2460, 1460 octets â”€â”€X     â”‚ âŒ
   â”‚ â‘¢ SEQ=3920, 1460 octets â”€â”€X     â”‚ âŒ
   â”‚ â‘£ SEQ=5380, 1460 octets â”€â”€â”€â”€â”€>  â”‚ âœ“
   â”‚ â‘¤ SEQ=6840, 1460 octets â”€â”€â”€â”€â”€>  â”‚ âœ“


T=50ms : ACK avec SACK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€ ACK=2460, SACK=[]          â”‚ (pour â‘ )
   â”‚ <â”€â”€â”€â”€ ACK=2460, SACK=[5380-6840] â”‚ (â‘£ reÃ§u)
   â”‚ <â”€â”€â”€â”€ ACK=2460, SACK=[5380-8300] â”‚ (â‘£â‘¤ reÃ§us)
   â”‚                                  â”‚
   â”‚ Analyse SACK :                   â”‚
   â”‚ Manquants : 2460-5380 (â‘¡â‘¢)      â”‚


T=51ms : Retransmission sÃ©lective
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ â‘¡ SEQ=2460 (retrans) â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ âœ“
   â”‚ â‘¢ SEQ=3920 (retrans) â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ âœ“


T=76ms : RÃ©cupÃ©ration complÃ¨te
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”‚ <â”€â”€â”€â”€ ACK=8300                â”‚
   â”‚                               â”‚
   â”‚ âœ“ Tout reÃ§u !                 â”‚

Sans SACK : Aurait retransmis â‘¡â‘¢â‘£â‘¤ (4 segments)
Avec SACK : Retransmis â‘¡â‘¢ seulement (2 segments)
Ã‰conomie : 50% âœ“
```

## Autres timers TCP

### 1. Persist Timer

GÃ¨re les situations de **Zero Window**.

```
ProblÃ¨me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RÃ©cepteur annonce WIN=0 (buffer plein)
Ã‰metteur arrÃªte d'envoyer
Plus tard, rÃ©cepteur libÃ¨re buffer
Envoie Window Update... mais il est PERDU !

â†’ Deadlock ! Ã‰metteur attend, rÃ©cepteur attend


Solution : Persist Timer
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ã‰metteur envoie pÃ©riodiquement des "probes"
(Zero Window Probe) pour vÃ©rifier l'Ã©tat


Intervalles :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1er probe : 5s
2e probe  : 10s
3e probe  : 20s
4e probe  : 40s
5e probe  : 60s (max)

Puis 60s en continu jusqu'Ã  rÃ©ouverture ou timeout
```

### 2. Keepalive Timer

DÃ©tecte les **connexions mortes**.

```
ProblÃ¨me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Connexion TCP Ã©tablie
Aucun Ã©change pendant longtemps
Le pair a peut-Ãªtre :
  - CrashÃ©
  - RebootÃ©
  - Perdu la connexion rÃ©seau

Comment savoir ?


Solution : Keepalive Timer
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Envoie pÃ©riodiquement des segments keepalive
(0 ou 1 octet de donnÃ©es)

Si pas de rÃ©ponse â†’ connexion morte


Configuration (Linux) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/proc/sys/net/ipv4/tcp_keepalive_time
7200  (2 heures avant premier probe)

/proc/sys/net/ipv4/tcp_keepalive_intvl
75  (75s entre probes)

/proc/sys/net/ipv4/tcp_keepalive_probes
9  (9 probes avant abandon)

Timeout total : 2h + 9Ã—75s â‰ˆ 2h11min


Activer par socket :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
int optval = 1;
setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,
           &optval, sizeof(optval));

// Ajuster paramÃ¨tres
optval = 60;  // 60s avant premier probe
setsockopt(sock, IPPROTO_TCP, TCP_KEEPIDLE,
           &optval, sizeof(optval));
```

### 3. TIME-WAIT Timer

Maintient la connexion en Ã©tat TIME-WAIT aprÃ¨s fermeture.

```
DurÃ©e : 2 Ã— MSL (Maximum Segment Lifetime)
        = 60-120 secondes typiquement

Raison :
â”€â”€â”€â”€â”€â”€â”€â”€
1. Permettre retransmission du dernier ACK
2. Ã‰viter confusion avec anciennes connexions

Voir section 4.5.4 (Fermeture de connexion)
pour dÃ©tails complets
```

### 4. FIN-WAIT-2 Timer

Limite le temps en Ã©tat FIN-WAIT-2.

```
ProblÃ¨me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Client envoie FIN
Serveur envoie ACK
Client en FIN-WAIT-2
Mais serveur ne ferme JAMAIS
â†’ Client bloquÃ© indÃ©finiment ?


Solution : FIN-WAIT-2 Timer
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AprÃ¨s X secondes, abandon


Configuration (Linux) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/proc/sys/net/ipv4/tcp_fin_timeout
60  (60 secondes)

AprÃ¨s 60s sans FIN du serveur :
â†’ Connexion fermÃ©e de force
```

## Exponential Backoff

### Principe

Quand les retransmissions Ã©chouent rÃ©pÃ©titivement, RTO **double** Ã  chaque fois.

```
Logique :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Si le rÃ©seau est vraiment congestionnÃ© :
  â†’ Retransmettre rapidement aggrave le problÃ¨me
  â†’ Attendre plus longtemps donne au rÃ©seau
    le temps de se dÃ©congestionner

SÃ©quence typique :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Tentative 1 : RTO = 250ms
Tentative 2 : RTO = 500ms
Tentative 3 : RTO = 1000ms  (1s)
Tentative 4 : RTO = 2000ms  (2s)
Tentative 5 : RTO = 4000ms  (4s)
Tentative 6 : RTO = 8000ms  (8s)
Tentative 7 : RTO = 16000ms (16s)
Tentative 8 : RTO = 32000ms (32s)
Tentative 9 : RTO = 64000ms (64s)
Tentative 10: RTO = 120000ms (120s, max)

AprÃ¨s X tentatives : Abandon
```

### Exemple chronologique

```
ScÃ©nario : RÃ©seau totalement inaccessible
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

T=0s     : Envoi SEQ=1000, RTO=250ms
T=0.25s  : Timeout #1, retr., RTO=500ms
T=0.75s  : Timeout #2, retr., RTO=1s
T=1.75s  : Timeout #3, retr., RTO=2s
T=3.75s  : Timeout #4, retr., RTO=4s
T=7.75s  : Timeout #5, retr., RTO=8s
T=15.75s : Timeout #6, retr., RTO=16s
T=31.75s : Timeout #7, retr., RTO=32s
T=63.75s : Timeout #8, retr., RTO=64s
T=127.75s: Timeout #9, retr., RTO=120s
T=247.75s: Timeout #10, retr., RTO=120s
T=367.75s: Timeout #11, retr., RTO=120s
T=487.75s: Timeout #12, retr., RTO=120s
T=607.75s: Timeout #13, retr., RTO=120s
T=727.75s: Timeout #14, retr., RTO=120s
T=847.75s: Timeout #15, ABANDON ! ğŸ’€

Total : ~15 minutes d'attente
15 tentatives de retransmission
```

### Configuration Linux

```bash
# Nombre maximum de retransmissions
sysctl net.ipv4.tcp_retries2
15  (dÃ©faut, connexion Ã©tablie)

sysctl net.ipv4.tcp_retries1
3   (avant de notifier routage)

# Pour SYN (Ã©tablissement de connexion)
sysctl net.ipv4.tcp_syn_retries
6   (abandon aprÃ¨s ~127s)

# Modifier
sysctl -w net.ipv4.tcp_retries2=10
# â†’ Abandon plus rapide (aprÃ¨s ~5 minutes)
```

## Retransmissions inutiles (Spurious Retransmissions)

### Causes

Retransmissions dÃ©clenchÃ©es alors que le segment n'Ã©tait pas rÃ©ellement perdu.

```
Causes courantes :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. RTO trop court
   â†’ Timeout prÃ©maturÃ©
   â†’ Segment arrive juste aprÃ¨s retransmission

2. RÃ©ordonnancement sÃ©vÃ¨re
   â†’ 3 dup ACK dÃ©clenchÃ©s
   â†’ Mais segment arrive finalement

3. ACK retardÃ© (delayed ACK)
   â†’ ACK envoyÃ© tardivement
   â†’ Timeout entre-temps

4. Spike de latence
   â†’ RTT temporairement Ã©levÃ©
   â†’ RTO pas adaptÃ© assez vite
```

### Exemple de spurious retransmission

```
ScÃ©nario : ACK retardÃ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

T=0ms   : Ã‰metteur envoie SEQ=1000
          RTO=250ms

T=25ms  : Segment arrive au rÃ©cepteur âœ“
          RÃ©cepteur dÃ©marre Delayed ACK (200ms)

T=225ms : RÃ©cepteur envoie ACK=1460
          (aprÃ¨s 200ms de delayed ACK)

T=250ms : Timeout RTO Ã  l'Ã©metteur ! ğŸ’¥
          Retransmission SEQ=1000

T=275ms : ACK=1460 arrive (trop tard)
          âœ“ Original Ã©tait bien arrivÃ©

T=300ms : Segment retransmis arrive (duplicate)
          RÃ©cepteur envoie ACK=1460 (duplicate)

RÃ©sultat :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Retransmission inutile
âŒ Gaspillage de bande passante
âŒ cwnd rÃ©duit inutilement
âŒ RTO doublÃ© inutilement
```

### DÃ©tection et correction

#### F-RTO (Forward RTO-Recovery)

```
F-RTO (RFC 5682) :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DÃ©tecte les spurious retransmissions aprÃ¨s timeout

Principe :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AprÃ¨s retransmission :
  - Envoie 2 nouveaux segments
  - Observe les ACK

Si ACK pour les nouveaux segments avant l'ancien :
  â†’ Retransmission Ã©tait spurious
  â†’ Ne rÃ©duit pas cwnd
  â†’ Restaure Ã©tat

Configuration Linux :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sysctl net.ipv4.tcp_frto
2  (activÃ© en mode conservateur)
```

#### Eifel Detection (RFC 3522)

```
Eifel Detection :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Utilise timestamps TCP pour dÃ©tecter spurious

MÃ©canisme :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Retransmission envoyÃ©e avec TSval=T1
ACK reÃ§u avec TSecr=T0 (avant retransmission)
â†’ ACK pour transmission originale
â†’ Retransmission Ã©tait spurious

Action :
â”€â”€â”€â”€â”€â”€â”€â”€
Restaure cwnd et ssthresh
Annule backoff RTO
```

#### Eifel Response (RFC 4015)

```
Eifel Response :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DÃ©finit comment rÃ©agir Ã  spurious detection

Actions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Restaurer cwnd Ã  valeur prÃ©-timeout
2. Restaurer ssthresh
3. Restaurer RTO (annuler backoff)
4. Ne PAS entrer en Slow Start

RÃ©sultat :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Performance prÃ©servÃ©e malgrÃ© spurious âœ“
```

## Diagnostic et monitoring

### Commandes systÃ¨me

```bash
# Statistiques de retransmission
netstat -s | grep -i retrans

# Sortie exemple :
# 12345 segments retransmitted
# 678 times packets where retransmitted
# 234 fast retransmits
# 89 retransmits in slow start
# 45 spurious RTO caused by DSACKs

Analyse :
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Taux de retrans = retrans / segments_out
Acceptable : < 1%
ProblÃ©matique : > 5%


# DÃ©tail par connexion
ss -tie

# Sortie exemple :
tcp ESTAB 0 0 192.168.1.10:54321 93.184.216.34:443
     cubic wscale:7,7 rto:204 rtt:3.5/1.75
     ato:40 mss:1460 pmtu:1500 rcvmss:1460
     advmss:1460 cwnd:10 ssthresh:7
     bytes_sent:123456 bytes_acked:123000
     bytes_received:654321 segs_out:789
     segs_in:456 data_segs_out:678
     data_segs_in:345 send 28.7Mbps
     lastsnd:1 lastrcv:1 lastack:1
     pacing_rate 34.5Mbps delivery_rate 25.3Mbps
     busy:5280ms rwnd_limited:120ms(2.3%)
     sndbuf_limited:0ms(0.0%)
     unacked:0 retrans:0/5 â† Important !
              â–²         â–²    â–²
              â”‚         â”‚    â””â”€ Total retrans
              â”‚         â””â”€â”€â”€â”€â”€â”€ Actuellement non acquittÃ©
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Retrans en cours

     reordering:3 rcv_space:29200
     rcv_ssthresh:29200 minrtt:3.5
```

### Wireshark

```
Filtres pour retransmissions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Toutes retransmissions
tcp.analysis.retransmission

# Fast Retransmit spÃ©cifiquement
tcp.analysis.fast_retransmission

# Spurious Retransmissions
tcp.analysis.spurious_retransmission

# Duplicate ACK
tcp.analysis.duplicate_ack

# RTO
tcp.analysis.rto


Exemple de capture :
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Frame 1234: [TCP Retransmission]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Source: 192.168.1.10
Destination: 93.184.216.34
Sequence: 12345 (relative)
Length: 1460

[SEQ/ACK analysis]
    [This is a retransmission]
    [RTO: 0.204 seconds]
    [Original segment in frame: 1150]
    [Time since original: 0.250 seconds]


Frame 1235-1237: [TCP Dup ACK]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[Expert Info: Duplicate ACK (#3)]


Frame 1238: [TCP Fast Retransmission]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[Expert Info: Fast retransmission]
[Time to retransmit: 0.015 seconds]


Frame 1250: [TCP Spurious Retransmission]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[Expert Info: Spurious retransmission]
[Original transmission was ACKed in frame: 1240]
```

### Graphiques Wireshark

```
Statistics â†’ TCP Stream Graphs â†’ Time-Sequence (Stevens)

Visualisation des retransmissions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SEQ
 â”‚     Original
 â”‚    â•±
 â”‚   â•±
 â”‚  â•±    âš ï¸ Retransmission (mÃªme SEQ)
 â”‚ â•±     â•±
 â”‚â•±     â•±
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Temps

Identification :
- Ligne horizontale = retransmission
- Retour en arriÃ¨re dans SEQ
- Plusieurs points au mÃªme SEQ


Statistics â†’ TCP Stream Graphs â†’ Round Trip Time

Visualisation RTO/RTT :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RTT (ms)
 â”‚
 â”‚    RTO
 â”‚   â•±â”€â”€â”€â”€â•²  Spike
 â”‚  â•±      â•²
 â”‚ â•±        â•²____
 â”‚â•±  RTT
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Temps

- Spikes RTT â†’ Congestion
- RTO augmente â†’ Adaptation
- Timeouts visibles (gaps)
```

## Tuning et optimisation

### ParamÃ¨tres RTO

```bash
# RTO minimum (Linux)
sysctl net.ipv4.tcp_rto_min
# 200 (200ms, dÃ©faut Linux)
# RFC suggÃ¨re 1000ms (trop conservateur)

# RÃ©duire pour LAN :
sysctl -w net.ipv4.tcp_rto_min=20  # 20ms
# Attention : Risque spurious retransmissions !

# Augmenter pour satellite/haute latence :
sysctl -w net.ipv4.tcp_rto_min=1000  # 1s


# RTO maximum
# CodÃ© en dur : 120 secondes
# Non modifiable


# Retries
sysctl net.ipv4.tcp_retries2
15  (dÃ©faut)

# RÃ©duire pour connexions courtes :
sysctl -w net.ipv4.tcp_retries2=8
# Abandon aprÃ¨s ~3-5 minutes au lieu de 15
```

### Activer SACK

```bash
# SACK (Selective Acknowledgment)
sysctl net.ipv4.tcp_sack
1  (activÃ© par dÃ©faut)

# Si dÃ©sactivÃ© (rare), activer :
sysctl -w net.ipv4.tcp_sack=1

# Essentiel pour :
# - Pertes multiples
# - RÃ©seaux haute latence
# - Performance optimale
```

### Activer F-RTO

```bash
# F-RTO (Forward RTO Recovery)
sysctl net.ipv4.tcp_frto
2  (mode conservateur, recommandÃ©)

# Valeurs :
# 0 = dÃ©sactivÃ©
# 1 = mode agressif
# 2 = mode conservateur (dÃ©faut)

# Active la dÃ©tection de spurious retransmissions
# PrÃ©serve cwnd quand c'est le cas
```

### Timestamps

```bash
# TCP Timestamps
sysctl net.ipv4.tcp_timestamps
1  (activÃ© par dÃ©faut)

# BÃ©nÃ©fices :
# âœ“ Mesure RTT prÃ©cise
# âœ“ PAWS (Protection Against Wrapped Sequences)
# âœ“ Eifel detection (spurious)

# Ne dÃ©sactiver que si absolument nÃ©cessaire
# (compatibilitÃ© anciens Ã©quipements)
```

## ProblÃ¨mes courants et solutions

### ProblÃ¨me 1 : Taux de retransmission Ã©levÃ©

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
netstat -s | grep retrans
"5% segments retransmitted"

Diagnostic :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. VÃ©rifier RTT et variation :
   ping -c 100 destination
   # RTT trÃ¨s variable = problÃ¨me

2. VÃ©rifier pertes :
   mtr destination
   # Pertes constantes sur un saut

3. VÃ©rifier RTO :
   ss -ti | grep rto
   # RTO anormalement court/long

Causes possibles :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
A. Congestion rÃ©seau
B. Pertes physiques (WiFi, cÃ¢bles)
C. RTO mal calibrÃ©
D. Buffer routeur inadÃ©quat

Solutions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
A. Congestion :
   - RÃ©duire dÃ©bit applicatif
   - Activer ECN
   - Utiliser BBR

B. Pertes physiques :
   - AmÃ©liorer signal WiFi
   - VÃ©rifier cÃ¢bles
   - Remplacer matÃ©riel dÃ©fectueux

C. RTO :
   - VÃ©rifier tcp_rto_min
   - Activer F-RTO
   - Activer timestamps

D. Buffers :
   - AQM (fq_codel, cake)
   - RÃ©duire buffers si bufferbloat
```

### ProblÃ¨me 2 : Timeouts frÃ©quents

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Wireshark montre beaucoup de [TCP RTO]
Connexions lentes

Diagnostic :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ss -ti | grep "rto:"
# rto:2000 â† TrÃ¨s Ã©levÃ© !

Causes :
â”€â”€â”€â”€â”€â”€â”€â”€
1. RTT trÃ¨s variable (spike)
2. RÃ©seau instable
3. CPU surchargÃ© (dÃ©lai traitement)

Solutions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Augmenter tcp_rto_min :
   sysctl -w net.ipv4.tcp_rto_min=500

2. Activer F-RTO :
   sysctl -w net.ipv4.tcp_frto=2

3. Utiliser BBR :
   sysctl -w net.ipv4.tcp_congestion_control=bbr
   # BBR gÃ¨re mieux variabilitÃ©

4. VÃ©rifier CPU :
   top, htop
   # Si surchargÃ©, optimiser/scaling
```

### ProblÃ¨me 3 : Spurious retransmissions

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Wireshark : [TCP Spurious Retransmission]
Performance dÃ©gradÃ©e sans raison apparente

Diagnostic :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
netstat -s | grep "spurious RTO"
# Nombre Ã©levÃ© = problÃ¨me

Causes :
â”€â”€â”€â”€â”€â”€â”€â”€
1. RTO trop court
2. Delayed ACK + RTO court
3. RÃ©seau avec variation importante

Solutions :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Augmenter tcp_rto_min :
   sysctl -w net.ipv4.tcp_rto_min=200

2. Activer F-RTO et Eifel :
   sysctl -w net.ipv4.tcp_frto=2
   # DÃ©tection et correction automatique

3. VÃ©rifier timestamps activÃ©s :
   sysctl net.ipv4.tcp_timestamps
   # Doit Ãªtre 1

4. DÃ©sactiver Nagle si latence critique :
   # TCP_NODELAY dans l'application
```

### ProblÃ¨me 4 : Connexion abandonnÃ©e prÃ©maturÃ©ment

```
SymptÃ´me :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"Connection timed out" aprÃ¨s quelques secondes
RÃ©seau semble OK pourtant

Diagnostic :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ss -ti
# retrans:0/3 â† Seulement 3 tentatives !

sysctl net.ipv4.tcp_retries2
3  â† Trop faible !

Cause :
â”€â”€â”€â”€â”€â”€â”€
ParamÃ¨tre tcp_retries2 modifiÃ©
Abandon trop rapide

Solution :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Restaurer valeur par dÃ©faut
sysctl -w net.ipv4.tcp_retries2=15

# Ou valeur intermÃ©diaire
sysctl -w net.ipv4.tcp_retries2=8
# Abandon aprÃ¨s ~5 minutes
```

## RÃ©sumÃ©

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         RETRANSMISSIONS ET TIMERS TCP                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  RTT (Round-Trip Time) :                                 â”‚
â”‚  â€¢ Temps aller-retour d'un segment                       â”‚
â”‚  â€¢ MesurÃ© dynamiquement                                  â”‚
â”‚  â€¢ Base pour calculer RTO                                â”‚
â”‚                                                          â”‚
â”‚  RTO (Retransmission Timeout) :                          â”‚
â”‚  â€¢ RTO = SRTT + 4 Ã— RTTVAR                               â”‚
â”‚  â€¢ Algorithme de Jacobson/Karels                         â”‚
â”‚  â€¢ AdaptÃ© dynamiquement au RTT                           â”‚
â”‚  â€¢ RTO_min = 200ms (Linux)                               â”‚
â”‚                                                          â”‚
â”‚  DÃ©tection de perte :                                    â”‚
â”‚  1. Timeout RTO                                          â”‚
â”‚     â†’ Perte sÃ©vÃ¨re                                       â”‚
â”‚     â†’ cwnd = 1 MSS                                       â”‚
â”‚     â†’ RTO doublÃ© (exponential backoff)                   â”‚
â”‚                                                          â”‚
â”‚  2. Fast Retransmit (3 dup ACK)                          â”‚
â”‚     â†’ Perte isolÃ©e                                       â”‚
â”‚     â†’ cwnd = cwnd / 2                                    â”‚
â”‚     â†’ Fast Recovery possible                             â”‚
â”‚                                                          â”‚
â”‚  SACK (Selective Acknowledgment) :                       â”‚
â”‚  â€¢ Informe quels segments sont reÃ§us                     â”‚
â”‚  â€¢ Retransmissions sÃ©lectives                            â”‚
â”‚  â€¢ Ã‰conomie de bande passante                            â”‚
â”‚                                                          â”‚
â”‚  Autres timers :                                         â”‚
â”‚  â€¢ Persist : Zero Window Probe                           â”‚
â”‚  â€¢ Keepalive : DÃ©tection connexions mortes               â”‚
â”‚  â€¢ TIME-WAIT : AprÃ¨s fermeture (2Ã—MSL)                   â”‚
â”‚  â€¢ FIN-WAIT-2 : Limite temps attente FIN                 â”‚
â”‚                                                          â”‚
â”‚  Spurious Retransmissions :                              â”‚
â”‚  â€¢ F-RTO : DÃ©tection et correction                       â”‚
â”‚  â€¢ Eifel : Utilise timestamps                            â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Conclusion

Les retransmissions et timers sont les mÃ©canismes qui permettent Ã  TCP de garantir la fiabilitÃ© malgrÃ© les pertes inÃ©vitables sur les rÃ©seaux modernes.

**Points clÃ©s** :

1. **RTT** : MesurÃ© continuellement, base de tout
2. **RTO** : CalculÃ© dynamiquement via Jacobson/Karels
3. **Deux mÃ©thodes** : Timeout (lent) et Fast Retransmit (rapide)
4. **SACK** : Essentiel pour pertes multiples
5. **Exponential backoff** : Ã‰vite d'aggraver la congestion
6. **Spurious detection** : F-RTO et Eifel prÃ©servent performance
7. **Autres timers** : Persist, Keepalive, TIME-WAIT, FIN-WAIT-2

**Formules importantes** :

```
RTO = SRTT + 4 Ã— RTTVAR

SRTT = (1 - Î±) Ã— SRTT + Î± Ã— RTT
       Î± = 1/8

RTTVAR = (1 - Î²) Ã— RTTVAR + Î² Ã— |SRTT - RTT|
         Î² = 1/4

Exponential Backoff :
RTO_nouveau = RTO_ancien Ã— 2
```

**Recommandations** :

```
Production :
âœ“ SACK activÃ© (tcp_sack=1)
âœ“ Timestamps activÃ©s (tcp_timestamps=1)
âœ“ F-RTO activÃ© (tcp_frto=2)
âœ“ RTO_min adaptÃ© au rÃ©seau (200ms dÃ©faut)
âœ“ tcp_retries2 = 15 (ou 8-10 si besoin)

Surveillance :
âœ“ Taux retransmission < 1%
âœ“ RTO stable et raisonnable
âœ“ Peu de spurious retransmissions
âœ“ Fast Retransmit privilÃ©giÃ© vs timeout
```

Les retransmissions sont coÃ»teuses mais nÃ©cessaires. L'objectif est de :
- Les dÃ©tecter rapidement (Fast Retransmit)
- Les retransmettre efficacement (SACK)
- Les Ã©viter quand inutiles (Spurious detection)
- S'adapter aux conditions (RTO dynamique)

Dans la prochaine section, nous explorerons les **Ã©tats d'une connexion TCP**, complÃ©tant notre comprÃ©hension du cycle de vie complet d'une connexion.

---

**Prochaine section** : 4.5.10 Ã‰tats d'une connexion TCP (diagramme d'Ã©tats)

â­ï¸ [Ã‰tats d'une connexion TCP (diagramme d'Ã©tats)](/04-couche-transport/05.10-tcp-etats-connexion.md)
