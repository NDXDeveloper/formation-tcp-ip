üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.8.3 Circuit Breakers

## Introduction

Imaginez un disjoncteur √©lectrique dans votre maison : quand un court-circuit se produit, il **coupe automatiquement le courant** pour prot√©ger l'installation. Les circuit breakers r√©seau fonctionnent sur le m√™me principe : **quand un service distant √©choue de mani√®re r√©p√©t√©e, le circuit breaker bloque temporairement les appels vers ce service** pour √©viter de gaspiller des ressources et laisser le temps au service de r√©cup√©rer.

**Probl√®me r√©solu** : Les retries permettent de r√©cup√©rer des √©checs transitoires, mais que faire quand un service est compl√®tement down ? Continuer √† retrier aggrave la situation en :
- Saturant vos propres ressources (threads, connexions)
- Amplifiant la charge sur le service d√©faillant
- D√©gradant l'exp√©rience utilisateur (latence √©lev√©e avant √©chec)

**Solution** : Le circuit breaker d√©tecte les d√©faillances persistantes et **√©choue rapidement** (fail-fast) au lieu de tenter inutilement.

---

## Le probl√®me : Cascade de d√©faillances

### Sc√©nario r√©el : L'effet domino

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   SANS CIRCUIT BREAKER                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ  User Request ‚Üí API Gateway ‚Üí Service A ‚Üí Service B      ‚îÇ
‚îÇ                                     ‚Üì                    ‚îÇ
‚îÇ                                  [CRASH]                 ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  Cons√©quences:                                           ‚îÇ
‚îÇ  1. Service A attend 30s (timeout)                       ‚îÇ
‚îÇ  2. Service A retry 3x = 90s total                       ‚îÇ
‚îÇ  3. API Gateway timeout apr√®s 120s                       ‚îÇ
‚îÇ  4. 100 requ√™tes/s √ó 90s = 9000 threads bloqu√©s          ‚îÇ
‚îÇ  5. Service A √©puise ses ressources                      ‚îÇ
‚îÇ  6. Service A devient indisponible                       ‚îÇ
‚îÇ  7. Tous les autres services qui appellent A √©chouent    ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  R√©sultat: Une panne locale devient une panne globale    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   AVEC CIRCUIT BREAKER                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ  User Request ‚Üí API Gateway ‚Üí Service A ‚Üí Service B      ‚îÇ
‚îÇ                                     ‚Üì                    ‚îÇ
‚îÇ                                  [CRASH]                 ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  D√©roulement:                                            ‚îÇ
‚îÇ  1. Service B √©choue 5 fois en 10s                       ‚îÇ
‚îÇ  2. Circuit breaker OPEN ‚Üí blocage des appels            ‚îÇ
‚îÇ  3. Service A re√ßoit imm√©diatement une erreur            ‚îÇ
‚îÇ  4. Service A utilise un fallback ou propage l'erreur    ‚îÇ
‚îÇ  5. Apr√®s 30s, circuit breaker HALF-OPEN                 ‚îÇ
‚îÇ  6. Test de r√©cup√©ration avec 1 requ√™te                  ‚îÇ
‚îÇ  7. Si succ√®s ‚Üí CLOSED, sinon ‚Üí OPEN                     ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  R√©sultat: Service A reste op√©rationnel, panne isol√©e    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Cas r√©el : Netflix (2011)

**Contexte** : Un datacenter AWS tombe en panne. Les services Netflix tentent de se connecter aux instances down.

**Sans circuit breaker** :
- Chaque requ√™te attend le timeout (30s)
- Milliers de threads bloqu√©s
- Saturation m√©moire
- Cascade de pannes
- **Netflix totalement indisponible pendant 4h**

**Apr√®s introduction d'Hystrix (circuit breaker)** :
- D√©tection rapide des instances down
- Basculement automatique vers instances saines
- Services d√©grad√©s mais fonctionnels
- **Downtime r√©duit de 4h √† quelques minutes**

---

## Les trois √©tats d'un circuit breaker

Un circuit breaker fonctionne comme une machine √† √©tats avec trois √©tats possibles :

```
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   CLOSED    ‚îÇ
                    ‚îÇ  (Normal)   ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                    √âchecs r√©p√©t√©s
                    (> threshold)
                           ‚îÇ
                           ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ               OPEN                        ‚îÇ
    ‚îÇ          (Blocage total)                  ‚îÇ
    ‚îÇ  Toutes les requ√™tes √©chouent            ‚îÇ
    ‚îÇ  imm√©diatement sans appel r√©seau         ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
            Apr√®s timeout
           (recovery_timeout)
                   ‚îÇ
                   ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ   HALF-OPEN     ‚îÇ
         ‚îÇ  (Test de       ‚îÇ
         ‚îÇ   r√©cup√©ration) ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ        ‚îÇ
        Succ√®s‚îÇ        ‚îÇ√âchec
              ‚îÇ        ‚îÇ
              ‚ñº        ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇCLOSED‚îÇ    ‚îÇ OPEN ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 1. √âtat CLOSED (Ferm√© - Normal)

**Comportement** :
- Toutes les requ√™tes passent normalement
- Les √©checs sont comptabilis√©s
- Si le nombre d'√©checs d√©passe un seuil ‚Üí passage √† OPEN

**Exemple** :
```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.state = "CLOSED"
        self.failure_count = 0
        self.failure_threshold = failure_threshold
        self.timeout = timeout

    def call(self, func):
        if self.state == "CLOSED":
            try:
                result = func()
                self.failure_count = 0  # Reset sur succ√®s
                return result
            except Exception as e:
                self.failure_count += 1
                if self.failure_count >= self.failure_threshold:
                    self.state = "OPEN"
                    self.opened_at = time.time()
                    print(f"Circuit breaker OPEN ({self.failure_count} failures)")
                raise
```

### 2. √âtat OPEN (Ouvert - Bloqu√©)

**Comportement** :
- **Toutes les requ√™tes √©chouent imm√©diatement** sans appel r√©seau
- Aucune charge envoy√©e au service d√©faillant
- Apr√®s un timeout, passage √† HALF-OPEN pour tester la r√©cup√©ration

**Avantages** :
- Fail-fast : erreur imm√©diate au lieu d'attendre le timeout
- Lib√©ration des ressources (threads, connexions)
- Protection du service en panne

```python
def call(self, func):
    if self.state == "OPEN":
        # V√©rifier si on peut tester la r√©cup√©ration
        if time.time() - self.opened_at > self.timeout:
            self.state = "HALF_OPEN"
            print("Circuit breaker HALF_OPEN (testing recovery)")
        else:
            # √âchec imm√©diat sans appel r√©seau
            raise CircuitBreakerOpenError("Circuit breaker is OPEN")
```

### 3. √âtat HALF-OPEN (Semi-ouvert - Test)

**Comportement** :
- Laisse passer **un nombre limit√© de requ√™tes** (g√©n√©ralement 1)
- Si succ√®s ‚Üí retour √† CLOSED
- Si √©chec ‚Üí retour √† OPEN

**Pourquoi cet √©tat est crucial** :
- √âvite de rouvrir le circuit trop rapidement
- Teste prudemment la r√©cup√©ration
- √âvite d'envoyer tout le trafic sur un service qui vient de red√©marrer

```python
def call(self, func):
    if self.state == "HALF_OPEN":
        try:
            result = func()
            # Succ√®s : r√©cup√©ration confirm√©e
            self.state = "CLOSED"
            self.failure_count = 0
            print("Circuit breaker CLOSED (recovery successful)")
            return result
        except Exception as e:
            # √âchec : retour √† OPEN
            self.state = "OPEN"
            self.opened_at = time.time()
            print("Circuit breaker OPEN (recovery failed)")
            raise
```

---

## Impl√©mentation compl√®te

### Python : Circuit Breaker production-ready

```python
import time
import threading
from enum import Enum
from functools import wraps

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreakerOpenError(Exception):
    """Exception lev√©e quand le circuit est ouvert."""
    pass

class CircuitBreaker:
    """
    Circuit breaker thread-safe avec fen√™tre glissante.

    Args:
        failure_threshold: Nombre d'√©checs avant ouverture
        recovery_timeout: Temps en secondes avant test de r√©cup√©ration
        expected_exception: Type d'exception consid√©r√©e comme √©chec
        success_threshold: Nombre de succ√®s requis en HALF_OPEN
        window_size: Taille de la fen√™tre de comptage (secondes)
    """

    def __init__(
        self,
        failure_threshold=5,
        recovery_timeout=60,
        expected_exception=Exception,
        success_threshold=1,
        window_size=60
    ):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.expected_exception = expected_exception
        self.success_threshold = success_threshold
        self.window_size = window_size

        self.state = CircuitState.CLOSED
        self.opened_at = None
        self.half_open_successes = 0

        # Fen√™tre glissante des √©checs
        self.failures = []  # Liste de timestamps

        # Thread safety
        self.lock = threading.RLock()

        # M√©triques
        self.total_calls = 0
        self.total_failures = 0
        self.total_successes = 0

    def _clean_old_failures(self):
        """Nettoie les √©checs hors de la fen√™tre."""
        now = time.time()
        cutoff = now - self.window_size
        self.failures = [f for f in self.failures if f > cutoff]

    def _record_success(self):
        """Enregistre un succ√®s."""
        with self.lock:
            self.total_successes += 1

            if self.state == CircuitState.HALF_OPEN:
                self.half_open_successes += 1

                if self.half_open_successes >= self.success_threshold:
                    self._transition_to_closed()

    def _record_failure(self):
        """Enregistre un √©chec."""
        with self.lock:
            self.total_failures += 1
            now = time.time()
            self.failures.append(now)
            self._clean_old_failures()

            if self.state == CircuitState.CLOSED:
                if len(self.failures) >= self.failure_threshold:
                    self._transition_to_open()

            elif self.state == CircuitState.HALF_OPEN:
                self._transition_to_open()

    def _transition_to_open(self):
        """Transition vers l'√©tat OPEN."""
        self.state = CircuitState.OPEN
        self.opened_at = time.time()
        print(f"‚ö†Ô∏è  Circuit breaker OPEN ({len(self.failures)} failures)")

    def _transition_to_half_open(self):
        """Transition vers l'√©tat HALF_OPEN."""
        self.state = CircuitState.HALF_OPEN
        self.half_open_successes = 0
        print("üîÑ Circuit breaker HALF_OPEN (testing recovery)")

    def _transition_to_closed(self):
        """Transition vers l'√©tat CLOSED."""
        self.state = CircuitState.CLOSED
        self.failures = []
        self.half_open_successes = 0
        print("‚úÖ Circuit breaker CLOSED (recovered)")

    def call(self, func, *args, **kwargs):
        """
        Ex√©cute une fonction √† travers le circuit breaker.

        Raises:
            CircuitBreakerOpenError: Si le circuit est ouvert
        """
        with self.lock:
            self.total_calls += 1

            # √âtat OPEN : v√©rifier si on peut tester la r√©cup√©ration
            if self.state == CircuitState.OPEN:
                if time.time() - self.opened_at >= self.recovery_timeout:
                    self._transition_to_half_open()
                else:
                    raise CircuitBreakerOpenError(
                        f"Circuit breaker is OPEN. "
                        f"Retry in {self.recovery_timeout - (time.time() - self.opened_at):.0f}s"
                    )

        # Ex√©cuter la fonction
        try:
            result = func(*args, **kwargs)
            self._record_success()
            return result

        except self.expected_exception as e:
            self._record_failure()
            raise

    def __call__(self, func):
        """Permet d'utiliser comme d√©corateur."""
        @wraps(func)
        def wrapper(*args, **kwargs):
            return self.call(func, *args, **kwargs)
        return wrapper

    def get_state(self):
        """Retourne l'√©tat actuel et les statistiques."""
        with self.lock:
            return {
                'state': self.state.value,
                'total_calls': self.total_calls,
                'total_successes': self.total_successes,
                'total_failures': self.total_failures,
                'recent_failures': len(self.failures),
                'failure_threshold': self.failure_threshold,
                'opened_at': self.opened_at
            }

# Utilisation
breaker = CircuitBreaker(
    failure_threshold=5,
    recovery_timeout=30,
    expected_exception=requests.RequestException
)

@breaker
def call_external_api():
    response = requests.get('https://api.example.com/data', timeout=5)
    response.raise_for_status()
    return response.json()

# Ou sans d√©corateur
def fetch_user(user_id):
    def _fetch():
        response = requests.get(f'/users/{user_id}', timeout=5)
        response.raise_for_status()
        return response.json()

    return breaker.call(_fetch)
```

### Go : Implementation robuste

```go
package circuitbreaker

import (
    "errors"
    "fmt"
    "sync"
    "time"
)

// State repr√©sente l'√©tat du circuit breaker
type State int

const (
    StateClosed State = iota
    StateOpen
    StateHalfOpen
)

func (s State) String() string {
    switch s {
    case StateClosed:
        return "CLOSED"
    case StateOpen:
        return "OPEN"
    case StateHalfOpen:
        return "HALF_OPEN"
    default:
        return "UNKNOWN"
    }
}

// ErrCircuitBreakerOpen est retourn√©e quand le circuit est ouvert
var ErrCircuitBreakerOpen = errors.New("circuit breaker is open")

// Config configure le circuit breaker
type Config struct {
    FailureThreshold  int           // Nombre d'√©checs avant ouverture
    SuccessThreshold  int           // Succ√®s requis en HALF_OPEN
    RecoveryTimeout   time.Duration // D√©lai avant test de r√©cup√©ration
    WindowSize        time.Duration // Taille de la fen√™tre glissante
    OnStateChange     func(from, to State) // Callback sur changement d'√©tat
}

// CircuitBreaker impl√©mente le pattern
type CircuitBreaker struct {
    config Config

    mu               sync.RWMutex
    state            State
    openedAt         time.Time
    halfOpenSuccesses int

    // Fen√™tre glissante
    failures []time.Time

    // M√©triques
    totalCalls     uint64
    totalSuccesses uint64
    totalFailures  uint64
}

// New cr√©e un nouveau circuit breaker
func New(config Config) *CircuitBreaker {
    // Valeurs par d√©faut
    if config.FailureThreshold == 0 {
        config.FailureThreshold = 5
    }
    if config.SuccessThreshold == 0 {
        config.SuccessThreshold = 1
    }
    if config.RecoveryTimeout == 0 {
        config.RecoveryTimeout = 60 * time.Second
    }
    if config.WindowSize == 0 {
        config.WindowSize = 60 * time.Second
    }

    return &CircuitBreaker{
        config:   config,
        state:    StateClosed,
        failures: make([]time.Time, 0),
    }
}

// cleanOldFailures nettoie les √©checs hors fen√™tre
func (cb *CircuitBreaker) cleanOldFailures() {
    cutoff := time.Now().Add(-cb.config.WindowSize)
    validFailures := make([]time.Time, 0)

    for _, f := range cb.failures {
        if f.After(cutoff) {
            validFailures = append(validFailures, f)
        }
    }

    cb.failures = validFailures
}

// recordSuccess enregistre un succ√®s
func (cb *CircuitBreaker) recordSuccess() {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    cb.totalSuccesses++

    if cb.state == StateHalfOpen {
        cb.halfOpenSuccesses++

        if cb.halfOpenSuccesses >= cb.config.SuccessThreshold {
            cb.transitionTo(StateClosed)
        }
    }
}

// recordFailure enregistre un √©chec
func (cb *CircuitBreaker) recordFailure() {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    cb.totalFailures++
    cb.failures = append(cb.failures, time.Now())
    cb.cleanOldFailures()

    if cb.state == StateClosed {
        if len(cb.failures) >= cb.config.FailureThreshold {
            cb.transitionTo(StateOpen)
        }
    } else if cb.state == StateHalfOpen {
        cb.transitionTo(StateOpen)
    }
}

// transitionTo change l'√©tat du circuit
func (cb *CircuitBreaker) transitionTo(newState State) {
    if cb.state == newState {
        return
    }

    oldState := cb.state
    cb.state = newState

    switch newState {
    case StateOpen:
        cb.openedAt = time.Now()
        fmt.Printf("‚ö†Ô∏è  Circuit breaker: %s ‚Üí %s (%d failures)\n",
            oldState, newState, len(cb.failures))
    case StateHalfOpen:
        cb.halfOpenSuccesses = 0
        fmt.Printf("üîÑ Circuit breaker: %s ‚Üí %s (testing recovery)\n",
            oldState, newState)
    case StateClosed:
        cb.failures = make([]time.Time, 0)
        cb.halfOpenSuccesses = 0
        fmt.Printf("‚úÖ Circuit breaker: %s ‚Üí %s (recovered)\n",
            oldState, newState)
    }

    if cb.config.OnStateChange != nil {
        cb.config.OnStateChange(oldState, newState)
    }
}

// Call ex√©cute une fonction √† travers le circuit breaker
func (cb *CircuitBreaker) Call(fn func() error) error {
    // V√©rifier l'√©tat
    cb.mu.Lock()
    cb.totalCalls++

    if cb.state == StateOpen {
        // V√©rifier si on peut passer √† HALF_OPEN
        if time.Since(cb.openedAt) >= cb.config.RecoveryTimeout {
            cb.transitionTo(StateHalfOpen)
        } else {
            cb.mu.Unlock()
            return ErrCircuitBreakerOpen
        }
    }
    cb.mu.Unlock()

    // Ex√©cuter la fonction
    err := fn()

    if err != nil {
        cb.recordFailure()
        return err
    }

    cb.recordSuccess()
    return nil
}

// State retourne l'√©tat actuel
func (cb *CircuitBreaker) State() State {
    cb.mu.RLock()
    defer cb.mu.RUnlock()
    return cb.state
}

// Stats retourne les statistiques
func (cb *CircuitBreaker) Stats() map[string]interface{} {
    cb.mu.RLock()
    defer cb.mu.RUnlock()

    return map[string]interface{}{
        "state":            cb.state.String(),
        "total_calls":      cb.totalCalls,
        "total_successes":  cb.totalSuccesses,
        "total_failures":   cb.totalFailures,
        "recent_failures":  len(cb.failures),
        "failure_threshold": cb.config.FailureThreshold,
    }
}

// Exemple d'utilisation
func Example() {
    breaker := New(Config{
        FailureThreshold: 5,
        RecoveryTimeout:  30 * time.Second,
        OnStateChange: func(from, to State) {
            fmt.Printf("State changed: %s ‚Üí %s\n", from, to)
        },
    })

    err := breaker.Call(func() error {
        resp, err := http.Get("https://api.example.com/data")
        if err != nil {
            return err
        }
        defer resp.Body.Close()

        if resp.StatusCode >= 500 {
            return fmt.Errorf("server error: %d", resp.StatusCode)
        }

        return nil
    })

    if err == ErrCircuitBreakerOpen {
        fmt.Println("Circuit breaker is open, using fallback")
        // Utiliser un fallback
    }
}
```

### JavaScript (Node.js) : Version moderne

```javascript
const EventEmitter = require('events');

/**
 * √âtats du circuit breaker
 */
const State = {
    CLOSED: 'CLOSED',
    OPEN: 'OPEN',
    HALF_OPEN: 'HALF_OPEN'
};

/**
 * Erreur lev√©e quand le circuit est ouvert
 */
class CircuitBreakerOpenError extends Error {
    constructor(message) {
        super(message);
        this.name = 'CircuitBreakerOpenError';
    }
}

/**
 * Circuit Breaker avec fen√™tre glissante
 */
class CircuitBreaker extends EventEmitter {
    constructor(options = {}) {
        super();

        this.failureThreshold = options.failureThreshold || 5;
        this.successThreshold = options.successThreshold || 1;
        this.recoveryTimeout = options.recoveryTimeout || 60000; // ms
        this.windowSize = options.windowSize || 60000; // ms

        this.state = State.CLOSED;
        this.openedAt = null;
        this.halfOpenSuccesses = 0;

        // Fen√™tre glissante
        this.failures = [];

        // M√©triques
        this.totalCalls = 0;
        this.totalSuccesses = 0;
        this.totalFailures = 0;
    }

    /**
     * Nettoie les √©checs hors de la fen√™tre
     */
    _cleanOldFailures() {
        const now = Date.now();
        const cutoff = now - this.windowSize;
        this.failures = this.failures.filter(f => f > cutoff);
    }

    /**
     * Enregistre un succ√®s
     */
    _recordSuccess() {
        this.totalSuccesses++;

        if (this.state === State.HALF_OPEN) {
            this.halfOpenSuccesses++;

            if (this.halfOpenSuccesses >= this.successThreshold) {
                this._transitionTo(State.CLOSED);
            }
        }
    }

    /**
     * Enregistre un √©chec
     */
    _recordFailure() {
        this.totalFailures++;
        this.failures.push(Date.now());
        this._cleanOldFailures();

        if (this.state === State.CLOSED) {
            if (this.failures.length >= this.failureThreshold) {
                this._transitionTo(State.OPEN);
            }
        } else if (this.state === State.HALF_OPEN) {
            this._transitionTo(State.OPEN);
        }
    }

    /**
     * Transition vers un nouvel √©tat
     */
    _transitionTo(newState) {
        if (this.state === newState) return;

        const oldState = this.state;
        this.state = newState;

        switch (newState) {
            case State.OPEN:
                this.openedAt = Date.now();
                console.log(`‚ö†Ô∏è  Circuit breaker: ${oldState} ‚Üí ${newState} (${this.failures.length} failures)`);
                break;

            case State.HALF_OPEN:
                this.halfOpenSuccesses = 0;
                console.log(`üîÑ Circuit breaker: ${oldState} ‚Üí ${newState} (testing recovery)`);
                break;

            case State.CLOSED:
                this.failures = [];
                this.halfOpenSuccesses = 0;
                console.log(`‚úÖ Circuit breaker: ${oldState} ‚Üí ${newState} (recovered)`);
                break;
        }

        this.emit('stateChange', { from: oldState, to: newState });
    }

    /**
     * Ex√©cute une fonction √† travers le circuit breaker
     */
    async execute(fn) {
        this.totalCalls++;

        // V√©rifier l'√©tat
        if (this.state === State.OPEN) {
            const now = Date.now();

            if (now - this.openedAt >= this.recoveryTimeout) {
                this._transitionTo(State.HALF_OPEN);
            } else {
                const retryIn = Math.ceil((this.recoveryTimeout - (now - this.openedAt)) / 1000);
                throw new CircuitBreakerOpenError(
                    `Circuit breaker is OPEN. Retry in ${retryIn}s`
                );
            }
        }

        // Ex√©cuter la fonction
        try {
            const result = await fn();
            this._recordSuccess();
            return result;
        } catch (error) {
            this._recordFailure();
            throw error;
        }
    }

    /**
     * Retourne l'√©tat actuel
     */
    getState() {
        return this.state;
    }

    /**
     * Retourne les statistiques
     */
    getStats() {
        return {
            state: this.state,
            totalCalls: this.totalCalls,
            totalSuccesses: this.totalSuccesses,
            totalFailures: this.totalFailures,
            recentFailures: this.failures.length,
            failureThreshold: this.failureThreshold,
            openedAt: this.openedAt
        };
    }

    /**
     * Reset le circuit breaker
     */
    reset() {
        this.state = State.CLOSED;
        this.failures = [];
        this.halfOpenSuccesses = 0;
        this.openedAt = null;
    }
}

// Exemple d'utilisation avec axios
const axios = require('axios');

const breaker = new CircuitBreaker({
    failureThreshold: 5,
    recoveryTimeout: 30000,
    successThreshold: 2
});

// Listener sur changements d'√©tat
breaker.on('stateChange', ({ from, to }) => {
    console.log(`Circuit breaker state: ${from} ‚Üí ${to}`);
    // Envoyer une alerte, logger, etc.
});

async function callAPI(endpoint) {
    return breaker.execute(async () => {
        const response = await axios.get(endpoint, {
            timeout: 5000
        });
        return response.data;
    });
}

// Utilisation
async function main() {
    try {
        const data = await callAPI('https://api.example.com/data');
        console.log('Success:', data);
    } catch (error) {
        if (error instanceof CircuitBreakerOpenError) {
            console.log('Circuit is open, using fallback');
            // Utiliser des donn√©es en cache
        } else {
            console.error('Request failed:', error.message);
        }
    }
}

module.exports = { CircuitBreaker, CircuitBreakerOpenError, State };
```

### Java : Avec Resilience4j (biblioth√®que production)

```java
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.vavr.control.Try;

import java.time.Duration;
import java.util.function.Supplier;

public class CircuitBreakerExample {

    public static void main(String[] args) {
        // Configuration du circuit breaker
        CircuitBreakerConfig config = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)                    // 50% d'√©checs
            .slowCallRateThreshold(50)                   // 50% de slow calls
            .slowCallDurationThreshold(Duration.ofSeconds(2))
            .waitDurationInOpenState(Duration.ofSeconds(30))
            .slidingWindowType(CircuitBreakerConfig.SlidingWindowType.COUNT_BASED)
            .slidingWindowSize(10)                       // Fen√™tre de 10 appels
            .minimumNumberOfCalls(5)                     // Minimum 5 appels avant d√©cision
            .permittedNumberOfCallsInHalfOpenState(3)    // 3 tests en HALF_OPEN
            .automaticTransitionFromOpenToHalfOpenEnabled(true)
            .recordExceptions(IOException.class, TimeoutException.class)
            .ignoreExceptions(IllegalArgumentException.class)
            .build();

        // Cr√©er le circuit breaker
        CircuitBreakerRegistry registry = CircuitBreakerRegistry.of(config);
        CircuitBreaker circuitBreaker = registry.circuitBreaker("apiService");

        // Listener sur √©v√©nements
        circuitBreaker.getEventPublisher()
            .onStateTransition(event ->
                System.out.println("State transition: " + event))
            .onFailureRateExceeded(event ->
                System.out.println("Failure rate exceeded: " + event.getFailureRate()))
            .onCallNotPermitted(event ->
                System.out.println("Call not permitted: circuit is OPEN"));

        // Wrapper de fonction
        Supplier<String> decoratedSupplier = CircuitBreaker
            .decorateSupplier(circuitBreaker, () -> callExternalAPI());

        // Ex√©cution avec gestion des erreurs
        Try<String> result = Try.ofSupplier(decoratedSupplier)
            .recover(CallNotPermittedException.class, throwable -> {
                System.out.println("Circuit breaker is OPEN, using fallback");
                return getCachedData();
            })
            .recover(Exception.class, throwable -> {
                System.out.println("Request failed: " + throwable.getMessage());
                return getDefaultData();
            });

        result.onSuccess(data -> System.out.println("Success: " + data))
              .onFailure(error -> System.err.println("Error: " + error));
    }

    private static String callExternalAPI() throws IOException {
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://api.example.com/data"))
            .timeout(Duration.ofSeconds(5))
            .build();

        HttpResponse<String> response = client.send(
            request,
            HttpResponse.BodyHandlers.ofString()
        );

        if (response.statusCode() >= 500) {
            throw new IOException("Server error: " + response.statusCode());
        }

        return response.body();
    }

    private static String getCachedData() {
        return "{ \"source\": \"cache\", \"data\": \"...\" }";
    }

    private static String getDefaultData() {
        return "{ \"source\": \"default\", \"data\": \"...\" }";
    }
}
```

---

## Strat√©gies de d√©tection de d√©faillance

### 1. Seuil de comptage (Count-based)

**Principe** : Ouvrir apr√®s N √©checs cons√©cutifs ou dans une fen√™tre.

```python
class CountBasedCircuitBreaker:
    def __init__(self, threshold=5, window_size=10):
        self.threshold = threshold  # Nombre d'√©checs max
        self.window_size = window_size  # Taille de la fen√™tre
        self.calls = []  # (timestamp, success)

    def should_open(self):
        # Garder seulement les N derniers appels
        self.calls = self.calls[-self.window_size:]

        # Compter les √©checs
        failures = sum(1 for _, success in self.calls if not success)

        return failures >= self.threshold
```

**Avantages** :
- Simple √† impl√©menter
- Facile √† raisonner

**Inconv√©nients** :
- Peut √™tre trop sensible au d√©but (peu de donn√©es)
- Ne prend pas en compte le taux d'erreur

### 2. Seuil de taux (Rate-based)

**Principe** : Ouvrir quand le taux d'erreur d√©passe un pourcentage.

```python
class RateBasedCircuitBreaker:
    def __init__(self, failure_rate_threshold=0.5, min_calls=10):
        self.failure_rate_threshold = failure_rate_threshold  # 50%
        self.min_calls = min_calls  # Minimum d'appels requis
        self.successes = 0
        self.failures = 0

    def should_open(self):
        total = self.successes + self.failures

        # Pas assez de donn√©es
        if total < self.min_calls:
            return False

        failure_rate = self.failures / total
        return failure_rate >= self.failure_rate_threshold
```

**Avantages** :
- Plus robuste statistiquement
- S'adapte au volume

**Inconv√©nients** :
- Requiert un minimum d'appels
- Plus complexe

### 3. Fen√™tre glissante temporelle (Time-based sliding window)

**Principe** : Compter les √©checs dans une fen√™tre temporelle (ex: derni√®res 60 secondes).

```go
type TimeBasedCircuitBreaker struct {
    failureThreshold int
    windowSize       time.Duration
    failures         []time.Time
    mu               sync.RWMutex
}

func (cb *TimeBasedCircuitBreaker) shouldOpen() bool {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    // Nettoyer les √©checs hors fen√™tre
    now := time.Now()
    cutoff := now.Add(-cb.windowSize)

    validFailures := make([]time.Time, 0)
    for _, f := range cb.failures {
        if f.After(cutoff) {
            validFailures = append(validFailures, f)
        }
    }
    cb.failures = validFailures

    return len(cb.failures) >= cb.failureThreshold
}

func (cb *TimeBasedCircuitBreaker) recordFailure() {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    cb.failures = append(cb.failures, time.Now())
}
```

**Avantages** :
- R√©agit aux pics r√©cents
- Plus adapt√© aux syst√®mes √† charge variable

**Inconv√©nients** :
- Utilisation m√©moire proportionnelle aux √©checs
- Complexit√© temporelle du nettoyage

### 4. Approche hybride (Recommand√©e)

**Combiner taux ET comptage avec fen√™tre glissante** :

```python
class HybridCircuitBreaker:
    """
    Circuit breaker utilisant une fen√™tre glissante avec seuils
    de taux ET de comptage.
    """
    def __init__(
        self,
        failure_count_threshold=10,
        failure_rate_threshold=0.5,
        min_calls=20,
        window_size=60
    ):
        self.failure_count_threshold = failure_count_threshold
        self.failure_rate_threshold = failure_rate_threshold
        self.min_calls = min_calls
        self.window_size = window_size

        # Fen√™tre glissante : (timestamp, was_success)
        self.calls = []

    def record_call(self, success):
        now = time.time()
        self.calls.append((now, success))
        self._clean_old_calls()

    def _clean_old_calls(self):
        cutoff = time.time() - self.window_size
        self.calls = [(t, s) for t, s in self.calls if t > cutoff]

    def should_open(self):
        if len(self.calls) < self.min_calls:
            return False

        successes = sum(1 for _, success in self.calls if success)
        failures = len(self.calls) - successes
        failure_rate = failures / len(self.calls)

        # Ouvrir si SOIT le taux SOIT le comptage d√©passe
        return (
            failures >= self.failure_count_threshold or
            failure_rate >= self.failure_rate_threshold
        )
```

---

## Patterns avanc√©s

### 1. Circuit Breaker par endpoint

**Probl√®me** : Un endpoint lent ne devrait pas bloquer tous les autres.

```python
class MultiCircuitBreaker:
    """G√®re plusieurs circuit breakers, un par endpoint."""

    def __init__(self, default_config=None):
        self.default_config = default_config or {}
        self.breakers = {}
        self.lock = threading.Lock()

    def get_breaker(self, key):
        """R√©cup√®re ou cr√©e un circuit breaker pour une cl√©."""
        if key not in self.breakers:
            with self.lock:
                if key not in self.breakers:
                    self.breakers[key] = CircuitBreaker(**self.default_config)
        return self.breakers[key]

    def call(self, key, func, *args, **kwargs):
        """Ex√©cute une fonction avec le circuit breaker appropri√©."""
        breaker = self.get_breaker(key)
        return breaker.call(func, *args, **kwargs)

# Utilisation
multi_breaker = MultiCircuitBreaker(
    default_config={
        'failure_threshold': 5,
        'recovery_timeout': 30
    }
)

# Chaque endpoint a son propre circuit breaker
def fetch_users():
    return multi_breaker.call(
        'users-api',
        lambda: requests.get('/users').json()
    )

def fetch_orders():
    return multi_breaker.call(
        'orders-api',
        lambda: requests.get('/orders').json()
    )

# Si 'orders-api' √©choue, 'users-api' reste op√©rationnel
```

### 2. Circuit Breaker avec fallback

**Combiner circuit breaker et fallback pour d√©gradation gracieuse** :

```javascript
class CircuitBreakerWithFallback {
    constructor(breaker, fallback) {
        this.breaker = breaker;
        this.fallback = fallback;
    }

    async execute(fn) {
        try {
            return await this.breaker.execute(fn);
        } catch (error) {
            if (error instanceof CircuitBreakerOpenError) {
                console.log('Circuit open, using fallback');
                return await this.fallback();
            }
            throw error;
        }
    }
}

// Utilisation
const breaker = new CircuitBreaker({ failureThreshold: 5 });

const resilientFetch = new CircuitBreakerWithFallback(
    breaker,
    async () => {
        // Fallback : donn√©es en cache
        return cache.get('users') || { users: [], source: 'empty' };
    }
);

async function getUsers() {
    return resilientFetch.execute(async () => {
        const response = await fetch('/api/users');
        if (!response.ok) throw new Error('API error');
        const data = await response.json();

        // Mettre en cache pour futurs fallbacks
        cache.set('users', data);

        return data;
    });
}
```

### 3. Adaptive Circuit Breaker

**Ajuster dynamiquement les seuils selon les conditions** :

```go
type AdaptiveCircuitBreaker struct {
    *CircuitBreaker
    baseThreshold     int
    currentThreshold  int
    successRate       float64
    adaptationFactor  float64
}

func NewAdaptiveCircuitBreaker() *AdaptiveCircuitBreaker {
    baseThreshold := 5

    return &AdaptiveCircuitBreaker{
        CircuitBreaker:   New(Config{FailureThreshold: baseThreshold}),
        baseThreshold:    baseThreshold,
        currentThreshold: baseThreshold,
        adaptationFactor: 0.1,
    }
}

func (acb *AdaptiveCircuitBreaker) adapt() {
    stats := acb.Stats()
    total := stats["total_calls"].(uint64)
    successes := stats["total_successes"].(uint64)

    if total == 0 {
        return
    }

    // Calculer le taux de succ√®s
    acb.successRate = float64(successes) / float64(total)

    // Ajuster le seuil
    if acb.successRate > 0.95 {
        // Haute fiabilit√© : augmenter la tol√©rance
        acb.currentThreshold = int(float64(acb.baseThreshold) * 1.5)
    } else if acb.successRate < 0.7 {
        // Faible fiabilit√© : r√©duire la tol√©rance
        acb.currentThreshold = int(float64(acb.baseThreshold) * 0.7)
    } else {
        // Revenir √† la normale
        acb.currentThreshold = acb.baseThreshold
    }

    // Mettre √† jour la configuration
    acb.config.FailureThreshold = acb.currentThreshold
}

// Appeler adapt() p√©riodiquement (ex: toutes les 10 secondes)
```

### 4. Circuit Breaker hi√©rarchique

**Pour les architectures microservices complexes** :

```python
class HierarchicalCircuitBreaker:
    """
    Circuit breaker hi√©rarchique :
    - Si un service leaf √©choue ‚Üí circuit breaker local
    - Si plusieurs services √©chouent ‚Üí circuit breaker parent
    """

    def __init__(self, name, parent=None, config=None):
        self.name = name
        self.parent = parent
        self.breaker = CircuitBreaker(**(config or {}))
        self.children = {}

    def add_child(self, name, config=None):
        """Ajoute un circuit breaker enfant."""
        child = HierarchicalCircuitBreaker(name, parent=self, config=config)
        self.children[name] = child
        return child

    def call(self, func, *args, **kwargs):
        """Ex√©cute en v√©rifiant parent puis local."""
        # V√©rifier le parent d'abord
        if self.parent and self.parent.breaker.state == CircuitState.OPEN:
            raise CircuitBreakerOpenError(f"Parent circuit {self.parent.name} is OPEN")

        # Puis le circuit local
        return self.breaker.call(func, *args, **kwargs)

# Utilisation
root = HierarchicalCircuitBreaker("backend")

# Services
user_service = root.add_child("user-service", config={'failure_threshold': 5})
order_service = root.add_child("order-service", config={'failure_threshold': 3})

# Si root s'ouvre, tous les enfants sont bloqu√©s
# Mais un enfant peut s'ouvrir ind√©pendamment
```

---

## Combinaison avec d'autres patterns

### Circuit Breaker + Retry + Timeout

**La trinit√© de la r√©silience** :

```python
class ResilientClient:
    """
    Client combinant timeout, retry et circuit breaker.
    """

    def __init__(self):
        self.breaker = CircuitBreaker(
            failure_threshold=5,
            recovery_timeout=30
        )

    def call_with_resilience(
        self,
        func,
        max_retries=3,
        timeout=5.0
    ):
        """
        Ex√©cute une fonction avec la pile de r√©silience compl√®te.

        Ordre d'ex√©cution :
        1. Circuit breaker v√©rifie l'√©tat
        2. Timeout limite le temps d'ex√©cution
        3. Retry en cas d'√©chec (si circuit ferm√©)
        """
        for attempt in range(1, max_retries + 1):
            try:
                # Circuit breaker
                return self.breaker.call(
                    # Timeout
                    lambda: self._with_timeout(func, timeout)
                )

            except CircuitBreakerOpenError:
                # Circuit ouvert : pas de retry
                raise

            except Exception as e:
                # Derni√®re tentative
                if attempt == max_retries:
                    raise

                # Retry avec backoff
                delay = 2 ** (attempt - 1) * random.random()
                print(f"Attempt {attempt} failed, retrying in {delay:.2f}s...")
                time.sleep(delay)

    def _with_timeout(self, func, timeout):
        """Ex√©cute une fonction avec timeout."""
        # Utiliser signal ou threading.Timer selon le contexte
        import signal

        def timeout_handler(signum, frame):
            raise TimeoutError("Operation timed out")

        signal.signal(signal.SIGALRM, timeout_handler)
        signal.alarm(int(timeout))

        try:
            return func()
        finally:
            signal.alarm(0)

# Utilisation
client = ResilientClient()

def fetch_data():
    response = requests.get('https://api.example.com/data')
    response.raise_for_status()
    return response.json()

try:
    data = client.call_with_resilience(
        fetch_data,
        max_retries=3,
        timeout=5.0
    )
except Exception as e:
    print(f"All resilience mechanisms exhausted: {e}")
```

### Circuit Breaker + Bulkhead (Isolation)

**Isoler les ressources par circuit breaker** :

```go
type BulkheadCircuitBreaker struct {
    breaker  *CircuitBreaker
    semaphore chan struct{}
}

func NewBulkheadCircuitBreaker(maxConcurrent int, config Config) *BulkheadCircuitBreaker {
    return &BulkheadCircuitBreaker{
        breaker:   New(config),
        semaphore: make(chan struct{}, maxConcurrent),
    }
}

func (bcb *BulkheadCircuitBreaker) Call(fn func() error) error {
    // Acqu√©rir un slot (bulkhead)
    select {
    case bcb.semaphore <- struct{}{}:
        defer func() { <-bcb.semaphore }()
    default:
        return errors.New("bulkhead full: too many concurrent requests")
    }

    // Ex√©cuter √† travers le circuit breaker
    return bcb.breaker.Call(fn)
}

// Utilisation : limiter √† 10 requ√™tes concurrentes
bulkhead := NewBulkheadCircuitBreaker(10, Config{
    FailureThreshold: 5,
    RecoveryTimeout:  30 * time.Second,
})
```

---

## Monitoring et observabilit√©

### M√©triques essentielles

```python
from prometheus_client import Counter, Gauge, Histogram

# √âtat du circuit breaker
circuit_breaker_state = Gauge(
    'circuit_breaker_state',
    'Current state of circuit breaker (0=CLOSED, 1=OPEN, 2=HALF_OPEN)',
    ['service']
)

# Transitions d'√©tat
circuit_breaker_transitions = Counter(
    'circuit_breaker_state_transitions_total',
    'Total number of state transitions',
    ['service', 'from_state', 'to_state']
)

# Appels bloqu√©s
circuit_breaker_calls_blocked = Counter(
    'circuit_breaker_calls_blocked_total',
    'Calls blocked by open circuit breaker',
    ['service']
)

# Temps pass√© dans chaque √©tat
circuit_breaker_time_in_state = Histogram(
    'circuit_breaker_time_in_state_seconds',
    'Time spent in each state',
    ['service', 'state']
)

class InstrumentedCircuitBreaker(CircuitBreaker):
    """Circuit breaker avec instrumentation Prometheus."""

    def __init__(self, service_name, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.service_name = service_name
        self.state_entered_at = time.time()

        # Enregistrer le callback de transition
        original_transition = self._transition_to

        def instrumented_transition(new_state):
            # Enregistrer le temps dans l'√©tat pr√©c√©dent
            duration = time.time() - self.state_entered_at
            circuit_breaker_time_in_state.labels(
                service=self.service_name,
                state=self.state.value
            ).observe(duration)

            # Enregistrer la transition
            circuit_breaker_transitions.labels(
                service=self.service_name,
                from_state=self.state.value,
                to_state=new_state.value
            ).inc()

            # Effectuer la transition
            original_transition(new_state)

            # Mettre √† jour la gauge d'√©tat
            state_value = {
                CircuitState.CLOSED: 0,
                CircuitState.OPEN: 1,
                CircuitState.HALF_OPEN: 2
            }[new_state]
            circuit_breaker_state.labels(service=self.service_name).set(state_value)

            self.state_entered_at = time.time()

        self._transition_to = instrumented_transition

    def call(self, func, *args, **kwargs):
        try:
            return super().call(func, *args, **kwargs)
        except CircuitBreakerOpenError:
            circuit_breaker_calls_blocked.labels(
                service=self.service_name
            ).inc()
            raise
```

### Dashboard Grafana

**Requ√™tes PromQL utiles** :

```promql
# √âtat actuel des circuit breakers
circuit_breaker_state{service="user-service"}

# Taux de transitions (instabilit√© du syst√®me)
rate(circuit_breaker_state_transitions_total[5m])

# Pourcentage d'appels bloqu√©s
(
  rate(circuit_breaker_calls_blocked_total[5m])
  /
  rate(http_requests_total[5m])
) * 100

# Temps moyen en √©tat OPEN
avg(circuit_breaker_time_in_state_seconds{state="OPEN"})

# Services avec circuit ouvert
count by (service) (circuit_breaker_state == 1)
```

### Alertes critiques

```yaml
groups:
  - name: circuit_breaker_alerts
    rules:
      # Circuit breaker ouvert
      - alert: CircuitBreakerOpen
        expr: circuit_breaker_state == 1
        for: 1m
        labels:
          severity: warning
        annotations:
          summary: "Circuit breaker OPEN for {{ $labels.service }}"
          description: "Service {{ $labels.service }} circuit breaker has been OPEN for 1 minute"

      # Circuit breaker instable (transitions fr√©quentes)
      - alert: CircuitBreakerFlapping
        expr: rate(circuit_breaker_state_transitions_total[5m]) > 0.1
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Circuit breaker flapping for {{ $labels.service }}"
          description: "Service {{ $labels.service }} circuit is transitioning frequently"

      # Taux de blocage √©lev√©
      - alert: HighCircuitBreakerBlockRate
        expr: |
          (rate(circuit_breaker_calls_blocked_total[5m])
          /
          rate(http_requests_total[5m])) > 0.5
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High block rate for {{ $labels.service }}"
          description: "{{ $value | humanizePercentage }} of calls are blocked by circuit breaker"
```

---

## Cas d'usage r√©els

### 1. Netflix Hystrix (pionnier)

**Contexte** : Netflix a popularis√© le pattern circuit breaker avec Hystrix.

```java
// Exemple Hystrix (legacy, mais instructif)
public class UserServiceCommand extends HystrixCommand<User> {

    private final Long userId;

    public UserServiceCommand(Long userId) {
        super(HystrixCommandGroupKey.Factory.asKey("UserService"));
        this.userId = userId;
    }

    @Override
    protected User run() throws Exception {
        // Appel principal
        return userServiceClient.getUser(userId);
    }

    @Override
    protected User getFallback() {
        // Fallback en cas d'√©chec ou circuit ouvert
        return User.createDefault(userId);
    }
}

// Configuration
HystrixCommandProperties.Setter()
    .withCircuitBreakerEnabled(true)
    .withCircuitBreakerRequestVolumeThreshold(20)      // Min 20 requ√™tes
    .withCircuitBreakerErrorThresholdPercentage(50)    // 50% d'erreurs
    .withCircuitBreakerSleepWindowInMilliseconds(5000) // 5s avant test
    .withExecutionTimeoutInMilliseconds(1000);         // Timeout 1s
```

**Le√ßons apprises** :
- Hystrix a sauv√© Netflix de nombreuses pannes
- Mais : overhead significatif (thread pool par commande)
- √âvolution vers des solutions plus l√©g√®res (Resilience4j)

### 2. Resilience4j (moderne)

**Meilleure pratique actuelle pour Java** :

```java
// Configuration moderne
CircuitBreakerConfig config = CircuitBreakerConfig.custom()
    .failureRateThreshold(50)
    .slowCallRateThreshold(50)
    .slowCallDurationThreshold(Duration.ofSeconds(2))
    .waitDurationInOpenState(Duration.ofSeconds(60))
    .slidingWindowSize(100)
    .minimumNumberOfCalls(10)
    .permittedNumberOfCallsInHalfOpenState(10)
    .build();

CircuitBreaker breaker = CircuitBreaker.of("userService", config);

// Utilisation avec Retry
Retry retry = Retry.ofDefaults("userService");

Supplier<User> decoratedSupplier = Decorators
    .ofSupplier(() -> userService.getUser(userId))
    .withCircuitBreaker(breaker)
    .withRetry(retry)
    .withFallback(
        Arrays.asList(CallNotPermittedException.class, Exception.class),
        e -> User.createDefault(userId)
    );

User user = decoratedSupplier.get();
```

### 3. Spring Cloud CircuitBreaker

**Abstraction pour diff√©rentes impl√©mentations** :

```java
@Service
public class UserService {

    @Autowired
    private CircuitBreakerFactory circuitBreakerFactory;

    @Autowired
    private UserClient userClient;

    public User getUser(Long userId) {
        return circuitBreakerFactory
            .create("userService")
            .run(
                () -> userClient.getUser(userId),
                throwable -> User.createDefault(userId)  // Fallback
            );
    }
}

// Configuration
@Configuration
public class CircuitBreakerConfig {

    @Bean
    public Customizer<Resilience4JCircuitBreakerFactory> defaultCustomizer() {
        return factory -> factory.configureDefault(id -> new Resilience4JConfigBuilder(id)
            .circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())
            .timeLimiterConfig(TimeLimiterConfig.custom()
                .timeoutDuration(Duration.ofSeconds(4))
                .build())
            .build());
    }
}
```

### 4. AWS SDK (circuit breaker implicite)

Les SDK AWS impl√©mentent une forme de circuit breaker :

```python
import boto3
from botocore.config import Config

# Configuration avec adaptive retry
config = Config(
    retries={
        'mode': 'adaptive',  # Inclut circuit breaker-like behavior
        'max_attempts': 3
    },
    connect_timeout=5,
    read_timeout=30
)

s3 = boto3.client('s3', config=config)

# Le SDK adapte automatiquement :
# - R√©duit les retries si taux d'erreur √©lev√©
# - Augmente les backoffs
# - Limite les requ√™tes concurrentes
```

### 5. gRPC avec circuit breaker

```go
import (
    "google.golang.org/grpc"
    "github.com/grpc-ecosystem/go-grpc-middleware"
)

// Interceptor circuit breaker pour gRPC
func CircuitBreakerInterceptor(breaker *CircuitBreaker) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        return breaker.Call(func() error {
            return invoker(ctx, method, req, reply, cc, opts...)
        })
    }
}

// Utilisation
conn, err := grpc.Dial(
    "localhost:50051",
    grpc.WithUnaryInterceptor(CircuitBreakerInterceptor(breaker)),
)
```

---

## Configuration optimale

### Param√®tres recommand√©s par type de service

| Type de service | Failure Threshold | Recovery Timeout | Success Threshold | Justification |
|----------------|-------------------|------------------|-------------------|---------------|
| **API REST externe** | 5-10 | 30-60s | 2-3 | Service tiers, r√©cup√©ration lente |
| **Base de donn√©es** | 3-5 | 10-20s | 1-2 | Critique, r√©cup√©ration rapide attendue |
| **Microservice interne** | 10-15 | 15-30s | 3-5 | Haute fr√©quence, tol√©rance moyenne |
| **Cache** | 20-30 | 5-10s | 5-10 | Non-critique, r√©cup√©ration rapide |
| **Service ML/AI** | 3-5 | 60-120s | 1-2 | Lent par nature, timeouts longs |
| **Queue/Message broker** | 5-10 | 20-40s | 2-3 | Buffering, r√©cup√©ration progressive |

### Formules d'estimation

**Recovery Timeout** :
```
recovery_timeout = 2 √ó (deployment_time + startup_time + warmup_time)
```

**Exemple** :
- Deployment: 10s
- Startup: 15s
- Warmup: 5s
- **Recovery timeout = 2 √ó (10 + 15 + 5) = 60s**

**Failure Threshold** :
```
failure_threshold = max(
    5,  # Minimum absolu
    0.1 √ó requests_per_second √ó window_size
)
```

**Exemple** : 100 req/s, fen√™tre de 10s
- `0.1 √ó 100 √ó 10 = 100` √©checs
- Utiliser 100 comme seuil

---

## Anti-patterns √† √©viter

### ‚ùå 1. Circuit breaker trop sensible

```python
# Anti-pattern : ouvre apr√®s 1 seul √©chec
breaker = CircuitBreaker(failure_threshold=1, recovery_timeout=300)

# Cons√©quence : un blip transitoire bloque le service 5 minutes
```

**Solution** : Threshold ‚â• 3-5 pour filtrer le bruit

### ‚ùå 2. Recovery timeout trop court

```python
# Anti-pattern : teste la r√©cup√©ration apr√®s 5 secondes
breaker = CircuitBreaker(failure_threshold=5, recovery_timeout=5)

# Cons√©quence : flapping (ouverture/fermeture rapide)
```

**Solution** : Recovery timeout ‚â• 2√ó temps de d√©ploiement

### ‚ùå 3. Pas de fallback

```python
# Anti-pattern : erreur propag√©e √† l'utilisateur
try:
    return breaker.call(fetch_recommendations)
except CircuitBreakerOpenError:
    raise  # L'utilisateur voit une erreur !
```

**Solution** : Toujours pr√©voir un fallback
```python
try:
    return breaker.call(fetch_recommendations)
except CircuitBreakerOpenError:
    return get_popular_items()  # Recommandations g√©n√©riques
```

### ‚ùå 4. Circuit breaker global pour tous les endpoints

```python
# Anti-pattern : un seul breaker pour tout
global_breaker = CircuitBreaker(failure_threshold=10)

def call_any_api(endpoint):
    return global_breaker.call(lambda: requests.get(endpoint))

# Cons√©quence : /health √©choue ‚Üí tous les endpoints bloqu√©s !
```

**Solution** : Circuit breaker par service ou endpoint

### ‚ùå 5. Ignorer l'√©tat HALF_OPEN

```python
# Anti-pattern : transition directe OPEN ‚Üí CLOSED
if time_since_open > timeout:
    state = "CLOSED"  # Danger : peut saturer le service qui red√©marre
```

**Solution** : Toujours utiliser HALF_OPEN pour tester prudemment

---

## Tests et validation

### Test de comportement

```python
import pytest
import time

def test_circuit_breaker_transitions():
    """Test des transitions d'√©tats."""
    breaker = CircuitBreaker(failure_threshold=3, recovery_timeout=1)

    failing_func = lambda: (_ for _ in ()).throw(Exception("fail"))
    success_func = lambda: "success"

    # √âtat initial : CLOSED
    assert breaker.state == CircuitState.CLOSED

    # 3 √©checs ‚Üí OPEN
    for _ in range(3):
        with pytest.raises(Exception):
            breaker.call(failing_func)

    assert breaker.state == CircuitState.OPEN

    # Pendant OPEN, les appels √©chouent imm√©diatement
    with pytest.raises(CircuitBreakerOpenError):
        breaker.call(success_func)

    # Apr√®s recovery_timeout ‚Üí HALF_OPEN
    time.sleep(1.1)

    # Premier appel en HALF_OPEN
    result = breaker.call(success_func)
    assert result == "success"

    # Succ√®s ‚Üí CLOSED
    assert breaker.state == CircuitState.CLOSED

def test_circuit_breaker_fallback():
    """Test avec fallback."""
    breaker = CircuitBreaker(failure_threshold=2)

    def fetch_with_fallback():
        try:
            return breaker.call(lambda: (_ for _ in ()).throw(Exception()))
        except (Exception, CircuitBreakerOpenError):
            return "fallback"

    # Premier √©chec
    assert fetch_with_fallback() == "fallback"

    # Deuxi√®me √©chec ‚Üí OPEN
    assert fetch_with_fallback() == "fallback"

    # Circuit ouvert ‚Üí fallback imm√©diat
    assert fetch_with_fallback() == "fallback"
```

### Chaos Engineering

**Tester le circuit breaker en condition r√©elle** :

```python
import random

class ChaosMonkey:
    """Injecte des √©checs pour tester la r√©silience."""

    def __init__(self, failure_rate=0.3):
        self.failure_rate = failure_rate

    def maybe_fail(self):
        if random.random() < self.failure_rate:
            raise Exception("Chaos monkey strike!")

    def wrap(self, func):
        def wrapper(*args, **kwargs):
            self.maybe_fail()
            return func(*args, **kwargs)
        return wrapper

# Test avec chaos monkey
chaos = ChaosMonkey(failure_rate=0.5)  # 50% d'√©checs
breaker = CircuitBreaker(failure_threshold=5, recovery_timeout=10)

@chaos.wrap
def unstable_api():
    return requests.get('https://api.example.com').json()

# Surveiller le comportement sur 100 appels
for i in range(100):
    try:
        data = breaker.call(unstable_api)
        print(f"Call {i}: SUCCESS")
    except CircuitBreakerOpenError:
        print(f"Call {i}: BLOCKED (circuit open)")
    except Exception as e:
        print(f"Call {i}: FAILED ({e})")

    time.sleep(0.1)

print(breaker.get_stats())
```

---

## Checklist pour production

- [ ] **Threshold adapt√©** au volume de trafic et √† la criticit√©
- [ ] **Recovery timeout** ‚â• 2√ó temps de d√©ploiement
- [ ] **Success threshold** en HALF_OPEN configur√© (‚â• 1)
- [ ] **Fen√™tre glissante** pour √©viter les faux positifs
- [ ] **Circuit breaker par service** ou par endpoint critique
- [ ] **Fallback d√©fini** pour chaque circuit breaker
- [ ] **Monitoring** : m√©triques d'√©tat expos√©es
- [ ] **Alertes** configur√©es (circuit open, flapping)
- [ ] **Logging** des transitions avec contexte
- [ ] **Tests** : transitions d'√©tats, fallbacks, recovery
- [ ] **Documentation** : seuils justifi√©s et comportement attendu
- [ ] **Runbook** : proc√©dure quand circuit ouvert
- [ ] **Dashboard** : vue d'ensemble de tous les circuits
- [ ] **Combination** avec retry et timeout test√©e

---

## Conclusion

Le circuit breaker est un **pattern fondamental** pour construire des syst√®mes distribu√©s r√©silients. Il prot√®ge vos services en d√©tectant les d√©faillances et en bloquant temporairement le trafic vers les services d√©faillants, √©vitant ainsi les cascades de pannes.

**Points cl√©s √† retenir** :

1. **Trois √©tats** : CLOSED (normal), OPEN (bloqu√©), HALF_OPEN (test de r√©cup√©ration)

2. **Compl√©mentaire aux retries** : Les retries r√©cup√®rent des √©checs transitoires, le circuit breaker prot√®ge contre les pannes persistantes

3. **Fail-fast** : √âchec imm√©diat quand circuit ouvert, lib√®re les ressources

4. **Toujours un fallback** : D√©gradation gracieuse plut√¥t qu'erreur totale

5. **Monitoring essentiel** : Surveiller les √©tats et les transitions pour d√©tecter les probl√®mes

6. **Configuration contextuelle** : Pas de valeur universelle, adapter aux caract√©ristiques du service

**Triangle de la r√©silience** :
```
        Circuit Breaker
        (Protection)
             /\
            /  \
           /    \
          /      \
    Timeout    Retry
   (D√©tection) (R√©cup√©ration)
```

**Prochaine √©tape** : Le circuit breaker prot√®ge contre les pannes, mais que faire pour optimiser les connexions r√©seau et r√©duire la latence ? La section suivante explore **Keep-Alive et les connexions persistantes**, des techniques pour am√©liorer les performances tout en maintenant la r√©silience.

---


‚è≠Ô∏è [Keep-alive et connexions persistantes](/08-programmation-reseau/08.4-keep-alive.md)
