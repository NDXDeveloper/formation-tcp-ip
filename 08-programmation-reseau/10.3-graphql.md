üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.10.3 GraphQL : consid√©rations r√©seau

# Table des mati√®res

## [Introduction](#introduction-1)

## [GraphQL vs REST : diff√©rences r√©seau fondamentales](#graphql-vs-rest--diff%C3%A9rences-r%C3%A9seau-fondamentales-1)

### [REST : Approche orient√©e ressources](#rest--approche-orient%C3%A9e-ressources-1)

### [GraphQL : Approche orient√©e besoins](#graphql--approche-orient%C3%A9e-besoins-1)

## [Le sch√©ma GraphQL : contrat de l'API](#le-sch%C3%A9ma-graphql--contrat-de-lapi-1)

### [Schema Definition Language (SDL)](#schema-definition-language-sdl-1)

### [Introspection du sch√©ma](#introspection-du-sch%C3%A9ma-1)

## [Requ√™tes GraphQL : anatomie r√©seau](#requ%C3%AAtes-graphql--anatomie-r%C3%A9seau-1)

### [Structure d'une requ√™te](#structure-dune-requ%C3%AAte-1)

### [Aliases et fragments](#aliases-et-fragments-1)

## [R√©solveurs et le probl√®me N+1](#r%C3%A9solveurs-et-le-probl%C3%A8me-n1-1)

### [R√©solveurs : le c≈ìur de GraphQL](#r%C3%A9solveurs--le-c%C5%93ur-de-graphql-1)

### [Le probl√®me N+1 : d√©sastre r√©seau](#le-probl%C3%A8me-n1--d%C3%A9sastre-r%C3%A9seau-1)

### [Solution : DataLoader](#solution--dataloader-1)

### [DataLoader pour relations complexes](#dataloader-pour-relations-complexes-1)

## [Mutations : √©criture de donn√©es](#mutations--%C3%A9criture-de-donn%C3%A9es-1)

### [Anatomie d'une mutation](#anatomie-dune-mutation-1)

### [Impl√©mentation serveur](#impl%C3%A9mentation-serveur-2)

### [Mutations multiples en une requ√™te](#mutations-multiples-en-une-requ%C3%AAte-1)

## [Subscriptions : temps r√©el sur WebSocket](#subscriptions--temps-r%C3%A9el-sur-websocket-1)

### [Protocole WebSocket](#protocole-websocket-1)

### [D√©finition de subscription](#d%C3%A9finition-de-subscription-1)

### [Impl√©mentation serveur (Node.js)](#impl%C3%A9mentation-serveur-nodejs-1)

### [Client JavaScript](#client-javascript-1)

### [Consid√©rations r√©seau pour subscriptions](#consid%C3%A9rations-r%C3%A9seau-pour-subscriptions-1)

## [Pagination : Relay Cursor Connections](#pagination--relay-cursor-connections-1)

### [Cursor-based pagination](#cursor-based-pagination-1)

### [Impl√©mentation serveur](#impl%C3%A9mentation-serveur-3)

## [Caching avec GraphQL](#caching-avec-graphql-1)

### [Probl√®mes de cache](#probl%C3%A8mes-de-cache-1)

### [Solutions de cache](#solutions-de-cache-1)
- [1. Cache par requ√™te compl√®te](#1-cache-par-requ%C3%AAte-compl%C3%A8te)
- [2. Normalized cache (Apollo)](#2-normalized-cache-apollo)
- [3. Persisted Queries (APQ)](#3-persisted-queries-apq)
- [4. HTTP caching avec GET](#4-http-caching-avec-get)

## [Batching et optimisations r√©seau](#batching-et-optimisations-r%C3%A9seau-1)

### [Request batching](#request-batching-1)

### [Response batching](#response-batching-1)

## [Gestion des erreurs](#gestion-des-erreurs-1)

## [Performance et limitations](#performance-et-limitations-1)

### [Complexity analysis](#complexity-analysis-1)

### [Depth limiting](#depth-limiting-1)

### [Rate limiting](#rate-limiting-1)

### [Timeout](#timeout-1)

## [Cas d'usage r√©els](#cas-dusage-r%C3%A9els-1)

### [1. GitHub GraphQL API](#1-github-graphql-api-1)

### [2. Shopify Storefront API](#2-shopify-storefront-api-1)

### [3. Application mobile avec GraphQL](#3-application-mobile-avec-graphql-1)

## [Conclusion](#conclusion-1)

---

**Temps de lecture estim√©** : 35-40 minutes
**Concepts cl√©s** : Sch√©ma, R√©solveurs, DataLoader, Subscriptions, Cache
**Probl√®mes r√©solus** : Over-fetching, Under-fetching, N+1
**Exemples de code** : JavaScript/Node.js, Python
**Optimisations** : DataLoader (21‚Üí2 requ√™tes), APQ (97% r√©duction), Batching
**Cas r√©els** : GitHub (90% √©conomie), Shopify, Applications mobiles

---

## Introduction

GraphQL est un langage de requ√™te pour APIs et un runtime c√¥t√© serveur pour ex√©cuter ces requ√™tes, d√©velopp√© par Facebook en 2012 et open-sourc√© en 2015. Contrairement √† REST qui expose des endpoints fixes retournant des structures de donn√©es pr√©d√©finies, GraphQL permet au client de d√©crire **exactement** les donn√©es dont il a besoin dans une seule requ√™te.

**Philosophie centrale :** "Ask for what you need, get exactly that"

Cette approche r√©sout plusieurs probl√®mes r√©seau fondamentaux :
- **Over-fetching** : R√©cup√©rer trop de donn√©es inutiles
- **Under-fetching** : Faire plusieurs requ√™tes pour obtenir toutes les donn√©es n√©cessaires
- **√âvolution de l'API** : Ajouter des champs sans versioning

## GraphQL vs REST : diff√©rences r√©seau fondamentales

### REST : Approche orient√©e ressources

```
Sc√©nario : Afficher un article de blog avec son auteur et ses commentaires

REST n√©cessite plusieurs requ√™tes :

GET /articles/123
‚Üí { "id": 123, "title": "...", "author_id": 456, "comment_ids": [1, 2, 3] }

GET /users/456
‚Üí { "id": 456, "name": "John Doe", "email": "...", "bio": "..." }

GET /comments/1
‚Üí { "id": 1, "text": "...", "author_id": 789 }

GET /comments/2
‚Üí { "id": 2, "text": "...", "author_id": 790 }

GET /comments/3
‚Üí { "id": 3, "text": "...", "author_id": 791 }

Total : 5 requ√™tes HTTP
Latence : 5 √ó RTT (round-trip time)
Over-fetching : email, bio de l'auteur non utilis√©s
Under-fetching : Besoin de plusieurs appels
```

### GraphQL : Approche orient√©e besoins

```graphql
# Une seule requ√™te GraphQL
query {
  article(id: 123) {
    id
    title
    author {
      name
    }
    comments {
      text
    }
  }
}

# R√©ponse exacte
{
  "data": {
    "article": {
      "id": 123,
      "title": "GraphQL Introduction",
      "author": {
        "name": "John Doe"
      },
      "comments": [
        { "text": "Great article!" },
        { "text": "Very informative" },
        { "text": "Thanks for sharing" }
      ]
    }
  }
}

Total : 1 requ√™te HTTP
Latence : 1 √ó RTT
Pas d'over-fetching : seulement les champs demand√©s
Pas d'under-fetching : tout en une requ√™te
```

**Impact r√©seau mesur√© :**

```
Sc√©nario : Page d'accueil d'une app mobile (liste de 20 posts)

REST :
- 1 requ√™te : GET /posts (liste des posts)
- 20 requ√™tes : GET /users/{id} (auteur de chaque post)
- Total : 21 requ√™tes
- Sur 4G (100ms latency) : 21 √ó 100ms = 2100ms minimum
- Taille : ~150 KB (beaucoup de donn√©es inutiles)

GraphQL :
- 1 requ√™te : query { posts { title, author { name } } }
- Total : 1 requ√™te
- Sur 4G : 1 √ó 100ms = 100ms minimum
- Taille : ~15 KB (seulement les donn√©es n√©cessaires)

Am√©lioration :
- Latence : 95% de r√©duction
- Bande passante : 90% de r√©duction
- Batterie mobile : Moins de radio wake-up
```

## Le sch√©ma GraphQL : contrat de l'API

Le sch√©ma GraphQL d√©finit la structure des donn√©es et les op√©rations disponibles, similaire √† un fichier `.proto` en gRPC.

### Schema Definition Language (SDL)

```graphql
# D√©finition des types
type User {
  id: ID!              # ! = requis (non-nullable)
  username: String!
  email: String!
  bio: String          # optionnel
  avatar: URL
  createdAt: DateTime!

  # Relations
  posts: [Post!]!      # Liste de posts (jamais null, √©l√©ments jamais null)
  followers: [User!]!
  following: [User!]!

  # Champs calcul√©s avec arguments
  isFollowing(userId: ID!): Boolean!

  # Pagination
  comments(first: Int, after: String): CommentConnection!
}

type Post {
  id: ID!
  title: String!
  content: String!
  published: Boolean!
  publishedAt: DateTime

  # Relations
  author: User!
  comments: [Comment!]!
  tags: [Tag!]!

  # Champs calcul√©s
  excerpt(length: Int = 100): String!
  readingTime: Int!  # en minutes
  likeCount: Int!
}

type Comment {
  id: ID!
  text: String!
  createdAt: DateTime!

  author: User!
  post: Post!
  parent: Comment  # Pour commentaires imbriqu√©s
  replies: [Comment!]!
}

type Tag {
  id: ID!
  name: String!
  posts: [Post!]!
}

# Types scalaires personnalis√©s
scalar DateTime
scalar URL
scalar Email

# Enums
enum Role {
  USER
  MODERATOR
  ADMIN
}

# Input types (pour mutations)
input CreatePostInput {
  title: String!
  content: String!
  tagIds: [ID!]!
}

input UpdateUserInput {
  username: String
  email: Email
  bio: String
}

# Point d'entr√©e : Query (lecture)
type Query {
  # R√©cup√©rer un utilisateur
  user(id: ID!): User
  users(first: Int, after: String): UserConnection!

  # R√©cup√©rer un post
  post(id: ID!): Post
  posts(
    first: Int
    after: String
    filter: PostFilter
    orderBy: PostOrderBy
  ): PostConnection!

  # Recherche
  search(query: String!): [SearchResult!]!

  # Utilisateur connect√©
  me: User
}

# Point d'entr√©e : Mutation (√©criture)
type Mutation {
  # Utilisateurs
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!

  # Posts
  createPost(input: CreatePostInput!): Post!
  updatePost(id: ID!, input: UpdatePostInput!): Post!
  deletePost(id: ID!): Boolean!
  publishPost(id: ID!): Post!

  # Interactions
  likePost(postId: ID!): Post!
  followUser(userId: ID!): User!

  # Commentaires
  addComment(postId: ID!, text: String!): Comment!
}

# Point d'entr√©e : Subscription (temps r√©el)
type Subscription {
  # Nouveau post publi√©
  postPublished: Post!

  # Nouveau commentaire sur un post
  commentAdded(postId: ID!): Comment!

  # Notifications pour un utilisateur
  notificationReceived(userId: ID!): Notification!
}

# Types pour pagination (Relay spec)
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  node: User!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

# Union types (pour r√©sultats de recherche)
union SearchResult = User | Post | Tag

# Interface
interface Node {
  id: ID!
}

type User implements Node {
  id: ID!
  # ... autres champs
}
```

### Introspection du sch√©ma

GraphQL permet d'interroger le sch√©ma lui-m√™me :

```graphql
# D√©couvrir tous les types
query {
  __schema {
    types {
      name
      kind
      description
    }
  }
}

# D√©couvrir un type sp√©cifique
query {
  __type(name: "User") {
    name
    fields {
      name
      type {
        name
        kind
      }
      args {
        name
        type {
          name
        }
      }
    }
  }
}
```

**Impact r√©seau :**
- Tooling (GraphiQL, Apollo Studio) exploite l'introspection
- G√©n√©ration automatique de documentation
- Autocompl√©tion c√¥t√© client
- Validation des requ√™tes avant envoi

## Requ√™tes GraphQL : anatomie r√©seau

### Structure d'une requ√™te

```graphql
# Requ√™te avec nom (recommand√© en production)
query GetUserProfile($userId: ID!) {
  user(id: $userId) {
    id
    username
    email
    posts(first: 10) {
      id
      title
      publishedAt
      likeCount
    }
    followers {
      id
      username
      avatar
    }
  }
}

# Variables (envoy√©es s√©par√©ment)
{
  "userId": "123"
}
```

**Requ√™te HTTP r√©elle :**

```http
POST /graphql HTTP/1.1
Host: api.example.com
Content-Type: application/json
Authorization: Bearer eyJhbGc...

{
  "query": "query GetUserProfile($userId: ID!) { user(id: $userId) { id username email posts(first: 10) { id title } } }",
  "variables": {
    "userId": "123"
  },
  "operationName": "GetUserProfile"
}
```

**R√©ponse HTTP :**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "user": {
      "id": "123",
      "username": "john_doe",
      "email": "john@example.com",
      "posts": [
        { "id": "1", "title": "First Post" },
        { "id": "2", "title": "Second Post" }
      ]
    }
  }
}
```

### Aliases et fragments

**Aliases :** Requ√™ter le m√™me champ plusieurs fois avec des arguments diff√©rents

```graphql
query {
  # Deux utilisateurs diff√©rents dans une seule requ√™te
  user1: user(id: "123") {
    username
    email
  }
  user2: user(id: "456") {
    username
    email
  }

  # Posts populaires et r√©cents
  popularPosts: posts(orderBy: LIKES_DESC, first: 5) {
    title
    likeCount
  }
  recentPosts: posts(orderBy: DATE_DESC, first: 5) {
    title
    publishedAt
  }
}
```

**√âconomie r√©seau :**
```
Sans alias (REST) : 4 requ√™tes HTTP
Avec alias (GraphQL) : 1 requ√™te HTTP
```

**Fragments :** R√©utiliser des ensembles de champs

```graphql
# D√©finition du fragment
fragment UserBasicInfo on User {
  id
  username
  avatar
}

fragment PostPreview on Post {
  id
  title
  excerpt(length: 150)
  publishedAt
  author {
    ...UserBasicInfo
  }
}

# Utilisation
query {
  me {
    ...UserBasicInfo
    email
    bio
  }

  posts(first: 10) {
    ...PostPreview
    likeCount
  }
}
```

**Avantages r√©seau :**
- R√©duction de la taille de la requ√™te (fragment r√©utilis√©)
- Consistency des donn√©es demand√©es
- Facilite les requ√™tes complexes

## R√©solveurs et le probl√®me N+1

### R√©solveurs : le c≈ìur de GraphQL

Un r√©solveur est une fonction qui r√©cup√®re les donn√©es pour un champ.

```javascript
// Serveur Node.js avec Apollo Server
const resolvers = {
  Query: {
    // R√©solveur pour Query.user
    user: async (parent, { id }, context) => {
      return context.db.users.findById(id);
    },

    posts: async (parent, { first, after }, context) => {
      return context.db.posts.findMany({ first, after });
    },
  },

  User: {
    // R√©solveur pour User.posts
    posts: async (user, args, context) => {
      return context.db.posts.findByAuthorId(user.id);
    },

    // R√©solveur pour User.followers
    followers: async (user, args, context) => {
      return context.db.followers.findByUserId(user.id);
    },
  },

  Post: {
    // R√©solveur pour Post.author
    author: async (post, args, context) => {
      return context.db.users.findById(post.authorId);
    },

    // R√©solveur pour Post.comments
    comments: async (post, args, context) => {
      return context.db.comments.findByPostId(post.id);
    },
  },
};
```

### Le probl√®me N+1 : d√©sastre r√©seau

**Sc√©nario catastrophe :**

```graphql
query {
  posts(first: 20) {
    title
    author {
      username
    }
  }
}
```

**R√©solution na√Øve :**

```javascript
// R√©solveur Query.posts
posts: async () => {
  // 1 requ√™te DB
  return db.query('SELECT * FROM posts LIMIT 20');
}

// R√©solveur Post.author (appel√© 20 fois !)
author: async (post) => {
  // 20 requ√™tes DB (une pour chaque post)
  return db.query('SELECT * FROM users WHERE id = ?', [post.authorId]);
}

// Total : 1 + 20 = 21 requ√™tes DB
// Sur une DB distante (10ms latency) : 21 √ó 10ms = 210ms
```

**Impact r√©seau amplifi√© :**

```
100 posts :
- Requ√™tes DB : 1 + 100 = 101
- Latence : 101 √ó 10ms = 1010ms

1000 posts :
- Requ√™tes DB : 1 + 1000 = 1001
- Latence : 1001 √ó 10ms = 10.01 secondes
```

### Solution : DataLoader

DataLoader est un pattern de batching et caching pour r√©soudre le N+1.

```javascript
const DataLoader = require('dataloader');

// Cr√©er un DataLoader pour les utilisateurs
const createUserLoader = () => {
  return new DataLoader(async (userIds) => {
    // Batch : r√©cup√©rer tous les utilisateurs en une seule requ√™te
    const users = await db.query(
      'SELECT * FROM users WHERE id IN (?)',
      [userIds]
    );

    // Retourner dans le m√™me ordre que les IDs demand√©s
    const userMap = {};
    users.forEach(user => {
      userMap[user.id] = user;
    });

    return userIds.map(id => userMap[id]);
  });
};

// Dans le contexte GraphQL
const context = {
  loaders: {
    user: createUserLoader(),
  },
};

// R√©solveur optimis√©
const resolvers = {
  Post: {
    author: async (post, args, context) => {
      // DataLoader batch automatiquement
      return context.loaders.user.load(post.authorId);
    },
  },
};
```

**R√©sultat optimis√© :**

```
Requ√™te : 20 posts avec leurs auteurs

Avant DataLoader :
- 21 requ√™tes DB (1 + 20)
- 210ms

Apr√®s DataLoader :
- 2 requ√™tes DB :
  1. SELECT * FROM posts LIMIT 20
  2. SELECT * FROM users WHERE id IN (1, 2, 3, ..., 20)
- 20ms

Am√©lioration : 10x plus rapide
```

**DataLoader avec cache :**

```javascript
// DataLoader cache automatiquement pendant la requ√™te
query {
  post(id: "1") {
    author {
      username
    }
  }
  post(id: "2") {
    author {  # M√™me auteur que post 1
      username
    }
  }
}

// Sans cache : 2 appels √† la fonction batch
// Avec cache : 1 appel, le 2e est servi depuis le cache
```

### DataLoader pour relations complexes

```javascript
// Loader pour commentaires
const createCommentLoader = () => {
  return new DataLoader(async (postIds) => {
    const comments = await db.query(
      'SELECT * FROM comments WHERE post_id IN (?) ORDER BY post_id',
      [postIds]
    );

    // Grouper par post_id
    const commentsByPost = {};
    postIds.forEach(id => {
      commentsByPost[id] = [];
    });

    comments.forEach(comment => {
      commentsByPost[comment.post_id].push(comment);
    });

    return postIds.map(id => commentsByPost[id]);
  });
};

// Utilisation
const resolvers = {
  Post: {
    comments: async (post, args, context) => {
      return context.loaders.comments.load(post.id);
    },
  },
};
```

**Performance avec DataLoader :**

```
Requ√™te complexe :
query {
  posts(first: 50) {
    title
    author { username }
    comments { text, author { username } }
  }
}

Sans DataLoader :
- posts : 1 requ√™te
- authors : 50 requ√™tes
- comments : 50 requ√™tes
- comment authors : N requ√™tes (N = nombre total de commentaires)
Total : 101 + N requ√™tes

Avec DataLoader :
- posts : 1 requ√™te
- authors : 1 requ√™te (batch)
- comments : 1 requ√™te (batch)
- comment authors : 1 requ√™te (batch)
Total : 4 requ√™tes

Am√©lioration : 96% de r√©duction
```

## Mutations : √©criture de donn√©es

### Anatomie d'une mutation

```graphql
mutation CreatePost($input: CreatePostInput!) {
  createPost(input: $input) {
    id
    title
    author {
      username
    }
    createdAt
  }
}

# Variables
{
  "input": {
    "title": "GraphQL Deep Dive",
    "content": "GraphQL is amazing...",
    "tagIds": ["1", "2", "3"]
  }
}
```

**Requ√™te HTTP :**

```http
POST /graphql HTTP/1.1
Content-Type: application/json
Authorization: Bearer ...

{
  "query": "mutation CreatePost($input: CreatePostInput!) { createPost(input: $input) { id title } }",
  "variables": {
    "input": {
      "title": "GraphQL Deep Dive",
      "content": "...",
      "tagIds": ["1", "2", "3"]
    }
  }
}
```

### Impl√©mentation serveur

```javascript
// Apollo Server
const resolvers = {
  Mutation: {
    createPost: async (parent, { input }, context) => {
      // Authentification
      if (!context.user) {
        throw new Error('Not authenticated');
      }

      // Validation
      if (input.title.length < 3) {
        throw new Error('Title must be at least 3 characters');
      }

      // Transaction DB
      const post = await context.db.transaction(async (trx) => {
        // Cr√©er le post
        const [postId] = await trx('posts').insert({
          title: input.title,
          content: input.content,
          author_id: context.user.id,
          created_at: new Date(),
        });

        // Associer les tags
        if (input.tagIds.length > 0) {
          await trx('post_tags').insert(
            input.tagIds.map(tagId => ({
              post_id: postId,
              tag_id: tagId,
            }))
          );
        }

        // R√©cup√©rer le post complet
        return trx('posts').where('id', postId).first();
      });

      // Invalider le cache
      context.loaders.post.clear(post.id);

      return post;
    },

    updatePost: async (parent, { id, input }, context) => {
      // V√©rifier permissions
      const post = await context.db.posts.findById(id);

      if (post.author_id !== context.user.id) {
        throw new Error('Not authorized');
      }

      // Mise √† jour partielle
      await context.db.posts.update(id, input);

      // Invalider cache
      context.loaders.post.clear(id);

      return context.db.posts.findById(id);
    },
  },
};
```

### Mutations multiples en une requ√™te

```graphql
mutation MultipleOperations {
  # Cr√©er un post
  post: createPost(input: {
    title: "New Post",
    content: "..."
  }) {
    id
  }

  # Suivre un utilisateur
  follow: followUser(userId: "456") {
    id
    following {
      id
    }
  }

  # Liker un post
  like: likePost(postId: "789") {
    id
    likeCount
  }
}
```

**Consid√©rations r√©seau :**

```
Avantage : 1 requ√™te HTTP au lieu de 3
Inconv√©nient : Pas de parall√©lisation serveur
             Les mutations s'ex√©cutent s√©quentiellement

REST √©quivalent avec HTTP/2 :
- 3 requ√™tes POST parall√®les
- Multiplexage HTTP/2
- Potentiellement plus rapide

Recommandation :
- Mutations ind√©pendantes ‚Üí Requ√™tes s√©par√©es (parall√®le)
- Mutations li√©es ‚Üí Une requ√™te (atomicit√©)
```

## Subscriptions : temps r√©el sur WebSocket

Les subscriptions GraphQL permettent au serveur de pousser des donn√©es vers le client en temps r√©el.

### Protocole WebSocket

GraphQL utilise g√©n√©ralement le protocole **graphql-ws** sur WebSocket.

**Handshake initial :**

```
Client ‚Üí Server (HTTP)
GET /graphql HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Protocol: graphql-ws

Server ‚Üí Client
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Protocol: graphql-ws

# Connexion WebSocket √©tablie
```

**Messages WebSocket :**

```json
// 1. Client envoie connection_init
{
  "type": "connection_init",
  "payload": {
    "Authorization": "Bearer ..."
  }
}

// 2. Serveur r√©pond connection_ack
{
  "type": "connection_ack"
}

// 3. Client subscribe
{
  "id": "1",
  "type": "subscribe",
  "payload": {
    "query": "subscription { postPublished { id title } }"
  }
}

// 4. Serveur envoie les donn√©es (√† chaque √©v√©nement)
{
  "id": "1",
  "type": "next",
  "payload": {
    "data": {
      "postPublished": {
        "id": "123",
        "title": "New Post"
      }
    }
  }
}

// 5. Client complete (se d√©sabonne)
{
  "id": "1",
  "type": "complete"
}
```

### D√©finition de subscription

```graphql
type Subscription {
  # Notification quand un nouveau post est publi√©
  postPublished: Post!

  # Notifications pour un utilisateur sp√©cifique
  notificationReceived(userId: ID!): Notification!

  # Changements sur un post (√©dition, likes, etc.)
  postUpdated(postId: ID!): Post!

  # Nouveau commentaire sur un post
  commentAdded(postId: ID!): Comment!
}
```

### Impl√©mentation serveur (Node.js)

```javascript
const { PubSub } = require('graphql-subscriptions');
const pubsub = new PubSub();

const resolvers = {
  Mutation: {
    createPost: async (parent, { input }, context) => {
      const post = await context.db.posts.create(input);

      // Publier l'√©v√©nement
      pubsub.publish('POST_PUBLISHED', {
        postPublished: post,
      });

      return post;
    },

    addComment: async (parent, { postId, text }, context) => {
      const comment = await context.db.comments.create({
        post_id: postId,
        text,
        author_id: context.user.id,
      });

      // Publier avec filtre
      pubsub.publish('COMMENT_ADDED', {
        commentAdded: comment,
        postId,
      });

      return comment;
    },
  },

  Subscription: {
    postPublished: {
      subscribe: () => pubsub.asyncIterator(['POST_PUBLISHED']),
    },

    commentAdded: {
      subscribe: (parent, { postId }) => {
        // Filtrer par postId
        return pubsub.asyncIterator(['COMMENT_ADDED']);
      },
      resolve: (payload, { postId }) => {
        // Ne retourner que si c'est le bon post
        if (payload.postId === postId) {
          return payload.commentAdded;
        }
        return null;
      },
    },
  },
};
```

**Avec Redis pour distribution :**

```javascript
const { RedisPubSub } = require('graphql-redis-subscriptions');
const Redis = require('ioredis');

const options = {
  host: 'localhost',
  port: 6379,
  retryStrategy: times => Math.min(times * 50, 2000),
};

const pubsub = new RedisPubSub({
  publisher: new Redis(options),
  subscriber: new Redis(options),
});

// Maintenant, les subscriptions fonctionnent sur plusieurs serveurs
```

### Client JavaScript

```javascript
import { createClient } from 'graphql-ws';

const client = createClient({
  url: 'ws://localhost:4000/graphql',
  connectionParams: {
    Authorization: 'Bearer token123',
  },
});

// S'abonner
const unsubscribe = client.subscribe(
  {
    query: `
      subscription {
        postPublished {
          id
          title
          author {
            username
          }
        }
      }
    `,
  },
  {
    next: (data) => {
      console.log('New post:', data.data.postPublished);
    },
    error: (error) => {
      console.error('Subscription error:', error);
    },
    complete: () => {
      console.log('Subscription completed');
    },
  }
);

// Se d√©sabonner
// unsubscribe();
```

**Client React avec Apollo :**

```javascript
import { useSubscription, gql } from '@apollo/client';

const POST_PUBLISHED = gql`
  subscription OnPostPublished {
    postPublished {
      id
      title
      author {
        username
      }
    }
  }
`;

function LatestPosts() {
  const { data, loading } = useSubscription(POST_PUBLISHED);

  if (loading) return <p>Waiting for posts...</p>;

  return (
    <div>
      <h3>Latest post: {data.postPublished.title}</h3>
      <p>By {data.postPublished.author.username}</p>
    </div>
  );
}
```

### Consid√©rations r√©seau pour subscriptions

**Comparaison avec polling :**

```
Polling (REST) :
GET /posts/latest tous les 5 secondes

- Requ√™tes : 720 par heure
- Overhead : 720 √ó (TCP handshake + TLS + HTTP headers)
- Latence : Jusqu'√† 5 secondes de d√©lai
- Bande passante : √âlev√©e m√™me sans changements

WebSocket Subscription :
- Connexion : 1 (maintenue ouverte)
- Overhead initial : 1 √ó (TCP + TLS + WS upgrade)
- Latence : Temps r√©el (<100ms)
- Bande passante : Seulement quand donn√©es changent

√âconomie :
- 99.9% moins de requ√™tes
- Latence divis√©e par 50
- Bande passante r√©duite de 90%+
```

**Scalabilit√© des WebSockets :**

```
Probl√®me : 10,000 connexions WebSocket simultan√©es

Ressources par connexion :
- M√©moire : ~10 KB (buffers, √©tat)
- File descriptor : 1

Total pour 10k connexions :
- RAM : ~100 MB
- FD : 10,000 (limite OS √† v√©rifier)

Solutions :
1. Load balancing avec sticky sessions
2. Redis PubSub pour distribution
3. Limiter connexions par utilisateur
4. Heartbeat pour d√©tecter connexions mortes
```

**Impl√©mentation heartbeat :**

```javascript
// Serveur
const WebSocket = require('ws');

wss.on('connection', (ws) => {
  ws.isAlive = true;

  ws.on('pong', () => {
    ws.isAlive = true;
  });
});

// Ping toutes les 30 secondes
const interval = setInterval(() => {
  wss.clients.forEach((ws) => {
    if (ws.isAlive === false) {
      return ws.terminate();
    }

    ws.isAlive = false;
    ws.ping();
  });
}, 30000);

wss.on('close', () => {
  clearInterval(interval);
});
```

## Pagination : Relay Cursor Connections

GraphQL utilise g√©n√©ralement la sp√©cification **Relay** pour la pagination.

### Cursor-based pagination

```graphql
type Query {
  posts(
    first: Int      # Nombre d'√©l√©ments
    after: String   # Cursor de d√©part
    last: Int       # Alternative : derniers N √©l√©ments
    before: String  # Alternative : cursor de fin
  ): PostConnection!
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PostEdge {
  node: Post!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}
```

**Utilisation :**

```graphql
# Premi√®re page (20 premiers posts)
query {
  posts(first: 20) {
    edges {
      node {
        id
        title
      }
      cursor
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}

# R√©ponse
{
  "data": {
    "posts": {
      "edges": [
        { "node": { "id": "1", "title": "Post 1" }, "cursor": "Y3Vyc29yMQ==" },
        { "node": { "id": "2", "title": "Post 2" }, "cursor": "Y3Vyc29yMg==" },
        // ... 18 autres
      ],
      "pageInfo": {
        "hasNextPage": true,
        "endCursor": "Y3Vyc29yMjA="
      }
    }
  }
}

# Page suivante
query {
  posts(first: 20, after: "Y3Vyc29yMjA=") {
    edges {
      node {
        id
        title
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
```

### Impl√©mentation serveur

```javascript
const resolvers = {
  Query: {
    posts: async (parent, { first, after }, context) => {
      // D√©coder le cursor (base64)
      let offset = 0;
      if (after) {
        const decoded = Buffer.from(after, 'base64').toString('utf-8');
        offset = parseInt(decoded.replace('cursor', ''), 10);
      }

      // R√©cup√©rer first + 1 pour savoir si hasNextPage
      const posts = await context.db.posts
        .findMany({ limit: first + 1, offset });

      const hasNextPage = posts.length > first;
      const edges = posts.slice(0, first).map((post, index) => ({
        node: post,
        cursor: Buffer.from(`cursor${offset + index + 1}`).toString('base64'),
      }));

      return {
        edges,
        pageInfo: {
          hasNextPage,
          hasPreviousPage: offset > 0,
          startCursor: edges.length > 0 ? edges[0].cursor : null,
          endCursor: edges.length > 0 ? edges[edges.length - 1].cursor : null,
        },
        totalCount: await context.db.posts.count(),
      };
    },
  },
};
```

**Avantages du cursor-based :**

```
Comparaison avec offset-based (REST classique)

Offset-based (probl√®me) :
GET /posts?page=1&limit=20
GET /posts?page=2&limit=20

Probl√®me : Si un post est ajout√© entre deux requ√™tes,
          la page 2 contiendra un √©l√©ment d√©j√† vu sur page 1

Cursor-based (solution) :
- Le cursor pointe vers un √©l√©ment sp√©cifique
- Coh√©rent m√™me si des √©l√©ments sont ajout√©s/supprim√©s
- Permet forward et backward navigation

Inconv√©nient :
- Pas de "saut" vers page N directement
- Adapt√© pour scroll infini, pas pour pagination classique
```

## Caching avec GraphQL

Le caching GraphQL est plus complexe que REST car chaque requ√™te peut √™tre unique.

### Probl√®mes de cache

```
REST :
GET /users/123 ‚Üí Cache par URL
GET /posts ‚Üí Cache par URL

GraphQL :
POST /graphql
Body: { "query": "{ user(id: 123) { name } }" }
‚Üí Cache comment ? Body unique √† chaque fois
```

### Solutions de cache

#### 1. Cache par requ√™te compl√®te

```javascript
// Client Apollo avec cache en m√©moire
import { InMemoryCache } from '@apollo/client';

const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        posts: {
          // Politique de merge pour pagination
          merge(existing = [], incoming) {
            return [...existing, ...incoming];
          },
        },
      },
    },
  },
});

// Requ√™te automatiquement cach√©e
const { data } = useQuery(gql`
  query GetUser($id: ID!) {
    user(id: $id) {
      id
      username
      email
    }
  }
`, {
  variables: { id: '123' },
  fetchPolicy: 'cache-first',  // Utiliser cache si disponible
});
```

**Policies de cache :**

```javascript
fetchPolicy options:
- 'cache-first'     : Cache ‚Üí Network (default)
- 'cache-only'      : Cache seulement, erreur si absent
- 'network-only'    : Network seulement, met √† jour cache
- 'no-cache'        : Network, pas de cache
- 'cache-and-network' : Cache imm√©diat + network en background
```

#### 2. Normalized cache (Apollo)

Apollo normalise les objets par ID pour un cache granulaire.

```javascript
const cache = new InMemoryCache();

// Requ√™te 1
query {
  user(id: "123") {
    id
    username
    email
  }
}

// Cache interne :
{
  "User:123": {
    "__typename": "User",
    "id": "123",
    "username": "john_doe",
    "email": "john@example.com"
  }
}

// Requ√™te 2 (diff√©rente mais m√™me utilisateur)
query {
  post(id: "456") {
    id
    author {
      id
      username  # D√©j√† en cache !
    }
  }
}

// Pas de fetch r√©seau pour author, servi depuis cache
```

**Impact r√©seau :**

```
Sc√©nario : Application avec 50 composants

Sans normalized cache :
- Chaque composant fait sa requ√™te
- 50 requ√™tes r√©seau pour user(id: 123)

Avec normalized cache :
- Premi√®re requ√™te : fetch r√©seau
- 49 suivantes : cache local
- √âconomie : 98% de requ√™tes
```

#### 3. Persisted Queries (APQ)

Automatic Persisted Queries r√©duit la taille des requ√™tes en utilisant des hashes.

**Fonctionnement :**

```
1. Client envoie le hash de la requ√™te
POST /graphql
{
  "extensions": {
    "persistedQuery": {
      "version": 1,
      "sha256Hash": "abc123..."
    }
  }
}

2. Si serveur a la requ√™te cach√©e :
‚Üí Ex√©cute directement (√©conomie de bande passante)

3. Si serveur n'a pas la requ√™te :
‚Üí R√©pond "PersistedQueryNotFound"

4. Client renvoie avec la requ√™te compl√®te :
{
  "query": "query GetUser($id: ID!) { ... }",
  "extensions": {
    "persistedQuery": {
      "version": 1,
      "sha256Hash": "abc123..."
    }
  }
}

5. Serveur cache la requ√™te et l'ex√©cute
6. Prochaines requ√™tes : seulement le hash
```

**√âconomie de bande passante :**

```
Requ√™te compl√®te : ~2 KB
Hash SHA256 : 64 bytes

√âconomie par requ√™te : 97%

Application mobile (1000 requ√™tes/jour) :
- Avant : 2 MB/jour
- Apr√®s : 64 KB/jour
- Impact batterie/data : Significatif
```

**Impl√©mentation Apollo :**

```javascript
// Serveur
const { ApolloServer } = require('apollo-server');

const server = new ApolloServer({
  typeDefs,
  resolvers,
  persistedQueries: {
    cache: new Map(),  // En production : Redis
  },
});

// Client
import { createPersistedQueryLink } from '@apollo/client/link/persisted-queries';
import { sha256 } from 'crypto-hash';

const link = createPersistedQueryLink({ sha256 }).concat(httpLink);

const client = new ApolloClient({
  link,
  cache: new InMemoryCache(),
});
```

#### 4. HTTP caching avec GET

GraphQL peut utiliser GET pour les queries (pas mutations).

```javascript
// Client Apollo avec GET
const httpLink = createHttpLink({
  uri: '/graphql',
  useGETForQueries: true,  // Queries via GET, Mutations via POST
});

// Requ√™te g√©n√©r√©e
GET /graphql?query={user(id:"123"){id,username}}&variables={}

// Headers de cache possibles
Cache-Control: public, max-age=300
```

**Avantages :**

```
GET queries :
- Cache navigateur standard
- Cache CDN/reverse proxy
- Cache HTTP standard

POST mutations :
- Pas de cache (comme attendu)
- Toujours ex√©cut√©es
```

## Batching et optimisations r√©seau

### Request batching

GraphQL permet de batcher plusieurs requ√™tes en une seule.

```javascript
// Sans batching : 3 requ√™tes HTTP
await client.query({ query: GET_USER });
await client.query({ query: GET_POSTS });
await client.query({ query: GET_COMMENTS });

// Avec batching : 1 requ√™te HTTP
POST /graphql
[
  { "query": "query GetUser { user(id: 123) { ... } }" },
  { "query": "query GetPosts { posts { ... } }" },
  { "query": "query GetComments { comments { ... } }" }
]

// R√©ponse
[
  { "data": { "user": {...} } },
  { "data": { "posts": [...] } },
  { "data": { "comments": [...] } }
]
```

**Configuration Apollo :**

```javascript
import { BatchHttpLink } from '@apollo/client/link/batch-http';

const link = new BatchHttpLink({
  uri: '/graphql',
  batchMax: 10,        // Max 10 requ√™tes par batch
  batchInterval: 20,   // Attendre 20ms avant d'envoyer
});
```

**Impact r√©seau :**

```
Page complexe : 15 queries GraphQL

Sans batching :
- 15 requ√™tes HTTP
- 15 √ó RTT latency
- Sur 3G (300ms RTT) : 4500ms

Avec batching (batch de 10) :
- 2 requ√™tes HTTP (10 + 5)
- 2 √ó RTT
- Sur 3G : 600ms

Am√©lioration : 87% plus rapide
```

### Response batching

Serveur peut aussi optimiser les r√©ponses.

```javascript
// Requ√™te
query {
  user1: user(id: "1") {
    posts { id title }
  }
  user2: user(id: "2") {
    posts { id title }
  }
  user3: user(id: "3") {
    posts { id title }
  }
}

// Sans optimisation : 3 √ó SELECT posts WHERE user_id = ?
// Avec DataLoader : 1 √ó SELECT posts WHERE user_id IN (1, 2, 3)
```

## Gestion des erreurs

GraphQL retourne toujours 200 OK, m√™me en cas d'erreur.

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "user": null
  },
  "errors": [
    {
      "message": "User not found",
      "locations": [{ "line": 2, "column": 3 }],
      "path": ["user"],
      "extensions": {
        "code": "NOT_FOUND",
        "userId": "999"
      }
    }
  ]
}
```

**Erreurs partielles :**

```graphql
query {
  user(id: "123") {
    username
    email
  }
  posts {  # Erreur ici
    title
  }
  comments {
    text
  }
}

# R√©ponse
{
  "data": {
    "user": {
      "username": "john_doe",
      "email": "john@example.com"
    },
    "posts": null,
    "comments": [
      { "text": "Great!" }
    ]
  },
  "errors": [
    {
      "message": "Database error",
      "path": ["posts"]
    }
  ]
}
```

**Custom error handling :**

```javascript
const { ApolloServer, UserInputError, AuthenticationError } = require('apollo-server');

const resolvers = {
  Query: {
    user: async (parent, { id }, context) => {
      if (!context.user) {
        throw new AuthenticationError('Not authenticated');
      }

      const user = await db.users.findById(id);

      if (!user) {
        throw new UserInputError('User not found', {
          userId: id,
        });
      }

      return user;
    },
  },
};
```

## Performance et limitations

### Complexity analysis

Pr√©venir les requ√™tes trop co√ªteuses.

```javascript
const { createComplexityLimitRule } = require('graphql-validation-complexity');

const server = new ApolloServer({
  typeDefs,
  resolvers,
  validationRules: [
    createComplexityLimitRule(1000, {
      onCost: (cost) => {
        console.log('Query cost:', cost);
      },
    }),
  ],
});
```

**Calcul de complexit√© :**

```graphql
query {
  posts(first: 100) {      # Cost: 100
    title                  # Cost: 100 √ó 1
    author {               # Cost: 100 √ó 1
      username             # Cost: 100 √ó 1
      followers(first: 50) {  # Cost: 100 √ó 50
        username           # Cost: 100 √ó 50 √ó 1
      }
    }
  }
}

# Total cost: 100 + 100 + 100 + 100 + 5000 + 5000 = 10,300
# ‚Üí Rejet√© si limite est 1000
```

### Depth limiting

Limiter la profondeur des requ√™tes.

```javascript
const depthLimit = require('graphql-depth-limit');

const server = new ApolloServer({
  typeDefs,
  resolvers,
  validationRules: [depthLimit(5)],
});

// Requ√™te rejet√©e (depth = 6)
query {
  user {              // 1
    posts {           // 2
      comments {      // 3
        author {      // 4
          posts {     // 5
            comments { // 6 ‚Üí TOO DEEP
              text
            }
          }
        }
      }
    }
  }
}
```

### Rate limiting

```javascript
const { RateLimitDirective } = require('graphql-rate-limit-directive');

const typeDefs = gql`
  directive @rateLimit(
    limit: Int!
    duration: Int!
  ) on FIELD_DEFINITION

  type Query {
    posts: [Post!]! @rateLimit(limit: 100, duration: 60)
    search(query: String!): [SearchResult!]! @rateLimit(limit: 10, duration: 60)
  }
`;
```

### Timeout

```javascript
const resolvers = {
  Query: {
    expensiveQuery: async (parent, args, context) => {
      // Timeout de 5 secondes
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 5000);

      try {
        const result = await fetch('http://slow-api.com/data', {
          signal: controller.signal,
        });
        return result;
      } catch (error) {
        if (error.name === 'AbortError') {
          throw new Error('Query timeout');
        }
        throw error;
      } finally {
        clearTimeout(timeout);
      }
    },
  },
};
```

## Cas d'usage r√©els

### 1. GitHub GraphQL API

GitHub a migr√© de REST v3 vers GraphQL v4.

```graphql
# Une seule requ√™te pour obtenir :
# - Infos repo
# - Issues r√©centes avec auteurs
# - Pull requests avec reviews

query {
  repository(owner: "facebook", name: "react") {
    name
    description
    stargazerCount

    issues(first: 5, orderBy: {field: CREATED_AT, direction: DESC}) {
      nodes {
        title
        author {
          login
        }
        comments(first: 3) {
          totalCount
        }
      }
    }

    pullRequests(first: 5, states: OPEN) {
      nodes {
        title
        author {
          login
        }
        reviews(first: 5) {
          totalCount
        }
      }
    }
  }
}

# √âquivalent REST : 15+ requ√™tes HTTP
```

**√âconomie mesur√©e par GitHub :**
- 90% de r√©duction des requ√™tes r√©seau
- 50% de r√©duction de bande passante
- Meilleure exp√©rience d√©veloppeur

### 2. Shopify Storefront API

```graphql
# Page produit compl√®te en une requ√™te
query ProductPage($handle: String!) {
  product(handle: $handle) {
    id
    title
    description

    images(first: 10) {
      edges {
        node {
          url
          altText
        }
      }
    }

    variants(first: 100) {
      edges {
        node {
          id
          title
          price
          availableForSale
        }
      }
    }

    collections(first: 5) {
      edges {
        node {
          title
        }
      }
    }

    reviews: metafield(namespace: "reviews", key: "data") {
      value
    }
  }
}
```

### 3. Application mobile avec GraphQL

```javascript
// Optimisation pour mobile
const POSTS_QUERY = gql`
  query GetPosts($includeImages: Boolean = false) {
    posts(first: 20) {
      id
      title
      excerpt

      # Charger images seulement sur WiFi
      images @include(if: $includeImages) {
        url
        thumbnail
      }
    }
  }
`;

// D√©tection du r√©seau
const isWifi = await NetInfo.fetch().then(state => state.type === 'wifi');

const { data } = useQuery(POSTS_QUERY, {
  variables: {
    includeImages: isWifi,  // Images seulement sur WiFi
  },
});
```

## Conclusion

GraphQL offre un mod√®le de communication r√©seau radicalement diff√©rent de REST :

**Avantages r√©seau :**
- **R√©duction des requ√™tes** : Une requ√™te au lieu de N
- **Optimisation bande passante** : Seulement les donn√©es n√©cessaires
- **Latence r√©duite** : Moins de round-trips
- **Temps r√©el** : Subscriptions sur WebSocket
- **Flexibilit√©** : Client d√©cide de la structure

**Co√ªts r√©seau :**
- **Complexit√© cache** : Pas de cache HTTP simple
- **Overhead initial** : Setup plus complexe que REST
- **Requ√™tes variables** : Chaque requ√™te peut √™tre unique
- **Optimisation serveur** : DataLoader, batching requis

**Quand utiliser GraphQL :**
- Applications mobiles (√©conomie data)
- Clients multiples (web, mobile, IoT)
- Donn√©es interconnect√©es complexes
- Besoin de flexibilit√© c√¥t√© client

**Quand √©viter GraphQL :**
- API publique simple (REST suffit)
- Cache HTTP critique
- √âquipe sans exp√©rience GraphQL
- Cas d'usage CRUD simple

**Prochaine section :** 8.10.4 Comparaison et crit√®res de choix

---

**Points cl√©s √† retenir :**
- GraphQL = un endpoint, requ√™tes flexibles
- Sch√©ma = contrat API avec introspection
- DataLoader r√©sout le probl√®me N+1 (critique)
- Subscriptions = temps r√©el sur WebSocket
- Normalized cache = optimisation client
- Persisted queries = √©conomie bande passante
- Complexity/depth limiting = protection serveur
- GitHub, Shopify : √©conomies mesurables en production

‚è≠Ô∏è [Comparaison et crit√®res de choix](/08-programmation-reseau/10.4-comparaison-choix.md)
