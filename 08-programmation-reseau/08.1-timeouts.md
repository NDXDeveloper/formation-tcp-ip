ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 8.8.1 Timeouts : lecture, Ã©criture, connexion

## Introduction

Les timeouts sont la **premiÃ¨re ligne de dÃ©fense** contre les dÃ©faillances rÃ©seau. Sans timeouts appropriÃ©s, une application peut rester bloquÃ©e indÃ©finiment en attendant une rÃ©ponse qui ne viendra jamais, Ã©puisant progressivement toutes ses ressources (threads, mÃ©moire, descripteurs de fichiers).

**Un timeout bien configurÃ© transforme un blocage infini en une erreur gÃ©rable.**

Cette section explore en profondeur les trois types de timeouts critiques, leurs implications au niveau TCP, et comment les implÃ©menter correctement dans vos applications.

---

## Les trois types de timeouts

### Vue d'ensemble

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Cycle de vie TCP                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  1. CONNECTION TIMEOUT                                  â”‚
â”‚     [SYN] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> [SYN-ACK]                 â”‚
â”‚           â† temps maximum â†’                             â”‚
â”‚                                                         â”‚
â”‚  2. WRITE TIMEOUT                                       â”‚
â”‚     [Data] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>                           â”‚
â”‚           â† temps maximum â†’                             â”‚
â”‚                                                         â”‚
â”‚  3. READ TIMEOUT                                        â”‚
â”‚            <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [Data]                    â”‚
â”‚           â† temps maximum â†’                             â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Chaque type de timeout protÃ¨ge contre un mode de dÃ©faillance diffÃ©rent :

| Type | ProtÃ¨ge contre | SymptÃ´me sans timeout | Timeout typique |
|------|----------------|----------------------|-----------------|
| **Connection** | Serveur injoignable, firewall qui drop | Thread bloquÃ© sur `connect()` | 2-10s |
| **Read** | Serveur qui ne rÃ©pond pas, rÃ©ponse lente | Thread bloquÃ© sur `read()`/`recv()` | 5-30s |
| **Write** | Serveur qui n'accepte plus de donnÃ©es | Thread bloquÃ© sur `write()`/`send()` | 5-30s |

---

## 1. Connection Timeout

### Qu'est-ce qu'un connection timeout ?

Le **connection timeout** limite le temps allouÃ© pour Ã©tablir une connexion TCP, c'est-Ã -dire complÃ©ter le 3-way handshake :

```
Client                          Serveur
  â”‚                                â”‚
  â”‚â”€â”€â”€â”€â”€â”€â”€ SYN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
  â”‚                                â”‚
  â”‚<â”€â”€â”€â”€â”€â”€ SYN-ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
  â”‚                                â”‚
  â”‚â”€â”€â”€â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
  â”‚                                â”‚
  â””â”€â”€ Connexion Ã©tablie (ou timeout)
```

### Pourquoi est-il crucial ?

**Sans connection timeout**, votre application peut rester bloquÃ©e pendant **plusieurs minutes** en attendant une rÃ©ponse qui ne viendra jamais.

#### Comportement par dÃ©faut du systÃ¨me

Sur Linux, le timeout par dÃ©faut pour `connect()` est dÃ©terminÃ© par le paramÃ¨tre kernel `tcp_syn_retries` :

```bash
# Valeur par dÃ©faut : gÃ©nÃ©ralement 5 ou 6 retries
$ sysctl net.ipv4.tcp_syn_retries
net.ipv4.tcp_syn_retries = 6
```

Avec 6 retries, le timing est approximativement :

```
Tentative 1:  0s   (SYN initial)
Tentative 2:  1s   (retry aprÃ¨s 1s)
Tentative 3:  3s   (retry aprÃ¨s 2s)
Tentative 4:  7s   (retry aprÃ¨s 4s)
Tentative 5: 15s   (retry aprÃ¨s 8s)
Tentative 6: 31s   (retry aprÃ¨s 16s)
Tentative 7: 63s   (retry aprÃ¨s 32s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total: ~127 secondes !
```

**127 secondes avant de dÃ©tecter que le serveur est injoignable** - inacceptable pour une application interactive !

### Cas d'usage rÃ©els

#### ScÃ©nario 1 : Firewall qui drop silencieusement

```
Client â”€â”€[SYN]â”€â”€> Firewall â”€â”€X (drop)
                      â”‚
                  (silence)
                      â”‚
Client attend... attend... attend... 127s
```

**ProblÃ¨me** : Le firewall ne rÃ©pond mÃªme pas avec un RST, il drop le paquet. Le client attend indÃ©finiment.

**Solution** : Connection timeout de 5-10 secondes.

#### ScÃ©nario 2 : Service discovery dans un cluster

```python
# Anti-pattern : tentative de connexion sans timeout
def find_healthy_node(nodes):
    for node in nodes:
        try:
            conn = socket.create_connection((node.ip, node.port))
            return conn  # Premier nÅ“ud joignable
        except:
            continue  # Essayer le suivant
```

**ProblÃ¨me** : Si le premier nÅ“ud est down, on attend 127s avant d'essayer le second. Avec 10 nÅ“uds down, c'est **21 minutes** !

**Solution** : Connection timeout court
```python
def find_healthy_node(nodes, timeout=2.0):
    for node in nodes:
        try:
            conn = socket.create_connection(
                (node.ip, node.port),
                timeout=timeout  # Max 2s par nÅ“ud
            )
            return conn
        except socket.timeout:
            continue  # NÅ“ud injoignable, suivant
    raise NoHealthyNodeError()
```

### ImplÃ©mentation par langage

#### Python

```python
import socket

# MÃ©thode 1 : socket.create_connection (recommandÃ©)
try:
    conn = socket.create_connection(
        ('api.example.com', 443),
        timeout=5.0  # 5 secondes
    )
except socket.timeout:
    print("Connection timeout")
except socket.error as e:
    print(f"Connection failed: {e}")

# MÃ©thode 2 : socket.settimeout
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.settimeout(5.0)
try:
    sock.connect(('api.example.com', 443))
except socket.timeout:
    print("Connection timeout")
finally:
    sock.close()
```

**Avec bibliothÃ¨ques HTTP** :

```python
import requests

# requests utilise urllib3 qui supporte les timeouts
response = requests.get(
    'https://api.example.com/data',
    timeout=(5.0, 30.0)  # (connect_timeout, read_timeout)
)

# httpx (moderne, async)
import httpx

async with httpx.AsyncClient() as client:
    response = await client.get(
        'https://api.example.com/data',
        timeout=httpx.Timeout(
            connect=5.0,  # Connection timeout
            read=30.0,    # Read timeout
            write=30.0,   # Write timeout
            pool=10.0     # Pool acquisition timeout
        )
    )
```

#### Go

```go
package main

import (
    "context"
    "net"
    "net/http"
    "time"
)

func main() {
    // MÃ©thode 1 : net.DialTimeout
    conn, err := net.DialTimeout("tcp", "api.example.com:443", 5*time.Second)
    if err != nil {
        // Timeout ou autre erreur
        return
    }
    defer conn.Close()

    // MÃ©thode 2 : Dialer personnalisÃ©
    dialer := &net.Dialer{
        Timeout:   5 * time.Second,
        KeepAlive: 30 * time.Second,
    }
    conn, err = dialer.Dial("tcp", "api.example.com:443")

    // MÃ©thode 3 : HTTP client avec timeout
    client := &http.Client{
        Timeout: 30 * time.Second, // Timeout global
        Transport: &http.Transport{
            DialContext: (&net.Dialer{
                Timeout:   5 * time.Second,  // Connection timeout
                KeepAlive: 30 * time.Second,
            }).DialContext,
            TLSHandshakeTimeout:   10 * time.Second,
            ResponseHeaderTimeout: 10 * time.Second,
            ExpectContinueTimeout: 1 * time.Second,
        },
    }

    resp, err := client.Get("https://api.example.com/data")
}
```

#### JavaScript (Node.js)

```javascript
// Node.js natif
const net = require('net');

const socket = new net.Socket();
socket.setTimeout(5000); // 5 secondes

socket.connect(443, 'api.example.com', () => {
    console.log('Connected');
});

socket.on('timeout', () => {
    console.log('Connection timeout');
    socket.destroy();
});

socket.on('error', (err) => {
    console.log('Connection error:', err);
});

// Avec axios (HTTP client populaire)
const axios = require('axios');

axios.get('https://api.example.com/data', {
    timeout: 5000 // 5 secondes (inclut connection + read)
})
.catch(err => {
    if (err.code === 'ECONNABORTED') {
        console.log('Request timeout');
    }
});

// Avec fetch (moderne)
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);

fetch('https://api.example.com/data', {
    signal: controller.signal
})
.then(response => {
    clearTimeout(timeoutId);
    return response.json();
})
.catch(err => {
    if (err.name === 'AbortError') {
        console.log('Request timeout');
    }
});
```

#### Java

```java
import java.net.Socket;
import java.net.InetSocketAddress;
import java.io.IOException;

public class TimeoutExample {
    public static void main(String[] args) {
        Socket socket = new Socket();

        try {
            // Connection timeout de 5 secondes
            socket.connect(
                new InetSocketAddress("api.example.com", 443),
                5000  // milliseconds
            );

            // Read timeout de 30 secondes
            socket.setSoTimeout(30000);

        } catch (java.net.SocketTimeoutException e) {
            System.out.println("Connection timeout");
        } catch (IOException e) {
            System.out.println("Connection error: " + e);
        } finally {
            try {
                socket.close();
            } catch (IOException e) {}
        }
    }
}

// Avec HttpClient (Java 11+)
import java.net.http.*;
import java.time.Duration;

HttpClient client = HttpClient.newBuilder()
    .connectTimeout(Duration.ofSeconds(5))
    .build();

HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com/data"))
    .timeout(Duration.ofSeconds(30))  // Timeout global
    .build();

HttpResponse<String> response = client.send(
    request,
    HttpResponse.BodyHandlers.ofString()
);
```

---

## 2. Read Timeout

### Qu'est-ce qu'un read timeout ?

Le **read timeout** limite le temps d'attente pour recevoir des donnÃ©es aprÃ¨s qu'une connexion a Ã©tÃ© Ã©tablie.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Connexion Ã©tablie âœ“                  â”‚
â”‚                                      â”‚
â”‚ Client: GET /api/data HTTP/1.1       â”‚
â”‚         [attend la rÃ©ponse...]       â”‚
â”‚              â±ï¸ Read timeout         â”‚
â”‚                                      â”‚
â”‚ Serveur: [traite... calcule...]      â”‚
â”‚          [enfin prÃªt]                â”‚
â”‚          HTTP/1.1 200 OK             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### DiffÃ©rence avec le connection timeout

| | Connection Timeout | Read Timeout |
|---|-------------------|--------------|
| **Phase** | Ã‰tablissement connexion | AprÃ¨s connexion Ã©tablie |
| **OpÃ©ration** | `connect()` | `read()`/`recv()` |
| **ProtÃ¨ge contre** | Serveur injoignable | Serveur lent/bloquÃ© |
| **DÃ©clenche si** | Pas de SYN-ACK | Pas de donnÃ©es reÃ§ues |

### Cas d'usage rÃ©els

#### ScÃ©nario 1 : RequÃªte Ã  une base de donnÃ©es lente

```python
import psycopg2

# Sans timeout : peut bloquer indÃ©finiment sur une query lente
conn = psycopg2.connect(
    host="db.example.com",
    database="mydb",
    user="user",
    password="pass"
)

# Avec timeout : dÃ©tection des queries problÃ©matiques
conn = psycopg2.connect(
    host="db.example.com",
    database="mydb",
    user="user",
    password="pass",
    connect_timeout=5,        # Connection timeout
    options=f"-c statement_timeout={30000}"  # 30s query timeout
)

cursor = conn.cursor()
try:
    cursor.execute("SELECT * FROM huge_table WHERE complex_condition")
except psycopg2.errors.QueryCanceled:
    print("Query took too long, cancelled")
```

#### ScÃ©nario 2 : API externe qui calcule une rÃ©ponse

**Contexte** : Vous appelez une API de machine learning qui analyse des images.

```javascript
// Sans timeout : le thread reste bloquÃ© si le ML prend trop de temps
const response = await fetch('https://ml-api.example.com/analyze', {
    method: 'POST',
    body: imageData
});

// Avec timeout adaptÃ© : 60s pour l'analyse ML
const controller = new AbortController();
const timeout = setTimeout(() => controller.abort(), 60000);

try {
    const response = await fetch('https://ml-api.example.com/analyze', {
        method: 'POST',
        body: imageData,
        signal: controller.signal
    });
    clearTimeout(timeout);
    return await response.json();
} catch (error) {
    if (error.name === 'AbortError') {
        // Fallback : rÃ©ponse par dÃ©faut ou mise en queue
        return { status: 'processing', jobId: '...' };
    }
    throw error;
}
```

#### ScÃ©nario 3 : Streaming de donnÃ©es

Pour le streaming, le read timeout s'applique **entre chaque chunk de donnÃ©es**, pas au stream complet.

```go
func streamLogs(conn net.Conn) error {
    // Timeout de 30s ENTRE chaque chunk
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))

    reader := bufio.NewReader(conn)
    for {
        line, err := reader.ReadString('\n')
        if err != nil {
            if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
                return fmt.Errorf("no data received for 30s")
            }
            return err
        }

        // DonnÃ©es reÃ§ues, reset le timeout
        conn.SetReadDeadline(time.Now().Add(30 * time.Second))

        fmt.Println("Log:", line)
    }
}
```

### Comportement au niveau TCP

#### Idle connection vs slow response

**Question critique** : Que se passe-t-il si le serveur est lent mais envoie des donnÃ©es par petits paquets ?

```
Temps    Client                    Serveur
0s       GET /data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>
                                    [traite...]
5s                <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  HTTP/1.1 200 OK\r\n
                                    [calcule...]
10s               <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  Content-Length: 10000\r\n
                                    [calcule...]
15s               <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  \r\n{"data":
                                    [calcule...]
```

**Avec read timeout de 10s** :
- âŒ Timeout Ã  10s ? Non ! Car des donnÃ©es sont reÃ§ues Ã  5s et 10s
- âœ… Le timeout se reset Ã  chaque rÃ©ception de donnÃ©es

**Le read timeout protÃ¨ge contre l'absence de donnÃ©es, pas contre la lenteur.**

### ImplÃ©mentation par langage

#### Python

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('api.example.com', 80))

# Timeout de 30s pour read
sock.settimeout(30.0)

try:
    # Envoi de la requÃªte
    sock.sendall(b'GET / HTTP/1.1\r\nHost: api.example.com\r\n\r\n')

    # Lecture de la rÃ©ponse (avec timeout)
    data = sock.recv(4096)

except socket.timeout:
    print("Read timeout: no data received for 30s")
finally:
    sock.close()

# Avec requests : tuple (connect_timeout, read_timeout)
import requests

response = requests.get(
    'https://api.example.com/slow-endpoint',
    timeout=(5, 60)  # 5s pour connect, 60s pour read
)
```

#### Go

```go
func makeRequestWithReadTimeout() error {
    // Connection
    conn, err := net.DialTimeout("tcp", "api.example.com:80", 5*time.Second)
    if err != nil {
        return err
    }
    defer conn.Close()

    // Envoi de la requÃªte
    _, err = conn.Write([]byte("GET / HTTP/1.1\r\nHost: api.example.com\r\n\r\n"))
    if err != nil {
        return err
    }

    // Read timeout de 30s
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))

    // Lecture de la rÃ©ponse
    buffer := make([]byte, 4096)
    n, err := conn.Read(buffer)
    if err != nil {
        if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
            return fmt.Errorf("read timeout")
        }
        return err
    }

    fmt.Printf("Received %d bytes\n", n)
    return nil
}

// Avec http.Client
client := &http.Client{
    Transport: &http.Transport{
        ResponseHeaderTimeout: 10 * time.Second, // Timeout pour headers
        // Note: pas de read timeout direct, utiliser context
    },
}

// Utiliser un context pour le timeout global
ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
defer cancel()

req, _ := http.NewRequestWithContext(ctx, "GET", "https://api.example.com/data", nil)
resp, err := client.Do(req)
```

#### JavaScript (Node.js)

```javascript
const net = require('net');

const socket = new net.Socket();

// Connection
socket.connect(80, 'api.example.com', () => {
    console.log('Connected');

    // Envoi de requÃªte
    socket.write('GET / HTTP/1.1\r\nHost: api.example.com\r\n\r\n');

    // Read timeout de 30s
    socket.setTimeout(30000);
});

socket.on('data', (data) => {
    console.log('Received:', data.toString());
    // Reset timeout Ã  chaque rÃ©ception
    socket.setTimeout(30000);
});

socket.on('timeout', () => {
    console.log('Read timeout: no data for 30s');
    socket.destroy();
});

// Avec axios : timeout global (connection + read)
const axios = require('axios');

axios.get('https://api.example.com/data', {
    timeout: 30000,  // 30s total
    onDownloadProgress: (progressEvent) => {
        // Monitoring du download
        console.log('Downloaded:', progressEvent.loaded);
    }
});
```

---

## 3. Write Timeout

### Qu'est-ce qu'un write timeout ?

Le **write timeout** limite le temps d'attente pour envoyer des donnÃ©es au serveur. Il est moins souvent configurÃ© mais tout aussi important.

### Quand le write timeout se dÃ©clenche-t-il ?

#### ScÃ©nario 1 : Serveur qui n'accepte plus de donnÃ©es (full TCP receive buffer)

```
Client                               Serveur
  â”‚                                    â”‚
  â”‚â”€â”€â”€â”€ write(1MB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>   â”‚ Buffer TCP: [â–ˆâ–ˆâ–ˆ full]
  â”‚                                    â”‚ Application: bloquÃ©e/lente
  â”‚                                    â”‚
  â”‚ [bloquÃ© sur write()]               â”‚
  â”‚ â±ï¸ Write timeout                   â”‚
```

**Ce qui se passe au niveau TCP** :

1. Le client essaie d'envoyer 1MB de donnÃ©es
2. Le buffer de rÃ©ception du serveur (SO_RCVBUF) est plein
3. Le serveur envoie une fenÃªtre TCP de 0 (flow control)
4. Le client est bloquÃ© jusqu'Ã  ce que le serveur libÃ¨re de l'espace
5. Sans write timeout, le client attend indÃ©finiment

#### ScÃ©nario 2 : Upload de fichier vers un serveur lent

```python
def upload_large_file(filename, url):
    with open(filename, 'rb') as f:
        # Fichier de 1GB
        data = f.read()

        # Sans write timeout : peut bloquer si serveur saturÃ©
        response = requests.post(
            url,
            data=data,
            timeout=(5, None)  # âŒ Pas de write timeout !
        )
```

**ProblÃ¨me** : Si le serveur a une connexion lente ou un disque saturÃ©, l'upload peut prendre des heures sans qu'on puisse le dÃ©tecter.

**Solution** :
```python
import httpx

async def upload_with_timeout(filename, url):
    async with httpx.AsyncClient() as client:
        with open(filename, 'rb') as f:
            response = await client.post(
                url,
                content=f,
                timeout=httpx.Timeout(
                    connect=5.0,
                    read=300.0,
                    write=300.0,  # âœ“ Write timeout de 5 minutes
                    pool=10.0
                )
            )
    return response
```

### ImplÃ©mentation par langage

#### Python

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('upload.example.com', 80))

# Write timeout de 60s
sock.settimeout(60.0)

large_data = b'x' * (10 * 1024 * 1024)  # 10MB

try:
    # Si le serveur n'accepte pas les donnÃ©es, timeout aprÃ¨s 60s
    sock.sendall(large_data)
except socket.timeout:
    print("Write timeout: couldn't send data within 60s")
finally:
    sock.close()
```

#### Go

```go
func uploadWithWriteTimeout(data []byte) error {
    conn, err := net.Dial("tcp", "upload.example.com:80")
    if err != nil {
        return err
    }
    defer conn.Close()

    // Write timeout de 60s
    conn.SetWriteDeadline(time.Now().Add(60 * time.Second))

    // Tentative d'envoi
    n, err := conn.Write(data)
    if err != nil {
        if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
            return fmt.Errorf("write timeout after sending %d bytes", n)
        }
        return err
    }

    return nil
}
```

#### JavaScript (Node.js)

```javascript
const net = require('net');

const socket = new net.Socket();

socket.connect(80, 'upload.example.com', () => {
    const largeData = Buffer.alloc(10 * 1024 * 1024); // 10MB

    // Write timeout de 60s
    socket.setTimeout(60000);

    const written = socket.write(largeData, (err) => {
        if (err) {
            console.error('Write error:', err);
        }
    });

    if (!written) {
        console.log('Data buffered, waiting for drain event');
        socket.once('drain', () => {
            console.log('Buffer drained, can write more');
        });
    }
});

socket.on('timeout', () => {
    console.log('Write timeout');
    socket.destroy();
});
```

---

## Choisir les bonnes valeurs de timeout

### Principes gÃ©nÃ©raux

**Il n'existe pas de valeur universelle** - les timeouts dÃ©pendent de votre contexte :

| Contexte | Connection | Read | Write |
|----------|-----------|------|-------|
| **API REST interactive** | 2-5s | 10-30s | 10-30s |
| **Batch processing** | 10s | 5-10min | 5-10min |
| **Real-time (WebSocket)** | 3s | 30s | 30s |
| **File upload** | 5s | 10min | 10min |
| **Database query** | 5s | 30s-2min | 30s |
| **Microservices (interne)** | 1-2s | 5-10s | 5-10s |

### MÃ©thodologie de calibration

#### Ã‰tape 1 : Mesurer les latences rÃ©elles

```python
import time
import statistics

latencies = []

for _ in range(100):
    start = time.time()
    try:
        response = requests.get('https://api.example.com/endpoint')
        latency = time.time() - start
        latencies.append(latency)
    except:
        pass

print(f"P50: {statistics.median(latencies):.2f}s")
print(f"P95: {statistics.quantiles(latencies, n=20)[18]:.2f}s")
print(f"P99: {statistics.quantiles(latencies, n=100)[98]:.2f}s")
print(f"Max: {max(latencies):.2f}s")
```

**Output exemple** :
```
P50: 0.12s
P95: 0.45s
P99: 1.20s
Max: 2.30s
```

#### Ã‰tape 2 : Appliquer une marge de sÃ©curitÃ©

**RÃ¨gle empirique** : Timeout = P99 Ã— 2 ou P99 + 2 standard deviations

```python
timeout = max(
    statistics.quantiles(latencies, n=100)[98] * 2,  # P99 Ã— 2
    5.0  # Minimum absolu
)
```

Pour l'exemple ci-dessus : `timeout = 1.20 Ã— 2 = 2.4s`, arrondi Ã  **3s**.

#### Ã‰tape 3 : Adapter selon le contexte utilisateur

**Question clÃ©** : Combien de temps un utilisateur est-il prÃªt Ã  attendre ?

```
Action utilisateur          TolÃ©rance    Timeout recommandÃ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Click sur bouton           < 1s          2-3s
Chargement de page         < 3s          5-10s
Soumission de formulaire   < 5s          10-15s
Upload de fichier          < 30s         60-120s
Export de rapport          < 1min        2-5min
Batch nocturne             Heures        30-60min
```

### Timeouts diffÃ©renciÃ©s par endpoint

Tous les endpoints n'ont pas les mÃªmes besoins :

```python
class APIClient:
    def __init__(self):
        self.timeouts = {
            '/health': (1, 2),           # Rapide
            '/users/{id}': (2, 5),       # Standard
            '/search': (3, 10),          # Query complexe
            '/reports/generate': (5, 300), # GÃ©nÃ©ration lourde
            '/files/upload': (5, 600)    # Upload
        }

    def request(self, endpoint, **kwargs):
        timeout = self.timeouts.get(
            endpoint,
            (5, 30)  # Default
        )
        return requests.get(endpoint, timeout=timeout, **kwargs)
```

### Timeouts adaptifs (pattern avancÃ©)

Ajuster dynamiquement les timeouts selon les conditions rÃ©seau :

```go
type AdaptiveTimeout struct {
    baseTimeout time.Duration
    mu          sync.RWMutex
    latencies   []time.Duration
    maxSamples  int
}

func (at *AdaptiveTimeout) GetTimeout() time.Duration {
    at.mu.RLock()
    defer at.mu.RUnlock()

    if len(at.latencies) < 10 {
        return at.baseTimeout
    }

    // Calculer P95
    sorted := make([]time.Duration, len(at.latencies))
    copy(sorted, at.latencies)
    sort.Slice(sorted, func(i, j int) bool {
        return sorted[i] < sorted[j]
    })

    p95Index := int(float64(len(sorted)) * 0.95)
    p95 := sorted[p95Index]

    // Timeout = P95 Ã— 2
    adaptive := p95 * 2

    // Limiter entre min et max
    min := at.baseTimeout / 2
    max := at.baseTimeout * 4

    if adaptive < min {
        return min
    }
    if adaptive > max {
        return max
    }

    return adaptive
}

func (at *AdaptiveTimeout) RecordLatency(latency time.Duration) {
    at.mu.Lock()
    defer at.mu.Unlock()

    at.latencies = append(at.latencies, latency)

    // Garder seulement les N derniÃ¨res mesures
    if len(at.latencies) > at.maxSamples {
        at.latencies = at.latencies[1:]
    }
}
```

---

## Patterns et bonnes pratiques

### 1. Timeout en cascade

Dans une architecture microservices, les timeouts doivent former une hiÃ©rarchie cohÃ©rente :

```
API Gateway (timeout: 10s)
    â”‚
    â”œâ”€> Service A (timeout: 8s)
    â”‚       â”‚
    â”‚       â””â”€> Database (timeout: 6s)
    â”‚
    â””â”€> Service B (timeout: 8s)
            â”‚
            â””â”€> Cache (timeout: 2s)
```

**RÃ¨gle** : `timeout_parent > timeout_child + overhead`

```python
class ServiceClient:
    def get_user_data(self, user_id):
        # Timeout total: 10s
        timeout_budget = 10.0
        overhead_per_call = 0.5  # Network + processing

        # Appel 1 : Database (60% du budget)
        db_timeout = timeout_budget * 0.6 - overhead_per_call
        user = self.db.query(
            f"SELECT * FROM users WHERE id = {user_id}",
            timeout=db_timeout  # ~5.5s
        )

        # Appel 2 : Preferences service (30% du budget)
        pref_timeout = timeout_budget * 0.3 - overhead_per_call
        try:
            preferences = self.pref_service.get(
                user_id,
                timeout=pref_timeout  # ~2.5s
            )
        except Timeout:
            preferences = {}  # Fallback

        return {**user, 'preferences': preferences}
```

### 2. Timeout avec retry

Combiner timeout court + retry intelligent :

```go
func callWithRetry(url string) (*http.Response, error) {
    maxAttempts := 3
    baseTimeout := 2 * time.Second

    for attempt := 1; attempt <= maxAttempts; attempt++ {
        // Timeout croissant : 2s, 4s, 8s
        timeout := baseTimeout * time.Duration(1<<(attempt-1))

        ctx, cancel := context.WithTimeout(
            context.Background(),
            timeout
        )
        defer cancel()

        req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
        resp, err := http.DefaultClient.Do(req)

        if err == nil {
            return resp, nil
        }

        // Retry seulement sur timeout ou 5xx
        if ctx.Err() == context.DeadlineExceeded || isServerError(err) {
            if attempt < maxAttempts {
                time.Sleep(time.Second * time.Duration(attempt))
                continue
            }
        }

        return nil, err
    }

    return nil, fmt.Errorf("max retries exceeded")
}
```

### 3. Logging des timeouts

**Essentiel pour le debugging** :

```python
import logging
import time
from functools import wraps

def log_timeout(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        timeout = kwargs.get('timeout', 'unknown')

        try:
            result = func(*args, **kwargs)
            duration = time.time() - start

            # Alerte si proche du timeout (>80%)
            if isinstance(timeout, (int, float)) and duration > timeout * 0.8:
                logging.warning(
                    f"{func.__name__} took {duration:.2f}s "
                    f"(timeout: {timeout}s, utilization: {duration/timeout*100:.1f}%)"
                )

            return result

        except socket.timeout:
            duration = time.time() - start
            logging.error(
                f"{func.__name__} timeout after {duration:.2f}s "
                f"(configured: {timeout}s)"
            )
            raise

    return wrapper

@log_timeout
def fetch_data(url, timeout=10):
    return requests.get(url, timeout=timeout)
```

### 4. Deadline propagation (microservices)

Propager le budget temps restant entre services :

```go
// Service A reÃ§oit une requÃªte avec deadline globale
func (s *ServiceA) HandleRequest(ctx context.Context, req *Request) (*Response, error) {
    // VÃ©rifier le temps restant
    deadline, ok := ctx.Deadline()
    if !ok {
        // Pas de deadline, en crÃ©er une
        var cancel context.CancelFunc
        ctx, cancel = context.WithTimeout(ctx, 30*time.Second)
        defer cancel()
        deadline, _ = ctx.Deadline()
    }

    timeRemaining := time.Until(deadline)

    // Allouer 70% du temps restant au service B
    serviceBTimeout := timeRemaining * 7 / 10
    serviceBCtx, cancel := context.WithTimeout(ctx, serviceBTimeout)
    defer cancel()

    // Appel au service B avec le budget temps
    respB, err := s.serviceBClient.Call(serviceBCtx, ...)
    if err != nil {
        if ctx.Err() == context.DeadlineExceeded {
            return nil, fmt.Errorf("global deadline exceeded")
        }
        return nil, err
    }

    // Utiliser les 30% restants pour le traitement local
    return s.processLocally(respB)
}
```

### 5. Metrics et alerting

Monitorer les timeouts pour dÃ©tecter les problÃ¨mes :

```python
from prometheus_client import Counter, Histogram

timeout_counter = Counter(
    'http_requests_timeout_total',
    'Total number of timeout requests',
    ['service', 'endpoint']
)

request_duration = Histogram(
    'http_request_duration_seconds',
    'HTTP request latency',
    ['service', 'endpoint'],
    buckets=[0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 30.0]
)

def make_request(service, endpoint, timeout=10):
    start = time.time()

    try:
        response = requests.get(
            f"http://{service}{endpoint}",
            timeout=timeout
        )
        return response

    except requests.Timeout:
        timeout_counter.labels(
            service=service,
            endpoint=endpoint
        ).inc()
        raise

    finally:
        duration = time.time() - start
        request_duration.labels(
            service=service,
            endpoint=endpoint
        ).observe(duration)
```

**Alertes Prometheus** :
```yaml
groups:
  - name: timeout_alerts
    rules:
      # Taux de timeout > 5% sur 5 minutes
      - alert: HighTimeoutRate
        expr: |
          rate(http_requests_timeout_total[5m])
          /
          rate(http_requests_total[5m])
          > 0.05
        annotations:
          summary: "High timeout rate on {{ $labels.service }}"

      # P95 latency proche du timeout
      - alert: LatencyNearTimeout
        expr: |
          histogram_quantile(0.95,
            rate(http_request_duration_seconds_bucket[5m])
          ) > 8
        annotations:
          summary: "P95 latency near timeout threshold"
```

---

## PiÃ¨ges courants et anti-patterns

### âŒ 1. Timeout global trop court pour opÃ©rations composites

```python
# Anti-pattern
def complex_operation():
    # Chaque appel a un timeout de 5s
    user = fetch_user(timeout=5)           # Peut prendre 4s
    orders = fetch_orders(user.id, timeout=5)  # âŒ Timeout dÃ©jÃ  dÃ©passÃ© !
    return aggregate(user, orders)
```

**Solution** : Budget temps partagÃ©
```python
def complex_operation(total_timeout=10):
    start = time.time()
    remaining = lambda: total_timeout - (time.time() - start)

    user = fetch_user(timeout=remaining())

    if remaining() < 1:
        raise TimeoutError("Insufficient time for orders")

    orders = fetch_orders(user.id, timeout=remaining())
    return aggregate(user, orders)
```

### âŒ 2. Ignorer les timeout exceptions

```python
# Anti-pattern : timeout silencieux
try:
    response = requests.get(url, timeout=5)
except:
    pass  # âŒ On ignore l'erreur
```

**Solution** : GÃ©rer explicitement
```python
try:
    response = requests.get(url, timeout=5)
except requests.Timeout:
    logger.error(f"Timeout calling {url}")
    # Retry, fallback, ou propagate
    raise
except requests.RequestException as e:
    logger.error(f"Request failed: {e}")
    raise
```

### âŒ 3. Timeout incohÃ©rent avec retry

```python
# Anti-pattern : retry sans ajuster le timeout
@retry(tries=3, delay=2)
def fetch_data(url):
    return requests.get(url, timeout=30)
    # Timeout total potentiel : 90s + 4s de delay = 94s !
```

**Solution** : Timeout dÃ©croissant ou global
```python
def fetch_with_retries(url, max_total_time=30):
    attempts = 3
    timeout_per_attempt = max_total_time / attempts

    for attempt in range(attempts):
        try:
            return requests.get(url, timeout=timeout_per_attempt)
        except requests.Timeout:
            if attempt == attempts - 1:
                raise
            time.sleep(1)
```

### âŒ 4. MÃªme timeout pour tous les environnements

```python
# Anti-pattern : timeout hardcodÃ©
TIMEOUT = 5  # MÃªme valeur en dev, staging, prod
```

**Solution** : Configuration par environnement
```python
import os

TIMEOUT = {
    'development': 30,    # Dev : rÃ©seau local, peut debugger
    'staging': 10,        # Staging : rÃ©seau cloud, tests
    'production': 5       # Prod : strict
}.get(os.environ.get('ENV'), 10)
```

---

## Debugging des timeouts

### Identifier la cause d'un timeout

**Question** : Le timeout est-il dÃ» Ã  un problÃ¨me rÃ©seau ou applicatif ?

#### Technique 1 : Comparer connection vs read timeout

```python
import time
import requests

def diagnose_timeout(url):
    start = time.time()

    try:
        response = requests.get(
            url,
            timeout=(5, 30)  # (connect, read)
        )
        print(f"âœ“ Success in {time.time() - start:.2f}s")

    except requests.ConnectTimeout:
        print(f"âœ— Connection timeout after {time.time() - start:.2f}s")
        print("  â†’ ProblÃ¨me: serveur injoignable, firewall, DNS")

    except requests.ReadTimeout:
        print(f"âœ— Read timeout after {time.time() - start:.2f}s")
        print("  â†’ ProblÃ¨me: serveur lent, query lourde, deadlock")
```

#### Technique 2 : Analyse au niveau TCP avec tcpdump

```bash
# Capturer le trafic pendant un timeout
sudo tcpdump -i any -w timeout.pcap host api.example.com

# Analyser avec tshark
tshark -r timeout.pcap -Y "tcp.flags.syn==1"

# Patterns Ã  rechercher :
# - SYN sans SYN-ACK : serveur injoignable
# - SYN-ACK puis silence : application qui ne rÃ©pond pas
# - Retransmissions TCP : paquets perdus
# - Window size = 0 : flow control actif
```

#### Technique 3 : Monitoring avec strace (Linux)

```bash
# Tracer les syscalls rÃ©seau d'un process
strace -e trace=network -p <PID> 2>&1 | grep -E "connect|recv|send"

# Output exemple pour un timeout :
# connect(3, {sa_family=AF_INET, sin_port=htons(443)}, 16) = -1 EINPROGRESS
# [pause de 5s]
# connect(3, ...) = -1 ETIMEDOUT (Connection timed out)
```

---

## Checklist timeouts pour production

Avant de dÃ©ployer, vÃ©rifier :

- [ ] **Connection timeout** configurÃ© (gÃ©nÃ©ralement 2-10s)
- [ ] **Read timeout** configurÃ© selon le type d'opÃ©ration
- [ ] **Write timeout** configurÃ© pour uploads/bulk operations
- [ ] Timeouts **diffÃ©renciÃ©s** par type d'endpoint
- [ ] Timeouts **cohÃ©rents** dans l'architecture en cascade
- [ ] **Logging** des timeouts avec contexte (URL, durÃ©e, tentative)
- [ ] **Metrics** exposÃ©es (Prometheus, StatsD, etc.)
- [ ] **Alertes** configurÃ©es pour taux de timeout Ã©levÃ©
- [ ] **Tests** de charge incluant scÃ©narios de timeout
- [ ] **Documentation** des valeurs choisies et leur justification
- [ ] **Retry logic** compatible avec les timeouts
- [ ] **Fallbacks** dÃ©finis pour opÃ©rations non-critiques

---

## Conclusion

Les timeouts sont la **premiÃ¨re ligne de dÃ©fense** contre les dÃ©faillances rÃ©seau. Leur configuration correcte transforme une application fragile en un systÃ¨me robuste capable de survivre aux conditions rÃ©elles.

**Points clÃ©s Ã  retenir** :

1. **Trois types de timeout** : connection, read, write - chacun protÃ¨ge contre un mode de dÃ©faillance diffÃ©rent

2. **Pas de valeur universelle** : calibrer selon votre contexte (P99 Ã— 2 est un bon dÃ©part)

3. **Timeout en cascade** : `parent_timeout > child_timeout + overhead`

4. **Combiner avec retry** : timeout court + retry intelligent = robustesse

5. **Monitor et alerte** : un timeout est un signal, pas juste une erreur

**Prochaine Ã©tape** : Les timeouts dÃ©tectent les problÃ¨mes, mais que faire ensuite ? La section suivante explore les **stratÃ©gies de retry** pour rÃ©cupÃ©rer automatiquement des Ã©checs transitoires.

---


â­ï¸ [Retry logic et backoff exponentiel](/08-programmation-reseau/08.2-retry-logic-backoff.md)
