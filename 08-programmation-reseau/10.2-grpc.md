üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.10.2 gRPC : HTTP/2 et Protocol Buffers

# Table des mati√®res

## [Introduction](#introduction-1)

## [Protocol Buffers : la fondation de gRPC](#protocol-buffers--la-fondation-de-grpc-1)

### [Qu'est-ce que Protocol Buffers ?](#quest-ce-que-protocol-buffers--1)

### [Anatomie d'un fichier .proto](#anatomie-dun-fichier-proto-1)

### [Num√©rotation des champs : importance critique](#num%C3%A9rotation-des-champs--importance-critique-1)

### [S√©rialisation binaire : efficacit√© en pratique](#s%C3%A9rialisation-binaire--efficacit%C3%A9-en-pratique-1)

### [R√©trocompatibilit√© et √©volution du sch√©ma](#r%C3%A9trocompatibilit%C3%A9-et-%C3%A9volution-du-sch%C3%A9ma-1)

### [G√©n√©ration de code](#g%C3%A9n%C3%A9ration-de-code-1)

## [HTTP/2 : le moteur de transport de gRPC](#http2--le-moteur-de-transport-de-grpc-1)

### [Pourquoi HTTP/2 ?](#pourquoi-http2--1)

### [Multiplexage : r√©volution pour les RPC](#multiplexage--r%C3%A9volution-pour-les-rpc-1)

### [Frames HTTP/2 et gRPC](#frames-http2-et-grpc-1)

### [Contr√¥le de flux et backpressure](#contr%C3%B4le-de-flux-et-backpressure-1)

## [Types de communication gRPC](#types-de-communication-grpc-1)

### [1. Unary RPC : Requ√™te-R√©ponse simple](#1-unary-rpc--requ%C3%AAte-r%C3%A9ponse-simple-1)

### [2. Server Streaming : Une requ√™te, plusieurs r√©ponses](#2-server-streaming--une-requ%C3%AAte-plusieurs-r%C3%A9ponses-1)

### [3. Client Streaming : Plusieurs requ√™tes, une r√©ponse](#3-client-streaming--plusieurs-requ%C3%AAtes-une-r%C3%A9ponse-1)

### [4. Bidirectional Streaming : Communication full-duplex](#4-bidirectional-streaming--communication-full-duplex-1)

## [Gestion des erreurs et codes de statut](#gestion-des-erreurs-et-codes-de-statut-1)

### [Codes de statut gRPC](#codes-de-statut-grpc-1)

### [Erreurs enrichies avec details](#erreurs-enrichies-avec-details-1)

## [Metadata et contexte](#metadata-et-contexte-1)

### [Envoi de metadata (client)](#envoi-de-metadata-client-1)

### [R√©ception de metadata (serveur)](#r%C3%A9ception-de-metadata-serveur-1)

### [Envoi de metadata du serveur vers le client](#envoi-de-metadata-du-serveur-vers-le-client-1)

## [Interceptors : Middleware gRPC](#interceptors--middleware-grpc-1)

### [Unary Interceptor (serveur)](#unary-interceptor-serveur-1)

### [Stream Interceptor (serveur)](#stream-interceptor-serveur-1)

### [Client Interceptors](#client-interceptors-1)

## [Performance et benchmarks](#performance-et-benchmarks-1)

### [Comparaison REST vs gRPC](#comparaison-rest-vs-grpc-1)

### [Optimisations r√©seau](#optimisations-r%C3%A9seau-1)

## [D√©ploiement et consid√©rations de production](#d%C3%A9ploiement-et-consid%C3%A9rations-de-production-1)

### [TLS / mTLS](#tls--mtls-1)

### [Health checking](#health-checking-1)

### [Reflection pour debugging](#reflection-pour-debugging-1)

### [Observabilit√©](#observabilit%C3%A9-1)

## [Limitations et cas o√π ne pas utiliser gRPC](#limitations-et-cas-o%C3%B9-ne-pas-utiliser-grpc-1)

### [1. Support navigateur limit√©](#1-support-navigateur-limit%C3%A9-1)

### [2. Debugging plus complexe](#2-debugging-plus-complexe-1)

### [3. Pas de caching interm√©diaire simple](#3-pas-de-caching-interm%C3%A9diaire-simple-1)

### [4. APIs publiques](#4-apis-publiques-1)

## [Cas d'usage r√©els](#cas-dusage-r%C3%A9els-1)

### [1. Microservices backend (Netflix, Uber)](#1-microservices-backend-netflix-uber-1)

### [2. Syst√®mes distribu√©s temps r√©el](#2-syst%C3%A8mes-distribu%C3%A9s-temps-r%C3%A9el-1)

### [3. Mobile backends](#3-mobile-backends-1)

## [Conclusion](#conclusion-1)

---

**Temps de lecture estim√©** : 40-45 minutes
**Types de RPC** : 4 (Unary, Server streaming, Client streaming, Bidirectional)
**Codes de statut gRPC** : 17
**Exemples de code** : Go, Python, JavaScript
**Benchmarks** : REST vs gRPC (7-10x plus rapide)
**Cas d'usage** : Netflix, Uber, microservices

---

## Introduction

gRPC (gRPC Remote Procedure Call) est un framework RPC moderne d√©velopp√© par Google en 2015 et aujourd'hui sous l'√©gide de la Cloud Native Computing Foundation (CNCF). Contrairement √† REST qui utilise une approche orient√©e ressources, gRPC adopte une approche orient√©e **actions** : le client invoque directement des m√©thodes sur le serveur comme si c'√©tait un objet local.

gRPC s'appuie sur deux technologies cl√©s :
- **Protocol Buffers (protobuf)** : Format de s√©rialisation binaire compact et efficace
- **HTTP/2** : Protocole de transport moderne avec multiplexage et streaming

Cette combinaison offre des performances sup√©rieures √† REST/JSON pour les communications service-to-service, particuli√®rement dans les architectures microservices.

## Protocol Buffers : la fondation de gRPC

### Qu'est-ce que Protocol Buffers ?

Protocol Buffers est un langage de d√©finition d'interface (IDL) et un format de s√©rialisation d√©velopp√© par Google. Il permet de d√©finir la structure des donn√©es de mani√®re ind√©pendante du langage, puis de g√©n√©rer automatiquement du code pour s√©rialiser/d√©s√©rialiser ces donn√©es dans diff√©rents langages.

**Philosophie :** "Define once, use everywhere"

### Anatomie d'un fichier .proto

```protobuf
// user.proto
syntax = "proto3";  // Version de protobuf

package userservice;  // Namespace

option go_package = "github.com/company/userservice/pb";

// Import d'autres fichiers proto
import "google/protobuf/timestamp.proto";

// Message = structure de donn√©es
message User {
  int64 id = 1;              // Num√©ro de champ unique
  string username = 2;
  string email = 3;
  bool active = 4;
  google.protobuf.Timestamp created_at = 5;

  // Types de base : int32, int64, uint32, uint64, sint32, sint64,
  //                 fixed32, fixed64, sfixed32, sfixed64,
  //                 float, double, bool, string, bytes

  // Enum
  enum Role {
    UNKNOWN = 0;  // Premi√®re valeur doit √™tre 0
    USER = 1;
    ADMIN = 2;
    MODERATOR = 3;
  }
  Role role = 6;

  // Champs r√©p√©t√©s (listes)
  repeated string tags = 7;

  // Champs optionnels (proto3)
  optional string phone = 8;

  // Messages imbriqu√©s
  message Address {
    string street = 1;
    string city = 2;
    string country = 3;
  }
  Address address = 9;

  // Map
  map<string, string> metadata = 10;
}

// Service = d√©finition des RPC
service UserService {
  // Unary RPC : 1 requ√™te ‚Üí 1 r√©ponse
  rpc GetUser(GetUserRequest) returns (User);

  // Server streaming : 1 requ√™te ‚Üí N r√©ponses
  rpc ListUsers(ListUsersRequest) returns (stream User);

  // Client streaming : N requ√™tes ‚Üí 1 r√©ponse
  rpc CreateUsers(stream User) returns (CreateUsersResponse);

  // Bidirectional streaming : N requ√™tes ‚Üî N r√©ponses
  rpc Chat(stream ChatMessage) returns (stream ChatMessage);
}

message GetUserRequest {
  int64 user_id = 1;
}

message ListUsersRequest {
  int32 page_size = 1;
  string page_token = 2;
}

message CreateUsersResponse {
  int32 created_count = 1;
  repeated int64 user_ids = 2;
}

message ChatMessage {
  int64 user_id = 1;
  string message = 2;
  google.protobuf.Timestamp timestamp = 3;
}
```

### Num√©rotation des champs : importance critique

Chaque champ a un **num√©ro unique** qui est utilis√© dans la s√©rialisation binaire. Ce num√©ro ne doit **jamais** √™tre r√©utilis√©.

```protobuf
message User {
  int64 id = 1;
  string username = 2;
  string email = 3;
  // Ne JAMAIS r√©utiliser 1, 2, 3 m√™me si on supprime ces champs
}
```

**Impact r√©seau :**

```
Repr√©sentation binaire :
- Champs 1-15 : 1 byte pour le tag (num√©ro + type)
- Champs 16-2047 : 2 bytes pour le tag
- Champs 2048+ : 3+ bytes

Recommandation : Utiliser 1-15 pour les champs les plus fr√©quents
```

### S√©rialisation binaire : efficacit√© en pratique

**Exemple - Comparaison JSON vs Protobuf :**

```json
// JSON (152 bytes)
{
  "id": 123456,
  "username": "john_doe",
  "email": "john@example.com",
  "active": true,
  "created_at": "2024-01-15T10:30:00Z"
}
```

```
// Protobuf (binaire, ~45 bytes)
08 C0 C4 07 12 08 6A 6F 68 6E 5F 64 6F 65 1A 11 6A 6F 68 6E 40 65 78 61 6D 70 6C 65 2E 63 6F 6D 20 01 2A 0A 08 80 C4 07 10 00

D√©composition :
08        - Tag pour field 1 (id), type varint
C0 C4 07  - Valeur 123456 en varint (3 bytes au lieu de 8)
12        - Tag pour field 2 (username), type string
08        - Longueur de la string (8 bytes)
6A 6F ... - "john_doe" en UTF-8
...

√âconomie : 70% de r√©duction de taille
```

**Encodage Varint :**

Les entiers utilisent un encodage √† longueur variable pour minimiser l'espace.

```
Nombre     Bytes requis    Taille JSON
0-127      1 byte         1-3 bytes
128-16383  2 bytes        4-5 bytes
16384+     3+ bytes       5+ bytes

Exemple :
123456 (JSON: 6 bytes "123456")
‚Üí Varint: 3 bytes (C0 C4 07)
```

### R√©trocompatibilit√© et √©volution du sch√©ma

**R√®gles de compatibilit√© :**

```protobuf
// Version 1
message User {
  int64 id = 1;
  string username = 2;
}

// Version 2 (compatible)
message User {
  int64 id = 1;
  string username = 2;
  string email = 3;        // ‚úÖ Nouveau champ OK
  optional string phone = 4; // ‚úÖ Optionnel OK
}

// Version 3 (compatible)
message User {
  int64 id = 1;
  string username = 2;
  string email = 3;
  // phone supprim√© mais num√©ro 4 jamais r√©utilis√©
  reserved 4;              // ‚úÖ R√©servation du num√©ro
  reserved "phone";        // ‚úÖ R√©servation du nom
  string full_name = 5;    // ‚úÖ Nouveau champ
}
```

**Impact sur le r√©seau :**

```
Client v1 (ne conna√Æt que id, username)
‚Üí Re√ßoit message v2 (id, username, email, phone)
‚Üí D√©code id et username, ignore email et phone
‚Üí Pas d'erreur, compatibilit√© forward

Serveur v2 (conna√Æt id, username, email, phone)
‚Üí Re√ßoit message v1 (id, username seulement)
‚Üí email et phone re√ßoivent valeurs par d√©faut (string vide, null)
‚Üí Pas d'erreur, compatibilit√© backward
```

### G√©n√©ration de code

Protocol Buffers g√©n√®re automatiquement du code dans le langage cible.

```bash
# Installation du compilateur protobuf
# Ubuntu/Debian
sudo apt-get install protobuf-compiler

# macOS
brew install protobuf

# G√©n√©ration de code
protoc --go_out=. --go_opt=paths=source_relative \
       --go-grpc_out=. --go-grpc_opt=paths=source_relative \
       user.proto
```

**Code g√©n√©r√© en Go :**

```go
// user.pb.go (g√©n√©r√© automatiquement)
type User struct {
    Id        int64     `protobuf:"varint,1,opt,name=id,proto3"`
    Username  string    `protobuf:"bytes,2,opt,name=username,proto3"`
    Email     string    `protobuf:"bytes,3,opt,name=email,proto3"`
    Active    bool      `protobuf:"varint,4,opt,name=active,proto3"`
    CreatedAt *timestamp.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3"`
}

// M√©thodes de s√©rialisation g√©n√©r√©es
func (x *User) Marshal() ([]byte, error)
func (x *User) Unmarshal(b []byte) error
func (x *User) ProtoMessage() {}
```

**Code g√©n√©r√© en Python :**

```python
# user_pb2.py (g√©n√©r√© automatiquement)
class User(message.Message):
    id = field(1, type=int64)
    username = field(2, type=str)
    email = field(3, type=str)
    active = field(4, type=bool)
    created_at = field(5, type=Timestamp)

    def SerializeToString(self) -> bytes: ...
    def ParseFromString(self, data: bytes) -> None: ...
```

## HTTP/2 : le moteur de transport de gRPC

### Pourquoi HTTP/2 ?

gRPC n√©cessite HTTP/2 pour plusieurs raisons critiques :

1. **Multiplexage** : Multiples RPC simultan√©s sur une seule connexion TCP
2. **Server Push** : Le serveur peut envoyer des donn√©es sans requ√™te explicite (streaming)
3. **Compression des headers** : Protocole HPACK r√©duit l'overhead
4. **Binaire** : Format plus efficace que texte HTTP/1.1
5. **Contr√¥le de flux** : Gestion de la congestion au niveau stream

### Multiplexage : r√©volution pour les RPC

**HTTP/1.1 (probl√®me) :**

```
Client                    Serveur
  |                          |
  |------ RPC1 (GetUser) --->|
  |                          | (traitement...)
  |<----- Response 1 --------|
  |                          |
  |------ RPC2 (ListUsers) ->|
  |                          | (traitement...)
  |<----- Response 2 --------|

Probl√®me : Head-of-line blocking
RPC2 attend que RPC1 soit compl√©t√©
```

**HTTP/2 (solution) :**

```
Client                    Serveur
  |                          |
  |------ RPC1 [Stream 1] -->|
  |------ RPC2 [Stream 3] -->|
  |                          | (traitement parall√®le)
  |<----- Resp2 [Stream 3] --|
  |<----- Resp1 [Stream 1] --|

Avantage : Multiples RPC simultan√©s
Une seule connexion TCP
R√©ponses peuvent arriver dans n'importe quel ordre
```

**Benchmark concret :**

```
Sc√©nario : 100 RPC courts (10ms chacun)

HTTP/1.1 avec keep-alive :
- 1 connexion TCP r√©utilis√©e
- RPC s√©quentiels
- Temps total : 100 √ó 10ms = 1000ms

HTTP/1.1 avec connexions parall√®les (6 max navigateur) :
- 6 connexions TCP
- Temps total : (100 √∑ 6) √ó 10ms ‚âà 167ms
- Overhead : 6 handshakes TCP + TLS

HTTP/2 (gRPC) :
- 1 connexion TCP
- 100 streams multiplex√©s
- Temps total : ~15-20ms (parall√®le complet)
- Overhead : 1 handshake TCP + TLS

Am√©lioration : 8-10x plus rapide
```

### Frames HTTP/2 et gRPC

HTTP/2 d√©coupe les donn√©es en **frames** :

```
Connexion HTTP/2
‚îú‚îÄ Stream 1 (RPC GetUser)
‚îÇ  ‚îú‚îÄ HEADERS frame (metadata)
‚îÇ  ‚îú‚îÄ DATA frame (message protobuf)
‚îÇ  ‚îî‚îÄ HEADERS frame (trailers)
‚îú‚îÄ Stream 3 (RPC ListUsers)
‚îÇ  ‚îú‚îÄ HEADERS frame
‚îÇ  ‚îú‚îÄ DATA frame 1
‚îÇ  ‚îú‚îÄ DATA frame 2
‚îÇ  ‚îú‚îÄ DATA frame 3 (streaming)
‚îÇ  ‚îî‚îÄ HEADERS frame
‚îî‚îÄ Stream 5 (RPC CreateUser)
   ‚îú‚îÄ HEADERS frame
   ‚îú‚îÄ DATA frame
   ‚îî‚îÄ HEADERS frame
```

**Structure d'un message gRPC sur HTTP/2 :**

```
POST /userservice.UserService/GetUser HTTP/2
:method: POST
:scheme: https
:path: /userservice.UserService/GetUser
:authority: api.example.com
content-type: application/grpc+proto
grpc-timeout: 1S
authorization: Bearer <token>

[Binaire Protobuf compress√©]
grpc-length: 45
grpc-message: <donn√©es>

grpc-status: 0
grpc-message: OK
```

### Contr√¥le de flux et backpressure

HTTP/2 g√®re le contr√¥le de flux au niveau stream, essentiel pour le streaming gRPC.

```go
// Serveur Go - Streaming avec backpressure
func (s *server) ListUsers(req *pb.ListUsersRequest,
                           stream pb.UserService_ListUsersServer) error {
    users := s.db.GetAllUsers()

    for _, user := range users {
        // HTTP/2 g√®re automatiquement le flow control
        // Si le client est lent, Send() bloque
        if err := stream.Send(user); err != nil {
            return err
        }

        // Le serveur s'adapte √† la vitesse du client
        // Pas de buffer overflow
    }

    return nil
}
```

**M√©canisme HTTP/2 :**

```
Client (lent)                           Serveur (rapide)
  |                                         |
  |<------ DATA frame 1 (user 1) -----------|
  |                                         |
  | (traitement lent...)                    |
  |                                         | (attend)
  |                                         |
  |------ WINDOW_UPDATE (+1) -------------> |
  |                                         |
  |<------ DATA frame 2 (user 2) -----------|

Le serveur envoie seulement quand le client est pr√™t
Backpressure naturel sans code applicatif
```

## Types de communication gRPC

gRPC supporte quatre patterns de communication, tous sur HTTP/2.

### 1. Unary RPC : Requ√™te-R√©ponse simple

**Le plus courant, √©quivalent √† REST :**

```protobuf
service UserService {
  rpc GetUser(GetUserRequest) returns (User);
}
```

**Impl√©mentation serveur Go :**

```go
package main

import (
    "context"
    "log"
    "net"

    "google.golang.org/grpc"
    pb "github.com/company/userservice/pb"
)

type server struct {
    pb.UnimplementedUserServiceServer
}

func (s *server) GetUser(ctx context.Context,
                         req *pb.GetUserRequest) (*pb.User, error) {
    // Validation
    if req.UserId <= 0 {
        return nil, status.Error(codes.InvalidArgument, "invalid user ID")
    }

    // R√©cup√©ration depuis la base
    user, err := db.GetUser(req.UserId)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, status.Error(codes.NotFound, "user not found")
        }
        return nil, status.Error(codes.Internal, "database error")
    }

    // Conversion vers protobuf
    return &pb.User{
        Id:       user.ID,
        Username: user.Username,
        Email:    user.Email,
        Active:   user.Active,
    }, nil
}

func main() {
    listener, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatal(err)
    }

    grpcServer := grpc.NewServer()
    pb.RegisterUserServiceServer(grpcServer, &server{})

    log.Println("gRPC server listening on :50051")
    if err := grpcServer.Serve(listener); err != nil {
        log.Fatal(err)
    }
}
```

**Client Go :**

```go
package main

import (
    "context"
    "log"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    pb "github.com/company/userservice/pb"
)

func main() {
    // Connexion au serveur gRPC
    conn, err := grpc.Dial("localhost:50051",
        grpc.WithTransportCredentials(insecure.NewCredentials()),
    )
    if err != nil {
        log.Fatal(err)
    }
    defer conn.Close()

    client := pb.NewUserServiceClient(conn)

    // Appel RPC avec timeout
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel()

    user, err := client.GetUser(ctx, &pb.GetUserRequest{
        UserId: 123,
    })
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("User: %+v", user)
}
```

**Impl√©mentation Python :**

```python
# server.py
import grpc
from concurrent import futures
import user_pb2
import user_pb2_grpc

class UserService(user_pb2_grpc.UserServiceServicer):
    def GetUser(self, request, context):
        # Validation
        if request.user_id <= 0:
            context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
            context.set_details('Invalid user ID')
            return user_pb2.User()

        # R√©cup√©ration depuis la base
        try:
            user_data = db.get_user(request.user_id)
        except UserNotFound:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details('User not found')
            return user_pb2.User()

        # Retour
        return user_pb2.User(
            id=user_data['id'],
            username=user_data['username'],
            email=user_data['email'],
            active=user_data['active']
        )

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    user_pb2_grpc.add_UserServiceServicer_to_server(UserService(), server)
    server.add_insecure_port('[::]:50051')
    server.start()
    print("gRPC server listening on :50051")
    server.wait_for_termination()

if __name__ == '__main__':
    serve()
```

```python
# client.py
import grpc
import user_pb2
import user_pb2_grpc

def main():
    channel = grpc.insecure_channel('localhost:50051')
    client = user_pb2_grpc.UserServiceStub(channel)

    # Appel RPC
    try:
        response = client.GetUser(
            user_pb2.GetUserRequest(user_id=123),
            timeout=1.0
        )
        print(f"User: {response}")
    except grpc.RpcError as e:
        print(f"Error: {e.code()} - {e.details()}")

if __name__ == '__main__':
    main()
```

**Trace r√©seau d'un Unary RPC :**

```
Client ‚Üí Serveur
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
HEADERS frame (Stream 1)
  :method = POST
  :scheme = https
  :path = /userservice.UserService/GetUser
  content-type = application/grpc+proto
  grpc-timeout = 1S

DATA frame (Stream 1)
  [5 bytes] - Compressed flag + Length
  [45 bytes] - Protobuf message (GetUserRequest)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Serveur ‚Üí Client

DATA frame (Stream 1)
  [5 bytes] - Compressed flag + Length
  [78 bytes] - Protobuf message (User)

HEADERS frame (Stream 1, END_STREAM)
  grpc-status = 0
  grpc-message =

Stream ferm√©
Connexion HTTP/2 reste ouverte pour futurs RPC
```

### 2. Server Streaming : Une requ√™te, plusieurs r√©ponses

**Cas d'usage : Log tailing, notifications, grandes listes**

```protobuf
service UserService {
  rpc ListUsers(ListUsersRequest) returns (stream User);
}
```

**Serveur Go :**

```go
func (s *server) ListUsers(req *pb.ListUsersRequest,
                           stream pb.UserService_ListUsersServer) error {
    // Pagination
    pageSize := req.PageSize
    if pageSize <= 0 || pageSize > 100 {
        pageSize = 50
    }

    offset := 0
    for {
        // R√©cup√©rer un batch d'utilisateurs
        users, err := db.GetUsers(offset, pageSize)
        if err != nil {
            return status.Error(codes.Internal, err.Error())
        }

        // Fin si plus de r√©sultats
        if len(users) == 0 {
            break
        }

        // Envoyer chaque utilisateur via le stream
        for _, user := range users {
            // V√©rifier si le client a annul√©
            select {
            case <-stream.Context().Done():
                return status.Error(codes.Canceled, "client canceled")
            default:
            }

            // Envoi
            if err := stream.Send(&pb.User{
                Id:       user.ID,
                Username: user.Username,
                Email:    user.Email,
            }); err != nil {
                return err
            }
        }

        offset += len(users)

        // Si moins que pageSize, on a tout r√©cup√©r√©
        if len(users) < int(pageSize) {
            break
        }
    }

    return nil
}
```

**Client Go :**

```go
func main() {
    conn, _ := grpc.Dial("localhost:50051",
        grpc.WithTransportCredentials(insecure.NewCredentials()))
    defer conn.Close()

    client := pb.NewUserServiceClient(conn)

    // D√©marrer le streaming
    stream, err := client.ListUsers(context.Background(),
        &pb.ListUsersRequest{PageSize: 50})
    if err != nil {
        log.Fatal(err)
    }

    // Recevoir les utilisateurs au fur et √† mesure
    for {
        user, err := stream.Recv()

        if err == io.EOF {
            // Fin du stream
            break
        }

        if err != nil {
            log.Fatal(err)
        }

        // Traiter l'utilisateur
        log.Printf("Received user: %s", user.Username)
    }
}
```

**Cas d'usage r√©el - Service de logs :**

```protobuf
service LogService {
  rpc StreamLogs(StreamLogsRequest) returns (stream LogEntry);
}

message StreamLogsRequest {
  string service_name = 1;
  string level = 2;  // ERROR, WARN, INFO, DEBUG
  google.protobuf.Timestamp since = 3;
}

message LogEntry {
  google.protobuf.Timestamp timestamp = 1;
  string level = 2;
  string service = 3;
  string message = 4;
  map<string, string> metadata = 5;
}
```

```go
// Serveur - Stream de logs en temps r√©el
func (s *server) StreamLogs(req *pb.StreamLogsRequest,
                            stream pb.LogService_StreamLogsServer) error {
    // S'abonner au flux de logs
    logChan := s.logAggregator.Subscribe(req.ServiceName, req.Level)
    defer s.logAggregator.Unsubscribe(logChan)

    for {
        select {
        case <-stream.Context().Done():
            return nil
        case logEntry := <-logChan:
            if err := stream.Send(logEntry); err != nil {
                return err
            }
        }
    }
}
```

**Avantages r√©seau :**
- Une seule connexion TCP/TLS pour des milliers de messages
- Backpressure automatique (HTTP/2 flow control)
- Client peut annuler √† tout moment sans laisser de ressources pendantes

### 3. Client Streaming : Plusieurs requ√™tes, une r√©ponse

**Cas d'usage : Upload de fichier, batch insert, metrics collection**

```protobuf
service FileService {
  rpc UploadFile(stream FileChunk) returns (UploadResponse);
}

message FileChunk {
  bytes data = 1;
  string filename = 2;  // Seulement dans le premier chunk
}

message UploadResponse {
  string file_id = 1;
  int64 size = 2;
}
```

**Serveur Go :**

```go
func (s *server) UploadFile(stream pb.FileService_UploadFileServer) error {
    var filename string
    var totalSize int64
    var fileData bytes.Buffer

    for {
        chunk, err := stream.Recv()

        if err == io.EOF {
            // Client a fini d'envoyer
            // Sauvegarder le fichier
            fileID, err := s.storage.Save(filename, fileData.Bytes())
            if err != nil {
                return status.Error(codes.Internal, "failed to save file")
            }

            // Retourner la r√©ponse unique
            return stream.SendAndClose(&pb.UploadResponse{
                FileId: fileID,
                Size:   totalSize,
            })
        }

        if err != nil {
            return status.Error(codes.Internal, err.Error())
        }

        // Premier chunk contient le nom de fichier
        if filename == "" {
            filename = chunk.Filename
        }

        // Accumuler les donn√©es
        fileData.Write(chunk.Data)
        totalSize += int64(len(chunk.Data))
    }
}
```

**Client Go :**

```go
func uploadFile(client pb.FileServiceClient, filepath string) error {
    file, err := os.Open(filepath)
    if err != nil {
        return err
    }
    defer file.Close()

    // D√©marrer le stream
    stream, err := client.UploadFile(context.Background())
    if err != nil {
        return err
    }

    // Lire et envoyer par chunks de 64KB
    buffer := make([]byte, 64*1024)
    isFirst := true

    for {
        n, err := file.Read(buffer)

        if err == io.EOF {
            break
        }

        if err != nil {
            return err
        }

        chunk := &pb.FileChunk{
            Data: buffer[:n],
        }

        // Premier chunk contient le nom de fichier
        if isFirst {
            chunk.Filename = filepath
            isFirst = false
        }

        if err := stream.Send(chunk); err != nil {
            return err
        }
    }

    // Fermer le stream et recevoir la r√©ponse
    response, err := stream.CloseAndRecv()
    if err != nil {
        return err
    }

    log.Printf("File uploaded: ID=%s, Size=%d", response.FileId, response.Size)
    return nil
}
```

**Cas d'usage - Batch metrics :**

```protobuf
service MetricsService {
  rpc RecordMetrics(stream Metric) returns (RecordResponse);
}

message Metric {
  string name = 1;
  double value = 2;
  google.protobuf.Timestamp timestamp = 3;
  map<string, string> tags = 4;
}
```

```python
# Client Python - Envoi de m√©triques en batch
def record_metrics(client, metrics_queue):
    def metric_generator():
        while True:
            metric = metrics_queue.get()
            if metric is None:  # Sentinel
                break
            yield metric

    response = client.RecordMetrics(metric_generator())
    print(f"Recorded {response.count} metrics")

# Les m√©triques sont stream√©es au serveur au fur et √† mesure
# Pas besoin d'attendre d'avoir toutes les m√©triques
# √âconomie de m√©moire c√¥t√© client
```

### 4. Bidirectional Streaming : Communication full-duplex

**Cas d'usage : Chat, gaming, collaboration temps r√©el**

```protobuf
service ChatService {
  rpc Chat(stream ChatMessage) returns (stream ChatMessage);
}

message ChatMessage {
  int64 user_id = 1;
  string username = 2;
  string message = 3;
  google.protobuf.Timestamp timestamp = 4;

  enum MessageType {
    TEXT = 0;
    JOIN = 1;
    LEAVE = 2;
  }
  MessageType type = 5;
}
```

**Serveur Go :**

```go
type chatRoom struct {
    mu      sync.RWMutex
    clients map[int64]pb.ChatService_ChatServer
}

func (s *server) Chat(stream pb.ChatService_ChatServer) error {
    var userID int64

    // Goroutine pour recevoir les messages du client
    go func() {
        for {
            msg, err := stream.Recv()
            if err == io.EOF {
                return
            }
            if err != nil {
                log.Printf("Error receiving: %v", err)
                return
            }

            userID = msg.UserId

            // Broadcaster le message √† tous les clients
            s.room.broadcast(msg)
        }
    }()

    // Ajouter le client √† la room
    s.room.addClient(userID, stream)
    defer s.room.removeClient(userID)

    // Garder la connexion ouverte
    <-stream.Context().Done()
    return nil
}

func (r *chatRoom) broadcast(msg *pb.ChatMessage) {
    r.mu.RLock()
    defer r.mu.RUnlock()

    for clientID, stream := range r.clients {
        // Ne pas renvoyer au sender
        if clientID == msg.UserId {
            continue
        }

        if err := stream.Send(msg); err != nil {
            log.Printf("Error sending to %d: %v", clientID, err)
        }
    }
}
```

**Client Go :**

```go
func chat(client pb.ChatServiceClient, userID int64, username string) {
    stream, err := client.Chat(context.Background())
    if err != nil {
        log.Fatal(err)
    }

    // Goroutine pour recevoir les messages
    go func() {
        for {
            msg, err := stream.Recv()
            if err == io.EOF {
                return
            }
            if err != nil {
                log.Printf("Error: %v", err)
                return
            }

            fmt.Printf("[%s] %s: %s\n",
                msg.Timestamp.AsTime().Format("15:04:05"),
                msg.Username,
                msg.Message)
        }
    }()

    // Message de join
    stream.Send(&pb.ChatMessage{
        UserId:   userID,
        Username: username,
        Type:     pb.ChatMessage_JOIN,
    })

    // Lire depuis stdin et envoyer
    scanner := bufio.NewScanner(os.Stdin)
    for scanner.Scan() {
        text := scanner.Text()

        stream.Send(&pb.ChatMessage{
            UserId:   userID,
            Username: username,
            Message:  text,
            Type:     pb.ChatMessage_TEXT,
            Timestamp: timestamppb.Now(),
        })
    }

    // Cleanup
    stream.CloseSend()
}
```

**Avantages r√©seau du bidirectionnel :**

```
Comparaison avec WebSocket :

WebSocket :
- Protocole s√©par√© de HTTP
- Upgrade depuis HTTP/1.1
- Pas de multiplexage natif
- Messages texte ou binaire (pas de structure)

gRPC Bidirectional :
- Utilise HTTP/2 (m√™me protocole)
- Multiplexage natif (plusieurs chats sur une connexion)
- Messages structur√©s (Protobuf)
- Typage fort
- G√©n√©ration de code client/serveur

Cas d'usage : Chat multi-room
WebSocket : 1 connexion par room (ou multiplexage manuel)
gRPC : 1 connexion, N streams (un par room)
```

## Gestion des erreurs et codes de statut

gRPC d√©finit des codes de statut standardis√©s, plus pr√©cis que HTTP.

### Codes de statut gRPC

```
OK (0)                    - Succ√®s
CANCELED (1)              - Op√©ration annul√©e par le client
UNKNOWN (2)               - Erreur inconnue
INVALID_ARGUMENT (3)      - Argument invalide
DEADLINE_EXCEEDED (4)     - Timeout d√©pass√©
NOT_FOUND (5)             - Ressource non trouv√©e
ALREADY_EXISTS (6)        - Ressource d√©j√† existante
PERMISSION_DENIED (7)     - Permission refus√©e
RESOURCE_EXHAUSTED (8)    - Quota d√©pass√©
FAILED_PRECONDITION (9)   - Pr√©condition √©chou√©e
ABORTED (10)              - Op√©ration avort√©e
OUT_OF_RANGE (11)         - Param√®tre hors limites
UNIMPLEMENTED (12)        - M√©thode non impl√©ment√©e
INTERNAL (13)             - Erreur interne serveur
UNAVAILABLE (14)          - Service indisponible
DATA_LOSS (15)            - Perte de donn√©es
UNAUTHENTICATED (16)      - Non authentifi√©
```

**Utilisation en Go :**

```go
import "google.golang.org/grpc/status"
import "google.golang.org/grpc/codes"

func (s *server) GetUser(ctx context.Context,
                         req *pb.GetUserRequest) (*pb.User, error) {
    // Validation
    if req.UserId <= 0 {
        return nil, status.Error(codes.InvalidArgument,
            "user ID must be positive")
    }

    // V√©rification de permission
    if !hasPermission(ctx, req.UserId) {
        return nil, status.Error(codes.PermissionDenied,
            "insufficient permissions")
    }

    // Recherche
    user, err := db.GetUser(req.UserId)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, status.Error(codes.NotFound,
                "user not found")
        }
        // Erreur interne
        log.Printf("Database error: %v", err)
        return nil, status.Error(codes.Internal,
            "internal server error")
    }

    return user, nil
}
```

**Gestion c√¥t√© client :**

```go
user, err := client.GetUser(ctx, req)
if err != nil {
    // Extraire le code de statut
    st, ok := status.FromError(err)
    if !ok {
        // Erreur non-gRPC
        log.Fatal("unexpected error:", err)
    }

    switch st.Code() {
    case codes.NotFound:
        fmt.Println("User not found")
    case codes.PermissionDenied:
        fmt.Println("Permission denied")
    case codes.InvalidArgument:
        fmt.Printf("Invalid argument: %s\n", st.Message())
    case codes.Unavailable:
        fmt.Println("Service unavailable, retrying...")
        // Retry logic
    default:
        log.Printf("Error: %s (%s)", st.Message(), st.Code())
    }

    return
}
```

### Erreurs enrichies avec details

gRPC permet d'attacher des d√©tails structur√©s aux erreurs.

```go
import "google.golang.org/genproto/googleapis/rpc/errdetails"

func (s *server) CreateUser(ctx context.Context,
                            req *pb.CreateUserRequest) (*pb.User, error) {
    // Validation multiple
    var violations []*errdetails.BadRequest_FieldViolation

    if len(req.Username) < 3 {
        violations = append(violations, &errdetails.BadRequest_FieldViolation{
            Field:       "username",
            Description: "must be at least 3 characters",
        })
    }

    if !isValidEmail(req.Email) {
        violations = append(violations, &errdetails.BadRequest_FieldViolation{
            Field:       "email",
            Description: "invalid email format",
        })
    }

    if len(violations) > 0 {
        // Cr√©er une erreur enrichie
        st := status.New(codes.InvalidArgument, "validation failed")

        br := &errdetails.BadRequest{
            FieldViolations: violations,
        }

        st, err := st.WithDetails(br)
        if err != nil {
            return nil, status.Error(codes.Internal, "failed to create error")
        }

        return nil, st.Err()
    }

    // Cr√©ation...
    return user, nil
}
```

**Client :**

```go
user, err := client.CreateUser(ctx, req)
if err != nil {
    st := status.Convert(err)

    for _, detail := range st.Details() {
        switch t := detail.(type) {
        case *errdetails.BadRequest:
            fmt.Println("Validation errors:")
            for _, violation := range t.GetFieldViolations() {
                fmt.Printf("  - %s: %s\n",
                    violation.GetField(),
                    violation.GetDescription())
            }
        }
    }
}
```

## Metadata et contexte

gRPC utilise les **metadata** (√©quivalent des headers HTTP) pour transmettre des informations transversales.

### Envoi de metadata (client)

```go
import "google.golang.org/grpc/metadata"

func main() {
    conn, _ := grpc.Dial("localhost:50051",
        grpc.WithTransportCredentials(insecure.NewCredentials()))
    defer conn.Close()

    client := pb.NewUserServiceClient(conn)

    // Cr√©er metadata
    md := metadata.Pairs(
        "authorization", "Bearer token123",
        "request-id", "req-abc-123",
        "client-version", "1.2.3",
    )

    // Attacher au contexte
    ctx := metadata.NewOutgoingContext(context.Background(), md)

    // Faire l'appel
    user, err := client.GetUser(ctx, &pb.GetUserRequest{UserId: 123})
    // ...
}
```

### R√©ception de metadata (serveur)

```go
func (s *server) GetUser(ctx context.Context,
                         req *pb.GetUserRequest) (*pb.User, error) {
    // Extraire metadata
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return nil, status.Error(codes.Internal, "no metadata")
    }

    // R√©cup√©rer un header sp√©cifique
    authHeaders := md.Get("authorization")
    if len(authHeaders) == 0 {
        return nil, status.Error(codes.Unauthenticated, "no auth token")
    }

    token := authHeaders[0]

    // Valider le token
    userID, err := validateToken(token)
    if err != nil {
        return nil, status.Error(codes.Unauthenticated, "invalid token")
    }

    // Log du request-id pour tracing
    if reqID := md.Get("request-id"); len(reqID) > 0 {
        log.Printf("Processing request %s for user %d", reqID[0], userID)
    }

    // ...
}
```

### Envoi de metadata du serveur vers le client

```go
func (s *server) GetUser(ctx context.Context,
                         req *pb.GetUserRequest) (*pb.User, error) {
    // Metadata √† envoyer
    header := metadata.Pairs(
        "server-version", "2.1.0",
        "rate-limit-remaining", "99",
    )
    grpc.SendHeader(ctx, header)

    // Trailers (envoy√©s apr√®s la r√©ponse)
    trailer := metadata.Pairs(
        "query-time-ms", "45",
    )
    grpc.SetTrailer(ctx, trailer)

    // ...
    return user, nil
}
```

**Client r√©ception :**

```go
var header, trailer metadata.MD

user, err := client.GetUser(ctx, req,
    grpc.Header(&header),
    grpc.Trailer(&trailer))

if err == nil {
    fmt.Println("Server version:", header.Get("server-version"))
    fmt.Println("Query time:", trailer.Get("query-time-ms"))
}
```

## Interceptors : Middleware gRPC

Les interceptors permettent d'ajouter de la logique transverse (logging, auth, metrics, etc.).

### Unary Interceptor (serveur)

```go
// Interceptor de logging
func loggingInterceptor(
    ctx context.Context,
    req interface{},
    info *grpc.UnaryServerInfo,
    handler grpc.UnaryHandler,
) (interface{}, error) {
    start := time.Now()

    // Log de la requ√™te
    log.Printf("‚Üí RPC %s", info.FullMethod)

    // Appeler le handler r√©el
    resp, err := handler(ctx, req)

    // Log de la r√©ponse
    duration := time.Since(start)
    status := "OK"
    if err != nil {
        status = "ERROR"
    }

    log.Printf("‚Üê RPC %s [%s] %v", info.FullMethod, status, duration)

    return resp, err
}

// Interceptor d'authentification
func authInterceptor(
    ctx context.Context,
    req interface{},
    info *grpc.UnaryServerInfo,
    handler grpc.UnaryHandler,
) (interface{}, error) {
    // Extraire token
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return nil, status.Error(codes.Unauthenticated, "no metadata")
    }

    authHeaders := md.Get("authorization")
    if len(authHeaders) == 0 {
        return nil, status.Error(codes.Unauthenticated, "no auth token")
    }

    // Valider
    userID, err := validateToken(authHeaders[0])
    if err != nil {
        return nil, status.Error(codes.Unauthenticated, "invalid token")
    }

    // Ajouter userID au contexte
    ctx = context.WithValue(ctx, "user_id", userID)

    // Continuer
    return handler(ctx, req)
}

// Cha√Æner les interceptors
func main() {
    server := grpc.NewServer(
        grpc.ChainUnaryInterceptor(
            loggingInterceptor,
            authInterceptor,
        ),
    )

    // ...
}
```

### Stream Interceptor (serveur)

```go
func streamLoggingInterceptor(
    srv interface{},
    ss grpc.ServerStream,
    info *grpc.StreamServerInfo,
    handler grpc.StreamHandler,
) error {
    log.Printf("‚Üí Stream RPC %s started", info.FullMethod)
    start := time.Now()

    err := handler(srv, ss)

    duration := time.Since(start)
    log.Printf("‚Üê Stream RPC %s ended after %v", info.FullMethod, duration)

    return err
}
```

### Client Interceptors

```go
// Interceptor client pour ajouter auth automatiquement
func authClientInterceptor(token string) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        // Ajouter token √† chaque requ√™te
        md := metadata.Pairs("authorization", "Bearer "+token)
        ctx = metadata.NewOutgoingContext(ctx, md)

        return invoker(ctx, method, req, reply, cc, opts...)
    }
}

func main() {
    token := "my-jwt-token"

    conn, _ := grpc.Dial("localhost:50051",
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithUnaryInterceptor(authClientInterceptor(token)),
    )
    defer conn.Close()

    // Toutes les requ√™tes auront automatiquement le token
    client := pb.NewUserServiceClient(conn)
    user, _ := client.GetUser(context.Background(), &pb.GetUserRequest{UserId: 123})
}
```

## Performance et benchmarks

### Comparaison REST vs gRPC

**Sc√©nario : 10,000 appels GetUser**

```
Configuration :
- R√©seau local (latence 1ms)
- Serveur : 4 CPU cores
- Message : User (5 champs, ~150 bytes JSON, ~45 bytes Protobuf)

REST (HTTP/1.1 + JSON) :
- Temps total : 12.5 secondes
- Throughput : 800 req/s
- Bande passante : ~1.5 MB
- CPU serveur : 75%

REST (HTTP/2 + JSON) :
- Temps total : 3.2 secondes
- Throughput : 3,125 req/s
- Bande passante : ~1.5 MB
- CPU serveur : 60%

gRPC (HTTP/2 + Protobuf) :
- Temps total : 1.8 secondes
- Throughput : 5,556 req/s
- Bande passante : ~0.5 MB
- CPU serveur : 45%

Am√©lioration gRPC vs REST/HTTP1.1 :
- 7x plus rapide
- 70% moins de bande passante
- 40% moins de CPU
```

**Benchmark code Go :**

```go
package main

import (
    "context"
    "testing"
    "time"

    "google.golang.org/grpc"
    pb "github.com/company/userservice/pb"
)

func BenchmarkGRPC(b *testing.B) {
    conn, _ := grpc.Dial("localhost:50051",
        grpc.WithTransportCredentials(insecure.NewCredentials()))
    defer conn.Close()

    client := pb.NewUserServiceClient(conn)
    req := &pb.GetUserRequest{UserId: 123}

    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        _, err := client.GetUser(context.Background(), req)
        if err != nil {
            b.Fatal(err)
        }
    }
}

// R√©sultats :
// BenchmarkGRPC-4   10000   180 ¬µs/op   45 B/op   2 allocs/op
```

### Optimisations r√©seau

**1. Connection pooling :**

```go
// R√©utiliser les connexions
var (
    clientConn *grpc.ClientConn
    once       sync.Once
)

func getClient() pb.UserServiceClient {
    once.Do(func() {
        conn, err := grpc.Dial("localhost:50051",
            grpc.WithTransportCredentials(insecure.NewCredentials()),
            grpc.WithKeepaliveParams(keepalive.ClientParameters{
                Time:                10 * time.Second,
                Timeout:             3 * time.Second,
                PermitWithoutStream: true,
            }),
        )
        if err != nil {
            panic(err)
        }
        clientConn = conn
    })

    return pb.NewUserServiceClient(clientConn)
}
```

**2. Compression :**

```go
// Serveur - Activer compression
server := grpc.NewServer(
    grpc.RPCCompressor(grpc.NewGZIPCompressor()),
    grpc.RPCDecompressor(grpc.NewGZIPDecompressor()),
)

// Client - Utiliser compression
client.GetUser(ctx, req,
    grpc.UseCompressor(gzip.Name))

// √âconomie : 60-80% pour JSON-like data
// Trade-off : CPU vs bande passante
```

**3. Load balancing :**

```go
import "google.golang.org/grpc/balancer/roundrobin"

// Client-side load balancing
conn, err := grpc.Dial(
    "dns:///api.example.com:50051",  // DNS avec multiples A records
    grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy":"round_robin"}`),
    grpc.WithTransportCredentials(insecure.NewCredentials()),
)
```

## D√©ploiement et consid√©rations de production

### TLS / mTLS

**Serveur avec TLS :**

```go
import "google.golang.org/grpc/credentials"

func main() {
    // Charger certificats
    creds, err := credentials.NewServerTLSFromFile(
        "server.crt",
        "server.key",
    )
    if err != nil {
        log.Fatal(err)
    }

    // Serveur gRPC avec TLS
    server := grpc.NewServer(grpc.Creds(creds))

    pb.RegisterUserServiceServer(server, &userServer{})

    listener, _ := net.Listen("tcp", ":50051")
    server.Serve(listener)
}
```

**Client avec TLS :**

```go
// Connexion s√©curis√©e
creds, err := credentials.NewClientTLSFromFile(
    "ca.crt",  // Certificat CA
    "api.example.com",  // Server name
)
if err != nil {
    log.Fatal(err)
}

conn, err := grpc.Dial("api.example.com:50051",
    grpc.WithTransportCredentials(creds))
```

**mTLS (Mutual TLS) :**

```go
// Serveur - Exiger certificat client
cert, _ := tls.LoadX509KeyPair("server.crt", "server.key")
certPool := x509.NewCertPool()
ca, _ := os.ReadFile("ca.crt")
certPool.AppendCertsFromPEM(ca)

creds := credentials.NewTLS(&tls.Config{
    Certificates: []tls.Certificate{cert},
    ClientAuth:   tls.RequireAndVerifyClientCert,
    ClientCAs:    certPool,
})

server := grpc.NewServer(grpc.Creds(creds))
```

### Health checking

```protobuf
// health.proto (standard gRPC)
service Health {
  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);
  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);
}

message HealthCheckRequest {
  string service = 1;
}

message HealthCheckResponse {
  enum ServingStatus {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
  }
  ServingStatus status = 1;
}
```

```go
import "google.golang.org/grpc/health"
import healthpb "google.golang.org/grpc/health/grpc_health_v1"

func main() {
    server := grpc.NewServer()

    // Enregistrer le service de health
    healthServer := health.NewServer()
    healthpb.RegisterHealthServer(server, healthServer)

    // Marquer le service comme SERVING
    healthServer.SetServingStatus("userservice.UserService",
        healthpb.HealthCheckResponse_SERVING)

    // ...
}
```

### Reflection pour debugging

```go
import "google.golang.org/grpc/reflection"

func main() {
    server := grpc.NewServer()

    pb.RegisterUserServiceServer(server, &userServer{})

    // Activer reflection (dev/debug seulement)
    reflection.Register(server)

    // Permet √† grpcurl de d√©couvrir les services
    // grpcurl -plaintext localhost:50051 list
}
```

### Observabilit√©

**OpenTelemetry avec gRPC :**

```go
import (
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
)

func main() {
    // Interceptor pour tracing
    server := grpc.NewServer(
        grpc.StatsHandler(otelgrpc.NewServerHandler()),
    )

    // Les RPC sont automatiquement trac√©s
}
```

**M√©triques Prometheus :**

```go
import (
    grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
)

func main() {
    server := grpc.NewServer(
        grpc.StreamInterceptor(grpc_prometheus.StreamServerInterceptor),
        grpc.UnaryInterceptor(grpc_prometheus.UnaryServerInterceptor),
    )

    grpc_prometheus.Register(server)

    // Exposer /metrics pour Prometheus
    http.Handle("/metrics", promhttp.Handler())
    go http.ListenAndServe(":9090", nil)
}
```

## Limitations et cas o√π ne pas utiliser gRPC

### 1. Support navigateur limit√©

**Probl√®me :** Les navigateurs ne supportent pas HTTP/2 client natif pour gRPC.

**Solution : gRPC-Web**

```javascript
// Client browser avec gRPC-Web
const {UserServiceClient} = require('./user_grpc_web_pb');

const client = new UserServiceClient('https://api.example.com');

const request = new GetUserRequest();
request.setUserId(123);

client.getUser(request, {}, (err, response) => {
  if (err) {
    console.error(err);
  } else {
    console.log(response.toObject());
  }
});
```

**N√©cessite un proxy (Envoy, grpc-web-proxy) :**

```yaml
# Envoy config
static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 8080
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          codec_type: AUTO
          stat_prefix: ingress_http
          route_config:
            virtual_hosts:
            - name: backend
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                route: { cluster: grpc_backend }
          http_filters:
          - name: envoy.filters.http.grpc_web
          - name: envoy.filters.http.router
  clusters:
  - name: grpc_backend
    type: STRICT_DNS
    http2_protocol_options: {}
    load_assignment:
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: grpc-server
                port_value: 50051
```

### 2. Debugging plus complexe

**REST :**
```bash
# Simple curl
curl https://api.example.com/users/123

# Browser DevTools
# Postman / Insomnia
```

**gRPC :**
```bash
# N√©cessite grpcurl
grpcurl -plaintext -d '{"user_id": 123}' \
  localhost:50051 \
  userservice.UserService/GetUser

# Wireshark peut d√©coder mais plus complexe
```

### 3. Pas de caching interm√©diaire simple

**REST :** CDN, reverse proxy, browser cache

**gRPC :** Cache applicatif n√©cessaire (Redis, Memcached)

```go
// Cache pattern avec gRPC
func (s *server) GetUser(ctx context.Context,
                         req *pb.GetUserRequest) (*pb.User, error) {
    // V√©rifier cache
    cacheKey := fmt.Sprintf("user:%d", req.UserId)
    if cached, err := s.cache.Get(cacheKey); err == nil {
        var user pb.User
        proto.Unmarshal(cached, &user)
        return &user, nil
    }

    // Pas en cache, fetch DB
    user, err := s.db.GetUser(req.UserId)
    if err != nil {
        return nil, err
    }

    // Mettre en cache
    data, _ := proto.Marshal(user)
    s.cache.Set(cacheKey, data, 5*time.Minute)

    return user, nil
}
```

### 4. APIs publiques

**Utiliser REST pour APIs publiques :**
- Universalit√© (tout le monde connait HTTP/JSON)
- Documentation web (Swagger UI)
- Pas de g√©n√©ration de code requise

**gRPC pour services internes :**
- Performance
- Typage fort
- G√©n√©ration de code

## Cas d'usage r√©els

### 1. Microservices backend (Netflix, Uber)

```
API Gateway (REST)
    ‚Üì
    ‚îú‚îÄ User Service (gRPC)
    ‚îú‚îÄ Order Service (gRPC)
    ‚îÇ   ‚îî‚îÄ‚Üí Inventory Service (gRPC)
    ‚îÇ   ‚îî‚îÄ‚Üí Payment Service (gRPC)
    ‚îî‚îÄ Notification Service (gRPC)

Avantages :
- Performance entre services
- Typage fort des contrats
- G√©n√©ration automatique de clients
```

### 2. Syst√®mes distribu√©s temps r√©el

```protobuf
// Service de notifications push
service PushService {
  rpc Subscribe(SubscribeRequest) returns (stream Notification);
}

// Client maintient une connexion ouverte
// Re√ßoit les notifications en temps r√©el
```

### 3. Mobile backends

```
App Mobile ‚Üí API Gateway (gRPC-Web ou REST)
              ‚Üì
           Backend Services (gRPC)

Avantages :
- Protobuf compact (√©conomie data mobile)
- Streaming pour sync efficace
```

## Conclusion

gRPC repr√©sente une √©volution majeure des communications r√©seau pour les architectures modernes :

**Forces :**
- **Performance** : 3-10x plus rapide que REST
- **Efficacit√©** : 70% moins de bande passante
- **Typage fort** : Contrats stricts, g√©n√©ration de code
- **Streaming** : Support natif bidirectionnel
- **HTTP/2** : Multiplexage, flow control

**Faiblesses :**
- Complexit√© setup (proto, g√©n√©ration de code)
- Support navigateur limit√© (gRPC-Web)
- Debugging moins accessible
- Pas de caching interm√©diaire simple

**Quand utiliser gRPC :**
- Communication service-to-service
- Microservices dans un datacenter
- Besoin de streaming
- Performance critique

**Quand √©viter gRPC :**
- APIs publiques pour d√©veloppeurs tiers
- Clients web uniquement
- Simplicit√© prioritaire sur performance

**Prochaine section :** 8.10.3 GraphQL : consid√©rations r√©seau

---

**Points cl√©s √† retenir :**
- Protocol Buffers = IDL + s√©rialisation binaire compacte
- HTTP/2 = multiplexage + streaming + flow control
- 4 types de RPC : unary, server streaming, client streaming, bidirectional
- Interceptors = middleware pour auth, logging, metrics
- mTLS pour s√©curit√© service-to-service
- gRPC-Web n√©cessaire pour navigateurs
- Performance sup√©rieure √† REST pour communications internes

‚è≠Ô∏è [GraphQL : consid√©rations r√©seau](/08-programmation-reseau/10.3-graphql.md)
