ðŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 8.9.2 Server-Sent Events (SSE) : streaming unidirectionnel

## Introduction

**Server-Sent Events (SSE)** est une technologie HTML5 qui permet au serveur de **pousser des donnÃ©es vers le client** via une connexion HTTP persistante. Contrairement au WebSocket qui est bidirectionnel, SSE est **unidirectionnel** : le serveur envoie, le client reÃ§oit.

**Pourquoi SSE existe-t-il ?**

En 2006, lorsque les navigateurs modernes ont commencÃ© Ã  supporter XMLHttpRequest, les dÃ©veloppeurs cherchaient un moyen simple de recevoir des mises Ã  jour du serveur sans polling. SSE a Ã©tÃ© standardisÃ© en 2009 comme partie de HTML5 pour rÃ©pondre Ã  ce besoin spÃ©cifique.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              SSE : ModÃ¨le de communication          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  Client                         Serveur             â”‚
â”‚    â”‚                               â”‚                â”‚
â”‚    â”‚â”€â”€â”€â”€ GET /events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                â”‚
â”‚    â”‚    (Accept: text/event-stream)â”‚                â”‚
â”‚    â”‚                               â”‚                â”‚
â”‚    â”‚<â”€â”€â”€â”€ HTTP/1.1 200 OK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                â”‚
â”‚    â”‚     (Content-Type: text/event-stream)          â”‚
â”‚    â”‚                               â”‚                â”‚
â”‚    â”‚<â•â•â•â•â•â•â• Connexion ouverte â•â•â•>â”‚                â”‚
â”‚    â”‚                               â”‚                â”‚
â”‚    â”‚                           [Ã‰vÃ©nement 1]        â”‚
â”‚    â”‚<â”€â”€â”€â”€ data: {...} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                â”‚
â”‚    â”‚                               â”‚                â”‚
â”‚    â”‚                           [Ã‰vÃ©nement 2]        â”‚
â”‚    â”‚<â”€â”€â”€â”€ data: {...} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                â”‚
â”‚    â”‚                               â”‚                â”‚
â”‚    â”‚  [DÃ©connexion rÃ©seau]         â”‚                â”‚
â”‚    â”‚                               â”‚                â”‚
â”‚    â”‚â”€â”€â”€â”€ GET /events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ (reconnexion auto)
â”‚    â”‚     (Last-Event-ID: 42)       â”‚                â”‚
â”‚    â”‚                               â”‚                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Avantages clÃ©s** :
- âœ… **API native** dans tous les navigateurs modernes (EventSource)
- âœ… **Reconnexion automatique** gÃ©rÃ©e par le navigateur
- âœ… **Format texte simple** (facile Ã  dÃ©boguer)
- âœ… **Compatible HTTP** (fonctionne avec proxies/load balancers)
- âœ… **LÃ©ger** : pas de bibliothÃ¨que nÃ©cessaire

**Limitations** :
- âŒ **Unidirectionnel** : serveur â†’ client uniquement
- âŒ **Texte seulement** (pas de binaire natif)
- âŒ **Limite de connexions** : 6 par domaine en HTTP/1.1
- âŒ **Pas de support IE** (mais polyfill disponibles)

---

## Le protocole SSE

### Format des messages

SSE utilise un format texte simple basÃ© sur des champs `field: value`.

```
Champs standards:
- data: Le contenu du message (peut Ãªtre multi-lignes)
- event: Type d'Ã©vÃ©nement (optionnel, dÃ©faut: "message")
- id: Identifiant unique (pour reconnexion)
- retry: DÃ©lai de reconnexion en millisecondes
- : Commentaire (ignorÃ© par le client)
```

**Exemple de stream SSE** :

```http
HTTP/1.1 200 OK
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive

: Ceci est un commentaire (heartbeat)

data: Premier message simple

data: Message JSON
data: {"type": "notification", "text": "Hello"}

event: userJoined
data: {"user": "Alice", "timestamp": 1638360000}
id: 42

data: Message multi-lignes
data: Ligne 1
data: Ligne 2
data: Ligne 3

retry: 10000

event: update
data: {"stock": "AAPL", "price": 150.25}
id: 43
```

### RÃ¨gles du protocole

```
1. Content-Type DOIT Ãªtre "text/event-stream"
2. Encoding DOIT Ãªtre UTF-8
3. Chaque message se termine par deux retours Ã  la ligne (\n\n)
4. Les lignes vides sont ignorÃ©es
5. Les lignes commenÃ§ant par : sont des commentaires
6. Un message peut avoir plusieurs champs "data" (concatÃ©nÃ©s avec \n)
```

---

## API EventSource (Client)

### Utilisation basique

```javascript
/**
 * EventSource : API native du navigateur pour SSE
 */

// CrÃ©er une connexion SSE
const eventSource = new EventSource('/api/events');

// Ã‰couter les messages gÃ©nÃ©riques (event: message ou pas d'event)
eventSource.addEventListener('message', (event) => {
    console.log('Message reÃ§u:', event.data);

    // PropriÃ©tÃ©s disponibles
    console.log('Data:', event.data);           // String
    console.log('Event type:', event.type);     // "message"
    console.log('Last Event ID:', event.lastEventId); // ID du dernier Ã©vÃ©nement
    console.log('Origin:', event.origin);       // URL source
});

// Ã‰couter des Ã©vÃ©nements spÃ©cifiques
eventSource.addEventListener('userJoined', (event) => {
    const data = JSON.parse(event.data);
    console.log('User joined:', data.user);
});

eventSource.addEventListener('stockUpdate', (event) => {
    const { symbol, price } = JSON.parse(event.data);
    updateStockPrice(symbol, price);
});

// Gestion des erreurs et Ã©tats
eventSource.addEventListener('error', (event) => {
    if (event.target.readyState === EventSource.CONNECTING) {
        console.log('Reconnecting...');
    } else if (event.target.readyState === EventSource.CLOSED) {
        console.log('Connection closed');
    } else {
        console.error('Error occurred:', event);
    }
});

// Ã‰tat de la connexion
console.log('Ready state:', eventSource.readyState);
// 0 = CONNECTING
// 1 = OPEN
// 2 = CLOSED

// Fermer la connexion manuellement
// eventSource.close();
```

### EventSource avec options

```javascript
/**
 * Configuration avancÃ©e d'EventSource
 */

// Avec credentials (cookies, auth)
const eventSource = new EventSource('/api/events', {
    withCredentials: true  // Envoie les cookies cross-origin
});

// Avec Last-Event-ID automatique
// Le navigateur envoie automatiquement le header "Last-Event-ID"
// lors de la reconnexion

// Custom headers (NON SUPPORTÃ‰ nativement)
// EventSource ne permet PAS de custom headers
// Workaround : passer le token dans l'URL
const token = localStorage.getItem('authToken');
const eventSource = new EventSource(`/api/events?token=${token}`);
```

### Wrapper rÃ©utilisable

```javascript
/**
 * Wrapper EventSource avec fonctionnalitÃ©s Ã©tendues
 */
class SSEClient {
    constructor(url, options = {}) {
        this.url = url;
        this.options = options;
        this.eventSource = null;
        this.listeners = new Map();
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = options.maxReconnectAttempts || Infinity;
        this.onConnectCallback = null;
        this.onErrorCallback = null;
    }

    connect() {
        // CrÃ©er EventSource
        this.eventSource = new EventSource(this.url, {
            withCredentials: this.options.withCredentials || false
        });

        // Gestion de l'ouverture
        this.eventSource.addEventListener('open', () => {
            console.log('SSE connected');
            this.reconnectAttempts = 0;

            if (this.onConnectCallback) {
                this.onConnectCallback();
            }
        });

        // Gestion des erreurs et reconnexion
        this.eventSource.addEventListener('error', (event) => {
            console.error('SSE error:', event);

            if (this.eventSource.readyState === EventSource.CLOSED) {
                console.log('Connection closed by server');

                // Tentative de reconnexion
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);

                    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);

                    setTimeout(() => {
                        this.connect();
                    }, delay);
                } else {
                    console.error('Max reconnect attempts reached');

                    if (this.onErrorCallback) {
                        this.onErrorCallback(new Error('Max reconnect attempts reached'));
                    }
                }
            }
        });

        // Attacher les listeners enregistrÃ©s
        this.listeners.forEach((callback, eventType) => {
            this.eventSource.addEventListener(eventType, callback);
        });

        return this;
    }

    on(eventType, callback) {
        this.listeners.set(eventType, callback);

        if (this.eventSource) {
            this.eventSource.addEventListener(eventType, callback);
        }

        return this;
    }

    onConnect(callback) {
        this.onConnectCallback = callback;
        return this;
    }

    onError(callback) {
        this.onErrorCallback = callback;
        return this;
    }

    close() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
    }

    getReadyState() {
        return this.eventSource ? this.eventSource.readyState : EventSource.CLOSED;
    }
}

// Utilisation
const sse = new SSEClient('/api/events', { withCredentials: true })
    .onConnect(() => {
        console.log('Connected!');
    })
    .on('message', (event) => {
        console.log('Message:', event.data);
    })
    .on('notification', (event) => {
        const notif = JSON.parse(event.data);
        showNotification(notif);
    })
    .on('error', (event) => {
        console.error('Custom error handler:', event);
    })
    .connect();

// Cleanup
window.addEventListener('beforeunload', () => {
    sse.close();
});
```

---

## ImplÃ©mentations serveur

### Node.js (Express)

```javascript
const express = require('express');
const app = express();

// Stockage des clients connectÃ©s
const clients = new Set();

/**
 * Endpoint SSE
 */
app.get('/api/events', (req, res) => {
    // Headers SSE obligatoires
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    // Pour Ã©viter les problÃ¨mes avec nginx/proxies
    res.setHeader('X-Accel-Buffering', 'no');

    // CORS si nÃ©cessaire
    res.setHeader('Access-Control-Allow-Origin', '*');

    // Client info
    const clientId = Date.now();
    const client = {
        id: clientId,
        res: res
    };

    clients.add(client);
    console.log(`Client ${clientId} connected. Total: ${clients.size}`);

    // Envoyer un message de bienvenue
    res.write(`data: Connected as client ${clientId}\n\n`);

    // Heartbeat toutes les 15 secondes
    const heartbeat = setInterval(() => {
        res.write(`: heartbeat\n\n`);
    }, 15000);

    // Cleanup quand le client se dÃ©connecte
    req.on('close', () => {
        clearInterval(heartbeat);
        clients.delete(client);
        console.log(`Client ${clientId} disconnected. Total: ${clients.size}`);
    });
});

/**
 * Fonction pour broadcaster un message Ã  tous les clients
 */
function broadcast(eventType, data) {
    const message = formatSSEMessage(eventType, data);

    clients.forEach((client) => {
        client.res.write(message);
    });
}

/**
 * Formater un message SSE
 */
function formatSSEMessage(eventType, data, id = null) {
    let message = '';

    if (id) {
        message += `id: ${id}\n`;
    }

    if (eventType && eventType !== 'message') {
        message += `event: ${eventType}\n`;
    }

    // GÃ©rer les objets/arrays
    const dataStr = typeof data === 'string' ? data : JSON.stringify(data);

    // Supporter les donnÃ©es multi-lignes
    dataStr.split('\n').forEach(line => {
        message += `data: ${line}\n`;
    });

    message += '\n';

    return message;
}

/**
 * Exemple : endpoint pour poster un message
 */
app.post('/api/broadcast', express.json(), (req, res) => {
    const { event, data } = req.body;

    broadcast(event || 'message', data);

    res.json({ success: true, clients: clients.size });
});

/**
 * Exemple : simuler des Ã©vÃ©nements pÃ©riodiques
 */
let eventId = 0;

setInterval(() => {
    const update = {
        timestamp: Date.now(),
        value: Math.random()
    };

    broadcast('update', update, ++eventId);
}, 5000);

app.listen(3000, () => {
    console.log('SSE server running on port 3000');
});
```

### Python (Flask)

```python
from flask import Flask, Response, request, jsonify
import time
import json
from queue import Queue
import threading

app = Flask(__name__)

# Stockage des clients
clients = {}
clients_lock = threading.Lock()

def format_sse_message(data, event=None, event_id=None, retry=None):
    """
    Formate un message SSE selon le protocole.
    """
    message = ""

    if event_id:
        message += f"id: {event_id}\n"

    if event:
        message += f"event: {event}\n"

    if retry:
        message += f"retry: {retry}\n"

    # DonnÃ©es (peut Ãªtre multi-lignes)
    if isinstance(data, (dict, list)):
        data = json.dumps(data)

    for line in str(data).split('\n'):
        message += f"data: {line}\n"

    message += "\n"

    return message

@app.route('/api/events')
def sse_stream():
    """
    Endpoint SSE principal.
    """
    def event_stream():
        # CrÃ©er une queue pour ce client
        client_id = id(request)
        client_queue = Queue()

        with clients_lock:
            clients[client_id] = client_queue

        print(f"Client {client_id} connected. Total: {len(clients)}")

        try:
            # Message de bienvenue
            yield format_sse_message(
                {'message': f'Connected as client {client_id}'},
                event='connected'
            )

            # Boucle d'Ã©vÃ©nements
            while True:
                # Heartbeat tous les 15s si pas de message
                try:
                    message = client_queue.get(timeout=15)
                    yield message
                except:
                    # Timeout : envoyer heartbeat
                    yield ": heartbeat\n\n"

        except GeneratorExit:
            # Client dÃ©connectÃ©
            print(f"Client {client_id} disconnected")
        finally:
            with clients_lock:
                if client_id in clients:
                    del clients[client_id]
            print(f"Total clients: {len(clients)}")

    return Response(
        event_stream(),
        mimetype='text/event-stream',
        headers={
            'Cache-Control': 'no-cache',
            'X-Accel-Buffering': 'no',  # Nginx
            'Connection': 'keep-alive'
        }
    )

def broadcast(data, event=None, event_id=None):
    """
    Envoie un message Ã  tous les clients connectÃ©s.
    """
    message = format_sse_message(data, event=event, event_id=event_id)

    with clients_lock:
        for client_queue in clients.values():
            try:
                client_queue.put(message)
            except:
                pass

@app.route('/api/broadcast', methods=['POST'])
def broadcast_message():
    """
    Endpoint pour broadcaster un message.
    """
    data = request.json

    broadcast(
        data.get('data'),
        event=data.get('event'),
        event_id=data.get('id')
    )

    return jsonify({
        'success': True,
        'clients': len(clients)
    })

# Ã‰vÃ©nements pÃ©riodiques (exemple)
def periodic_updates():
    event_id = 0
    while True:
        time.sleep(10)
        event_id += 1

        broadcast(
            {'timestamp': time.time(), 'value': 'periodic update'},
            event='update',
            event_id=str(event_id)
        )

# DÃ©marrer le thread des updates pÃ©riodiques
threading.Thread(target=periodic_updates, daemon=True).start()

if __name__ == '__main__':
    app.run(debug=True, threaded=True, port=5000)
```

### Go (avec goroutines)

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "sync"
    "time"
)

type SSEMessage struct {
    Event string      `json:"-"`
    Data  interface{} `json:"-"`
    ID    string      `json:"-"`
    Retry int         `json:"-"`
}

type Client struct {
    ID      string
    Channel chan SSEMessage
}

type SSEServer struct {
    clients    map[*Client]bool
    clientsMux sync.RWMutex
    eventID    int
}

func NewSSEServer() *SSEServer {
    return &SSEServer{
        clients: make(map[*Client]bool),
    }
}

func (s *SSEServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // Headers SSE
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")
    w.Header().Set("Access-Control-Allow-Origin", "*")

    // CrÃ©er un nouveau client
    client := &Client{
        ID:      fmt.Sprintf("%d", time.Now().UnixNano()),
        Channel: make(chan SSEMessage, 100),
    }

    // Enregistrer le client
    s.clientsMux.Lock()
    s.clients[client] = true
    clientCount := len(s.clients)
    s.clientsMux.Unlock()

    log.Printf("Client %s connected. Total: %d", client.ID, clientCount)

    // Flusher pour envoyer les donnÃ©es immÃ©diatement
    flusher, ok := w.(http.Flusher)
    if !ok {
        http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
        return
    }

    // Message de bienvenue
    s.writeMessage(w, flusher, SSEMessage{
        Event: "connected",
        Data:  map[string]string{"client_id": client.ID},
    })

    // Heartbeat ticker
    ticker := time.NewTicker(15 * time.Second)
    defer ticker.Stop()

    // Boucle d'Ã©vÃ©nements
    for {
        select {
        case msg := <-client.Channel:
            s.writeMessage(w, flusher, msg)

        case <-ticker.C:
            // Heartbeat
            fmt.Fprintf(w, ": heartbeat\n\n")
            flusher.Flush()

        case <-r.Context().Done():
            // Client dÃ©connectÃ©
            s.clientsMux.Lock()
            delete(s.clients, client)
            clientCount = len(s.clients)
            s.clientsMux.Unlock()

            close(client.Channel)
            log.Printf("Client %s disconnected. Total: %d", client.ID, clientCount)
            return
        }
    }
}

func (s *SSEServer) writeMessage(w http.ResponseWriter, flusher http.Flusher, msg SSEMessage) {
    if msg.ID != "" {
        fmt.Fprintf(w, "id: %s\n", msg.ID)
    }

    if msg.Event != "" && msg.Event != "message" {
        fmt.Fprintf(w, "event: %s\n", msg.Event)
    }

    if msg.Retry > 0 {
        fmt.Fprintf(w, "retry: %d\n", msg.Retry)
    }

    // SÃ©rialiser les donnÃ©es
    var dataStr string
    switch v := msg.Data.(type) {
    case string:
        dataStr = v
    default:
        jsonData, _ := json.Marshal(msg.Data)
        dataStr = string(jsonData)
    }

    // Ã‰crire les donnÃ©es (supporter multi-lignes)
    for _, line := range []string{dataStr} {
        fmt.Fprintf(w, "data: %s\n", line)
    }

    fmt.Fprintf(w, "\n")
    flusher.Flush()
}

func (s *SSEServer) Broadcast(msg SSEMessage) {
    s.clientsMux.RLock()
    defer s.clientsMux.RUnlock()

    for client := range s.clients {
        select {
        case client.Channel <- msg:
            // Message envoyÃ©
        default:
            // Canal plein, skip ce client
            log.Printf("Client %s channel full, skipping message", client.ID)
        }
    }
}

func (s *SSEServer) BroadcastHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }

    var payload struct {
        Event string      `json:"event"`
        Data  interface{} `json:"data"`
    }

    if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }

    s.eventID++
    s.Broadcast(SSEMessage{
        Event: payload.Event,
        Data:  payload.Data,
        ID:    fmt.Sprintf("%d", s.eventID),
    })

    json.NewEncoder(w).Encode(map[string]interface{}{
        "success": true,
        "clients": len(s.clients),
    })
}

func main() {
    server := NewSSEServer()

    http.Handle("/api/events", server)
    http.HandleFunc("/api/broadcast", server.BroadcastHandler)

    // Ã‰vÃ©nements pÃ©riodiques
    go func() {
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for range ticker.C {
            server.Broadcast(SSEMessage{
                Event: "update",
                Data: map[string]interface{}{
                    "timestamp": time.Now().Unix(),
                    "value":     "periodic update",
                },
            })
        }
    }()

    log.Println("SSE server running on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### Java (Spring Boot)

```java
package com.example.sse;

import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

@RestController
@RequestMapping("/api")
public class SSEController {

    private final Map<String, SseEmitter> clients = new ConcurrentHashMap<>();
    private final AtomicLong eventId = new AtomicLong(0);

    /**
     * Endpoint SSE
     */
    @GetMapping(path = "/events", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter streamEvents() {
        // CrÃ©er un SseEmitter avec timeout de 5 minutes
        SseEmitter emitter = new SseEmitter(300_000L);

        String clientId = String.valueOf(System.currentTimeMillis());
        clients.put(clientId, emitter);

        System.out.println("Client " + clientId + " connected. Total: " + clients.size());

        // Cleanup quand complÃ©tÃ© ou timeout
        emitter.onCompletion(() -> {
            clients.remove(clientId);
            System.out.println("Client " + clientId + " completed. Total: " + clients.size());
        });

        emitter.onTimeout(() -> {
            clients.remove(clientId);
            System.out.println("Client " + clientId + " timeout. Total: " + clients.size());
        });

        emitter.onError((ex) -> {
            clients.remove(clientId);
            System.out.println("Client " + clientId + " error: " + ex.getMessage());
        });

        // Message de bienvenue
        try {
            emitter.send(SseEmitter.event()
                .name("connected")
                .data(Map.of("client_id", clientId))
                .id(String.valueOf(eventId.incrementAndGet()))
            );
        } catch (IOException e) {
            emitter.completeWithError(e);
        }

        return emitter;
    }

    /**
     * Broadcaster un message Ã  tous les clients
     */
    @PostMapping("/broadcast")
    public Map<String, Object> broadcast(@RequestBody BroadcastRequest request) {
        String id = String.valueOf(eventId.incrementAndGet());

        clients.values().forEach(emitter -> {
            try {
                SseEmitter.SseEventBuilder event = SseEmitter.event()
                    .data(request.getData())
                    .id(id);

                if (request.getEvent() != null) {
                    event.name(request.getEvent());
                }

                emitter.send(event);

            } catch (IOException e) {
                // Client dÃ©connectÃ©, sera nettoyÃ© par onError
                e.printStackTrace();
            }
        });

        return Map.of(
            "success", true,
            "clients", clients.size(),
            "event_id", id
        );
    }

    /**
     * Classe pour la requÃªte de broadcast
     */
    static class BroadcastRequest {
        private String event;
        private Object data;

        public String getEvent() { return event; }
        public void setEvent(String event) { this.event = event; }
        public Object getData() { return data; }
        public void setData(Object data) { this.data = data; }
    }
}
```

---

## Gestion de la reconnexion

### Reconnexion automatique cÃ´tÃ© client

Le navigateur gÃ¨re automatiquement la reconnexion, mais on peut la personnaliser :

```javascript
/**
 * Gestion avancÃ©e de la reconnexion
 */
class ResilientSSE {
    constructor(url, options = {}) {
        this.url = url;
        this.options = options;
        this.maxReconnectDelay = options.maxReconnectDelay || 30000;
        this.reconnectDecay = options.reconnectDecay || 1.5;
        this.lastEventId = null;
        this.reconnectAttempts = 0;
        this.eventSource = null;
        this.listeners = new Map();
    }

    connect() {
        // Construire l'URL avec Last-Event-ID si disponible
        let url = this.url;
        if (this.lastEventId) {
            const separator = url.includes('?') ? '&' : '?';
            url = `${url}${separator}lastEventId=${this.lastEventId}`;
        }

        this.eventSource = new EventSource(url, this.options);

        // Gestion de l'ouverture
        this.eventSource.addEventListener('open', () => {
            console.log('SSE connected');
            this.reconnectAttempts = 0;
            this.onConnect();
        });

        // Intercepter tous les messages pour capturer l'ID
        const originalAddEventListener = this.eventSource.addEventListener.bind(this.eventSource);

        this.eventSource.addEventListener = (type, listener, options) => {
            const wrappedListener = (event) => {
                // Capturer le dernier event ID
                if (event.lastEventId) {
                    this.lastEventId = event.lastEventId;
                }

                // Appeler le listener original
                listener(event);
            };

            originalAddEventListener(type, wrappedListener, options);
        };

        // Gestion des erreurs
        this.eventSource.addEventListener('error', (event) => {
            if (this.eventSource.readyState === EventSource.CLOSED) {
                console.log('Connection closed, will reconnect...');
                this.scheduleReconnect();
            } else if (this.eventSource.readyState === EventSource.CONNECTING) {
                console.log('Reconnecting...');
            } else {
                console.error('SSE error:', event);
            }
        });

        // Attacher les listeners enregistrÃ©s
        this.listeners.forEach((callback, eventType) => {
            this.eventSource.addEventListener(eventType, callback);
        });
    }

    scheduleReconnect() {
        this.reconnectAttempts++;

        // Calcul du dÃ©lai avec exponential backoff
        const delay = Math.min(
            1000 * Math.pow(this.reconnectDecay, this.reconnectAttempts),
            this.maxReconnectDelay
        );

        console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);

        setTimeout(() => {
            this.connect();
        }, delay);
    }

    on(eventType, callback) {
        this.listeners.set(eventType, callback);

        if (this.eventSource) {
            this.eventSource.addEventListener(eventType, callback);
        }

        return this;
    }

    onConnect() {
        // Override dans les sous-classes
    }

    close() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
    }
}

// Utilisation
const sse = new ResilientSSE('/api/events')
    .on('message', (event) => {
        console.log('Message:', event.data);
    })
    .on('notification', (event) => {
        showNotification(JSON.parse(event.data));
    });

sse.onConnect = () => {
    console.log('Successfully connected!');
};

sse.connect();
```

### Reprise aprÃ¨s dÃ©connexion (Last-Event-ID)

Le serveur peut utiliser le header `Last-Event-ID` pour renvoyer les Ã©vÃ©nements manquÃ©s :

```python
from flask import Flask, Response, request
from collections import deque

app = Flask(__name__)

# Stockage des derniers Ã©vÃ©nements (en production, utiliser Redis)
event_history = deque(maxlen=1000)
event_history_lock = threading.Lock()

def add_to_history(event_id, event_type, data):
    """Ajoute un Ã©vÃ©nement Ã  l'historique."""
    with event_history_lock:
        event_history.append({
            'id': event_id,
            'event': event_type,
            'data': data,
            'timestamp': time.time()
        })

@app.route('/api/events')
def sse_with_history():
    def event_stream():
        # RÃ©cupÃ©rer le Last-Event-ID
        last_event_id = request.headers.get('Last-Event-ID')

        # Ou depuis l'URL
        if not last_event_id:
            last_event_id = request.args.get('lastEventId')

        # Renvoyer les Ã©vÃ©nements manquÃ©s
        if last_event_id:
            with event_history_lock:
                missed_events = [
                    e for e in event_history
                    if int(e['id']) > int(last_event_id)
                ]

            for event in missed_events:
                yield format_sse_message(
                    event['data'],
                    event=event['event'],
                    event_id=event['id']
                )

        # Suite normale : streaming des nouveaux Ã©vÃ©nements
        client_id = id(request)
        client_queue = Queue()

        with clients_lock:
            clients[client_id] = client_queue

        try:
            while True:
                try:
                    message = client_queue.get(timeout=15)
                    yield message
                except:
                    yield ": heartbeat\n\n"
        finally:
            with clients_lock:
                del clients[client_id]

    return Response(
        event_stream(),
        mimetype='text/event-stream'
    )

def broadcast_with_history(data, event=None, event_id=None):
    """Broadcast et stocke dans l'historique."""
    message = format_sse_message(data, event=event, event_id=event_id)

    # Ajouter Ã  l'historique
    if event_id:
        add_to_history(event_id, event or 'message', data)

    # Broadcaster
    with clients_lock:
        for client_queue in clients.values():
            try:
                client_queue.put(message)
            except:
                pass
```

---

## Cas d'usage rÃ©els

### 1. Notifications en temps rÃ©el (GitHub, Twitter)

```javascript
/**
 * SystÃ¨me de notifications style GitHub
 */

// Serveur (Node.js)
class NotificationService {
    constructor() {
        this.clients = new Map();
    }

    addClient(userId, res) {
        if (!this.clients.has(userId)) {
            this.clients.set(userId, new Set());
        }
        this.clients.get(userId).add(res);
    }

    removeClient(userId, res) {
        const userClients = this.clients.get(userId);
        if (userClients) {
            userClients.delete(res);
            if (userClients.size === 0) {
                this.clients.delete(userId);
            }
        }
    }

    notify(userId, notification) {
        const userClients = this.clients.get(userId);
        if (!userClients) return;

        const message = formatSSEMessage(notification, 'notification', notification.id);

        userClients.forEach(res => {
            try {
                res.write(message);
            } catch (error) {
                // Client dÃ©connectÃ©
                this.removeClient(userId, res);
            }
        });
    }
}

const notificationService = new NotificationService();

app.get('/api/notifications/stream', authenticateUser, (req, res) => {
    const userId = req.user.id;

    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    notificationService.addClient(userId, res);

    // Message de bienvenue
    res.write(formatSSEMessage({ message: 'Connected to notifications' }, 'connected'));

    req.on('close', () => {
        notificationService.removeClient(userId, res);
    });
});

// DÃ©clencher une notification
app.post('/api/users/:userId/mention', async (req, res) => {
    const { userId } = req.params;
    const { text, mentionedBy } = req.body;

    // Sauvegarder la notification en DB
    const notification = await db.notifications.create({
        userId,
        type: 'mention',
        text,
        mentionedBy,
        read: false
    });

    // Notifier en temps rÃ©el
    notificationService.notify(userId, {
        id: notification.id,
        type: 'mention',
        text,
        mentionedBy
    });

    res.json({ success: true });
});

// Client
const notificationSource = new EventSource('/api/notifications/stream');

notificationSource.addEventListener('notification', (event) => {
    const notif = JSON.parse(event.data);

    // Afficher dans l'UI
    showNotificationBadge();
    addNotificationToList(notif);

    // Browser notification si supportÃ©
    if ('Notification' in window && Notification.permission === 'granted') {
        new Notification('Nouvelle notification', {
            body: notif.text,
            icon: '/icon.png'
        });
    }
});
```

### 2. Dashboard de monitoring (Grafana-like)

```javascript
/**
 * Streaming de mÃ©triques systÃ¨me
 */

// Serveur (Go)
/*
func metricsSSE(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")

    flusher, _ := w.(http.Flusher)

    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            metrics := collectMetrics()

            data, _ := json.Marshal(metrics)
            fmt.Fprintf(w, "event: metrics\n")
            fmt.Fprintf(w, "data: %s\n\n", data)
            flusher.Flush()

        case <-r.Context().Done():
            return
        }
    }
}

func collectMetrics() map[string]interface{} {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    return map[string]interface{}{
        "timestamp": time.Now().Unix(),
        "cpu_usage": getCPUUsage(),
        "memory": map[string]uint64{
            "alloc": m.Alloc,
            "total_alloc": m.TotalAlloc,
            "sys": m.Sys,
        },
        "goroutines": runtime.NumGoroutine(),
    }
}
*/

// Client (Chart.js)
const metricsSource = new EventSource('/api/metrics/stream');
const chart = createChart();
const maxDataPoints = 60; // 1 minute de donnÃ©es

metricsSource.addEventListener('metrics', (event) => {
    const metrics = JSON.parse(event.data);

    // Mettre Ã  jour le graphique
    chart.data.labels.push(new Date(metrics.timestamp * 1000));
    chart.data.datasets[0].data.push(metrics.cpu_usage);
    chart.data.datasets[1].data.push(metrics.memory.alloc / 1024 / 1024); // MB

    // Garder seulement les N derniers points
    if (chart.data.labels.length > maxDataPoints) {
        chart.data.labels.shift();
        chart.data.datasets.forEach(dataset => dataset.data.shift());
    }

    chart.update('none'); // Update sans animation

    // Mettre Ã  jour les indicateurs
    document.getElementById('cpu').textContent = `${metrics.cpu_usage.toFixed(1)}%`;
    document.getElementById('memory').textContent = `${(metrics.memory.alloc / 1024 / 1024).toFixed(0)} MB`;
    document.getElementById('goroutines').textContent = metrics.goroutines;
});
```

### 3. Live score de sports (ESPN-like)

```python
"""
Diffusion de scores sportifs en temps rÃ©el
"""

from flask import Flask, Response
import json
import time

app = Flask(__name__)

class SportsScoreService:
    def __init__(self):
        self.games = {}  # game_id -> game data
        self.subscribers = {}  # game_id -> set of clients

    def subscribe(self, game_id, client_queue):
        """S'abonner aux mises Ã  jour d'un match."""
        if game_id not in self.subscribers:
            self.subscribers[game_id] = set()
        self.subscribers[game_id].add(client_queue)

    def unsubscribe(self, game_id, client_queue):
        """Se dÃ©sabonner."""
        if game_id in self.subscribers:
            self.subscribers[game_id].discard(client_queue)

    def update_score(self, game_id, home_score, away_score, event_type='score'):
        """Mettre Ã  jour le score et notifier."""
        self.games[game_id] = {
            'home_score': home_score,
            'away_score': away_score,
            'timestamp': time.time()
        }

        # Notifier les subscribers
        if game_id in self.subscribers:
            message = format_sse_message(
                self.games[game_id],
                event=event_type,
                event_id=str(int(time.time() * 1000))
            )

            for client_queue in self.subscribers[game_id]:
                try:
                    client_queue.put(message)
                except:
                    pass

sports_service = SportsScoreService()

@app.route('/api/games/<game_id>/stream')
def game_stream(game_id):
    def event_stream():
        client_queue = Queue()
        sports_service.subscribe(game_id, client_queue)

        # Envoyer l'Ã©tat actuel
        if game_id in sports_service.games:
            yield format_sse_message(
                sports_service.games[game_id],
                event='initial'
            )

        try:
            while True:
                try:
                    message = client_queue.get(timeout=30)
                    yield message
                except:
                    yield ": heartbeat\n\n"
        finally:
            sports_service.unsubscribe(game_id, client_queue)

    return Response(
        event_stream(),
        mimetype='text/event-stream'
    )

# Simuler des updates de score
@app.route('/api/games/<game_id>/score', methods=['POST'])
def update_score(game_id):
    data = request.json
    sports_service.update_score(
        game_id,
        data['home_score'],
        data['away_score'],
        event_type=data.get('event_type', 'score')
    )
    return jsonify({'success': True})
```

```javascript
// Client - suivre plusieurs matchs
class SportsScoreTracker {
    constructor() {
        this.sources = new Map();
    }

    trackGame(gameId) {
        if (this.sources.has(gameId)) return;

        const source = new EventSource(`/api/games/${gameId}/stream`);

        source.addEventListener('initial', (event) => {
            const score = JSON.parse(event.data);
            this.updateScoreboard(gameId, score);
        });

        source.addEventListener('score', (event) => {
            const score = JSON.parse(event.data);
            this.updateScoreboard(gameId, score);
            this.highlightUpdate(gameId);
        });

        source.addEventListener('error', (event) => {
            console.error(`Error tracking game ${gameId}`);
        });

        this.sources.set(gameId, source);
    }

    stopTracking(gameId) {
        const source = this.sources.get(gameId);
        if (source) {
            source.close();
            this.sources.delete(gameId);
        }
    }

    updateScoreboard(gameId, score) {
        document.querySelector(`#game-${gameId} .home-score`).textContent = score.home_score;
        document.querySelector(`#game-${gameId} .away-score`).textContent = score.away_score;
    }

    highlightUpdate(gameId) {
        const element = document.querySelector(`#game-${gameId}`);
        element.classList.add('updated');
        setTimeout(() => element.classList.remove('updated'), 2000);
    }
}

const tracker = new SportsScoreTracker();
tracker.trackGame('game-123');
tracker.trackGame('game-456');
```

### 4. Progress tracking (Upload, traitement)

```javascript
/**
 * Suivi de progression de tÃ¢ches longues
 */

// Serveur (Node.js)
class TaskProgressTracker {
    constructor() {
        this.tasks = new Map(); // taskId -> { progress, clients }
    }

    createTask(taskId) {
        this.tasks.set(taskId, {
            progress: 0,
            status: 'pending',
            clients: new Set()
        });
    }

    addClient(taskId, res) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.clients.add(res);

            // Envoyer l'Ã©tat actuel
            res.write(formatSSEMessage({
                progress: task.progress,
                status: task.status
            }, 'progress'));
        }
    }

    updateProgress(taskId, progress, status = 'processing') {
        const task = this.tasks.get(taskId);
        if (!task) return;

        task.progress = progress;
        task.status = status;

        const message = formatSSEMessage({
            progress,
            status
        }, 'progress');

        task.clients.forEach(res => {
            try {
                res.write(message);
            } catch (error) {
                task.clients.delete(res);
            }
        });

        // Si terminÃ©, fermer les connexions
        if (status === 'completed' || status === 'error') {
            task.clients.forEach(res => {
                res.end();
            });
            task.clients.clear();
        }
    }
}

const progressTracker = new TaskProgressTracker();

app.post('/api/tasks/upload', upload.single('file'), async (req, res) => {
    const taskId = generateId();
    progressTracker.createTask(taskId);

    // DÃ©marrer le traitement en arriÃ¨re-plan
    processFile(req.file, taskId);

    res.json({ taskId });
});

app.get('/api/tasks/:taskId/progress', (req, res) => {
    const { taskId } = req.params;

    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');

    progressTracker.addClient(taskId, res);

    req.on('close', () => {
        // Cleanup gÃ©rÃ© par le tracker
    });
});

async function processFile(file, taskId) {
    try {
        progressTracker.updateProgress(taskId, 10, 'processing');

        // Ã‰tape 1 : Validation
        await validateFile(file);
        progressTracker.updateProgress(taskId, 30);

        // Ã‰tape 2 : Traitement
        await transformFile(file);
        progressTracker.updateProgress(taskId, 60);

        // Ã‰tape 3 : Sauvegarde
        await saveFile(file);
        progressTracker.updateProgress(taskId, 90);

        // TerminÃ©
        progressTracker.updateProgress(taskId, 100, 'completed');

    } catch (error) {
        progressTracker.updateProgress(taskId, 0, 'error');
    }
}

// Client
async function uploadWithProgress(file) {
    const formData = new FormData();
    formData.append('file', file);

    // DÃ©marrer l'upload
    const response = await fetch('/api/tasks/upload', {
        method: 'POST',
        body: formData
    });

    const { taskId } = await response.json();

    // S'abonner Ã  la progression
    const progressSource = new EventSource(`/api/tasks/${taskId}/progress`);

    progressSource.addEventListener('progress', (event) => {
        const { progress, status } = JSON.parse(event.data);

        updateProgressBar(progress);
        updateStatus(status);

        if (status === 'completed') {
            progressSource.close();
            showSuccess();
        } else if (status === 'error') {
            progressSource.close();
            showError();
        }
    });
}
```

---

## Limitations et workarounds

### 1. Limite de 6 connexions (HTTP/1.1)

**ProblÃ¨me** : Les navigateurs limitent Ã  6 connexions SSE par domaine.

```
Domain: example.com
â”œâ”€ Tab 1: EventSource('/api/events')      âœ“
â”œâ”€ Tab 2: EventSource('/api/notifications') âœ“
â”œâ”€ Tab 3: EventSource('/api/metrics')     âœ“
â”œâ”€ Tab 4: EventSource('/api/logs')        âœ“
â”œâ”€ Tab 5: EventSource('/api/updates')     âœ“
â”œâ”€ Tab 6: EventSource('/api/status')      âœ“
â””â”€ Tab 7: EventSource('/api/alerts')      âœ— BLOQUÃ‰ !
```

**Solutions** :

**A) Multiplexer sur une seule connexion**

```javascript
/**
 * Multiplexer plusieurs flux sur une connexion SSE
 */
class MultiplexedSSE {
    constructor(url) {
        this.source = new EventSource(url);
        this.listeners = new Map();

        // Router les messages selon le type
        this.source.addEventListener('message', (event) => {
            const { channel, data } = JSON.parse(event.data);

            const channelListeners = this.listeners.get(channel);
            if (channelListeners) {
                channelListeners.forEach(callback => callback(data));
            }
        });
    }

    subscribe(channel, callback) {
        if (!this.listeners.has(channel)) {
            this.listeners.set(channel, new Set());
        }
        this.listeners.get(channel).add(callback);
    }

    unsubscribe(channel, callback) {
        const channelListeners = this.listeners.get(channel);
        if (channelListeners) {
            channelListeners.delete(callback);
        }
    }
}

// Utilisation
const sse = new MultiplexedSSE('/api/stream');

sse.subscribe('notifications', (data) => {
    showNotification(data);
});

sse.subscribe('metrics', (data) => {
    updateDashboard(data);
});

sse.subscribe('logs', (data) => {
    appendLog(data);
});

// Serveur envoie des messages multiplexÃ©s
function broadcast(channel, data) {
    const message = formatSSEMessage({
        channel: channel,
        data: data
    });

    clients.forEach(client => client.res.write(message));
}
```

**B) Utiliser des subdomains**

```javascript
// Connexions sur diffÃ©rents subdomains = contournement de la limite
const notifications = new EventSource('https://notif.example.com/stream');
const metrics = new EventSource('https://metrics.example.com/stream');
const logs = new EventSource('https://logs.example.com/stream');
// Chaque subdomain a sa propre limite de 6 connexions
```

**C) Utiliser HTTP/2**

HTTP/2 n'a pas cette limitation car il utilise le multiplexage.

```nginx
# Nginx : activer HTTP/2
server {
    listen 443 ssl http2;

    location /api/events {
        proxy_pass http://backend;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }
}
```

### 2. Pas de headers custom

**ProblÃ¨me** : EventSource ne permet pas d'envoyer des headers custom (comme Authorization).

**Solutions** :

**A) Token dans l'URL** (Simple mais moins sÃ©curisÃ©)

```javascript
const token = localStorage.getItem('authToken');
const source = new EventSource(`/api/events?token=${token}`);

// Serveur valide le token
app.get('/api/events', (req, res) => {
    const token = req.query.token;

    if (!validateToken(token)) {
        return res.status(401).send('Unauthorized');
    }

    // Continue...
});
```

**B) Cookie (RecommandÃ©)**

```javascript
// Le navigateur envoie automatiquement les cookies
const source = new EventSource('/api/events', {
    withCredentials: true
});

// Serveur lit le cookie
app.get('/api/events', (req, res) => {
    const token = req.cookies.authToken;

    if (!validateToken(token)) {
        return res.status(401).send('Unauthorized');
    }

    // Continue...
});
```

**C) Polyfill avec fetch** (ContrÃ´le total)

```javascript
/**
 * Polyfill EventSource avec fetch pour custom headers
 */
class FetchEventSource {
    constructor(url, options = {}) {
        this.url = url;
        this.options = options;
        this.listeners = new Map();
        this.readyState = 0; // CONNECTING
        this.controller = null;
    }

    async connect() {
        this.controller = new AbortController();

        try {
            const response = await fetch(this.url, {
                headers: this.options.headers || {},
                signal: this.controller.signal
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            this.readyState = 1; // OPEN
            this.dispatch('open', {});

            // Lire le stream
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();

                if (done) break;

                buffer += decoder.decode(value, { stream: true });

                // Parser les messages SSE
                const lines = buffer.split('\n\n');
                buffer = lines.pop(); // Garder la derniÃ¨re ligne incomplÃ¨te

                lines.forEach(chunk => {
                    const event = this.parseSSE(chunk);
                    if (event) {
                        this.dispatch(event.type, event);
                    }
                });
            }

        } catch (error) {
            this.readyState = 2; // CLOSED
            this.dispatch('error', { error });
        }
    }

    parseSSE(chunk) {
        const lines = chunk.split('\n');
        const event = {
            type: 'message',
            data: '',
            id: null
        };

        lines.forEach(line => {
            if (line.startsWith('event:')) {
                event.type = line.substring(6).trim();
            } else if (line.startsWith('data:')) {
                event.data += line.substring(5).trim() + '\n';
            } else if (line.startsWith('id:')) {
                event.id = line.substring(3).trim();
            }
        });

        event.data = event.data.trim();
        return event.data ? event : null;
    }

    addEventListener(type, listener) {
        if (!this.listeners.has(type)) {
            this.listeners.set(type, new Set());
        }
        this.listeners.get(type).add(listener);
    }

    removeEventListener(type, listener) {
        const typeListeners = this.listeners.get(type);
        if (typeListeners) {
            typeListeners.delete(listener);
        }
    }

    dispatch(type, event) {
        const typeListeners = this.listeners.get(type);
        if (typeListeners) {
            typeListeners.forEach(listener => listener(event));
        }
    }

    close() {
        if (this.controller) {
            this.controller.abort();
        }
        this.readyState = 2; // CLOSED
    }
}

// Utilisation avec Authorization header
const source = new FetchEventSource('/api/events', {
    headers: {
        'Authorization': `Bearer ${token}`
    }
});

source.addEventListener('message', (event) => {
    console.log('Message:', event.data);
});

source.connect();
```

### 3. Buffering par les proxies

**ProblÃ¨me** : Certains proxies/load balancers bufferisent les rÃ©ponses SSE.

```
Client â”€â”€> Nginx â”€â”€> Backend
           â”‚
           â””â”€ Buffer 4KB
              â”‚
              â””â”€ Attend 4KB avant d'envoyer au client !
```

**Solutions** :

**A) Nginx : DÃ©sactiver le buffering**

```nginx
location /api/events {
    proxy_pass http://backend;

    # DÃ©sactiver le buffering pour SSE
    proxy_buffering off;
    proxy_cache off;
    proxy_set_header Connection '';
    proxy_http_version 1.1;
    chunked_transfer_encoding off;

    # Headers additionnels
    proxy_set_header X-Accel-Buffering no;
}
```

**B) Serveur : Envoyer un padding initial**

```python
@app.route('/api/events')
def sse_stream():
    def event_stream():
        # Padding pour forcer le flush
        yield ': ' + (' ' * 2048) + '\n\n'

        # Suite normale
        while True:
            # ...

    return Response(event_stream(), mimetype='text/event-stream')
```

**C) Heartbeat frÃ©quent**

```javascript
// Serveur : heartbeat toutes les 15s
setInterval(() => {
    clients.forEach(client => {
        client.res.write(': heartbeat\n\n');
    });
}, 15000);
```

---

## Anti-patterns Ã  Ã©viter

### âŒ 1. Envoyer des donnÃ©es binaires

```javascript
// INCORRECT : SSE est texte seulement
const imageData = Buffer.from(imageBytes);
res.write(`data: ${imageData}\n\n`); // âœ— Ne fonctionne pas
```

**Solution** : Encoder en base64 ou utiliser WebSocket

```javascript
// Encoder en base64
const imageBase64 = imageData.toString('base64');
res.write(`data: ${imageBase64}\n\n`); // âœ“

// Ou mieux : utiliser WebSocket pour binaire
```

### âŒ 2. Oublier les heartbeats

```javascript
// INCORRECT : Pas de heartbeat
app.get('/api/events', (req, res) => {
    res.setHeader('Content-Type', 'text/event-stream');

    // Connexion reste silencieuse pendant des heures
    // Proxies/NAT peuvent timeout
});
```

**Solution** : Heartbeat rÃ©gulier

```javascript
// CORRECT
const heartbeat = setInterval(() => {
    res.write(': heartbeat\n\n');
}, 30000);

req.on('close', () => {
    clearInterval(heartbeat);
});
```

### âŒ 3. Ne pas gÃ©rer la fermeture cÃ´tÃ© client

```javascript
// INCORRECT : Fuite de mÃ©moire
const source = new EventSource('/api/events');
// Jamais fermÃ© !
```

**Solution** : Cleanup appropriÃ©

```javascript
// CORRECT
const source = new EventSource('/api/events');

window.addEventListener('beforeunload', () => {
    source.close();
});

// Ou dans React
useEffect(() => {
    const source = new EventSource('/api/events');

    return () => {
        source.close(); // Cleanup
    };
}, []);
```

### âŒ 4. Broadcast sans vÃ©rifier la connexion

```javascript
// INCORRECT
function broadcast(message) {
    clients.forEach(client => {
        client.res.write(message); // Peut crash si client dÃ©connectÃ©
    });
}
```

**Solution** : Gestion d'erreur

```javascript
// CORRECT
function broadcast(message) {
    clients.forEach(client => {
        try {
            client.res.write(message);
        } catch (error) {
            console.error('Failed to send to client:', error);
            clients.delete(client);
        }
    });
}
```

---

## Checklist pour production

- [ ] **Content-Type** : `text/event-stream` configurÃ©
- [ ] **Heartbeat** : Commentaires envoyÃ©s toutes les 15-30s
- [ ] **Reconnexion** : GÃ©rÃ©e avec Last-Event-ID
- [ ] **Cleanup** : Listeners supprimÃ©s cÃ´tÃ© client
- [ ] **Limite connexions** : Multiplexage si nÃ©cessaire
- [ ] **Authentication** : Via cookie ou token URL
- [ ] **Proxy buffering** : DÃ©sactivÃ© (nginx, etc.)
- [ ] **Error handling** : Gestion des dÃ©connexions
- [ ] **Monitoring** : MÃ©triques exposÃ©es (nb clients, latence)
- [ ] **Load balancing** : Sticky sessions configurÃ©es
- [ ] **Fallback** : Polyfill pour IE si nÃ©cessaire
- [ ] **CORS** : Headers configurÃ©s si cross-origin
- [ ] **Compression** : DÃ©sactivÃ©e pour SSE

---

## Conclusion

**Server-Sent Events (SSE)** est une technologie Ã©lÃ©gante et simple pour la communication **unidirectionnelle** serveur â†’ client. C'est le choix idÃ©al pour :

- âœ… **Notifications push** (GitHub, Slack)
- âœ… **Live updates** (scores sportifs, prix)
- âœ… **Dashboards temps rÃ©el** (monitoring, analytics)
- âœ… **Progress tracking** (uploads, traitement)

**Avantages** :
- API native, pas de bibliothÃ¨que requise
- Reconnexion automatique
- Format texte simple et dÃ©boguable
- Compatible HTTP standard

**Limitations** :
- Unidirectionnel uniquement
- Limite de 6 connexions (HTTP/1.1)
- Pas de headers custom nativement
- Texte seulement

**Quand utiliser SSE vs WebSocket** :
- SSE : Communication serveur â†’ client, donnÃ©es textuelles, simplicitÃ©
- WebSocket : Communication bidirectionnelle, binaire, jeux/chat temps rÃ©el

**Prochaine section** : Nous explorerons **WebSocket**, la solution bidirectionnelle full-duplex pour les cas d'usage nÃ©cessitant une communication client â†” serveur.

---


â­ï¸ [WebSockets : communication bidirectionnelle full-duplex](/08-programmation-reseau/09.3-websockets.md)
