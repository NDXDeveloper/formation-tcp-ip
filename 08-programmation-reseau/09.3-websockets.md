ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 8.9.3 WebSockets : communication bidirectionnelle full-duplex

## Table des matiÃ¨res

### ğŸ“š Fondamentaux
- [Introduction](#introduction)
- [Le protocole WebSocket](#le-protocole-websocket)
  - [Handshake HTTP initial](#handshake-http-initial)
  - [Format des frames WebSocket](#format-des-frames-websocket)
  - [Fragmentation des messages](#fragmentation-des-messages)
  - [ContrÃ´le de la connexion](#contr%C3%B4le-de-la-connexion)

### ğŸ’» API et implÃ©mentations
- [API WebSocket (Client)](#api-websocket-client)
  - [Utilisation basique](#utilisation-basique)
  - [Wrapper rÃ©utilisable avec reconnexion](#wrapper-r%C3%A9utilisable-avec-reconnexion)
- [ImplÃ©mentations serveur](#impl%C3%A9mentations-serveur)
  - [Node.js (ws library)](#nodejs-ws-library)
  - [Python (websockets library)](#python-websockets-library)
  - [Go (gorilla/websocket)](#go-gorillawebsocket)

### ğŸ¯ Patterns avancÃ©s
- [Patterns avancÃ©s](#patterns-avanc%C3%A9s)
  - [1. Rooms et namespaces](#1-rooms-et-namespaces-socketio-style)
  - [2. Acknowledgements (ACK)](#2-acknowledgements-ack)
  - [3. Message ordering](#3-message-ordering-garantie-dordre)
  - [4. Binary protocol efficiency](#4-binary-protocol-efficiency)
  - [5. Compression (permessage-deflate)](#5-compression-permessage-deflate)

### ğŸŒ Cas d'usage rÃ©els
- [Cas d'usage rÃ©els](#cas-dusage-r%C3%A9els)
  - [1. Chat en temps rÃ©el (Slack-like)](#1-chat-en-temps-r%C3%A9el-slack-like)
  - [2. Jeu multijoueur en temps rÃ©el](#2-jeu-multijoueur-en-temps-r%C3%A9el)
  - [3. Collaboration temps rÃ©el (Google Docs-like)](#3-collaboration-temps-r%C3%A9el-google-docs-like)
  - [4. Trading platform (real-time market data)](#4-trading-platform-real-time-market-data)

### ğŸ”’ SÃ©curitÃ©
- [SÃ©curitÃ© WebSocket](#s%C3%A9curit%C3%A9-websocket)
  - [1. Authentification](#1-authentification)
  - [2. Rate limiting](#2-rate-limiting)
  - [3. Validation des messages](#3-validation-des-messages)
  - [4. Protection XSS et injection](#4-protection-xss-et-injection)
  - [5. CSRF protection](#5-csrf-protection)

### âš¡ Performance et monitoring
- [Optimisations et performance](#optimisations-et-performance)
  - [1. Message batching](#1-message-batching)
  - [2. Lazy loading et pagination](#2-lazy-loading-et-pagination)
  - [3. Connection pooling (serveur)](#3-connection-pooling-serveur)
- [Monitoring et debugging](#monitoring-et-debugging)
  - [1. MÃ©triques cÃ´tÃ© serveur](#1-m%C3%A9triques-c%C3%B4t%C3%A9-serveur)
  - [2. Logging structurÃ©](#2-logging-structur%C3%A9)
  - [3. Debugging tools](#3-debugging-tools)

### âœ… Production
- [Checklist pour production](#checklist-pour-production)
- [Conclusion](#conclusion)

---

## Navigation rapide par thÃ©matique

### ğŸ“ Pour dÃ©buter
1. [Introduction](#introduction) - Comprendre WebSocket
2. [API WebSocket basique](#utilisation-basique) - Premier code
3. [Serveur Node.js simple](#nodejs-ws-library) - Backend minimal

### ğŸ—ï¸ Pour architectes
1. [Patterns avancÃ©s](#patterns-avanc%C3%A9s) - Design patterns
2. [ScalabilitÃ©](#3-connection-pooling-serveur) - Scale horizontal
3. [SÃ©curitÃ©](#s%C3%A9curit%C3%A9-websocket) - Protection complÃ¨te

### ğŸš€ Pour production
1. [Performance](#optimisations-et-performance) - Optimisations
2. [Monitoring](#monitoring-et-debugging) - ObservabilitÃ©
3. [Checklist](#checklist-pour-production) - Avant le dÃ©ploiement

### ğŸ’¡ Exemples pratiques
1. [Chat temps rÃ©el](#1-chat-en-temps-r%C3%A9el-slack-like) - Application complÃ¨te
2. [Jeu multijoueur](#2-jeu-multijoueur-en-temps-r%C3%A9el) - Game server
3. [Google Docs-like](#3-collaboration-temps-r%C3%A9el-google-docs-like) - Collaboration
4. [Trading platform](#4-trading-platform-real-time-market-data) - Finance

---

## LÃ©gende des sections

- ğŸ“š **ThÃ©orie** - Concepts et protocole
- ğŸ’» **Code** - ImplÃ©mentations et exemples
- ğŸ¯ **AvancÃ©** - Patterns et techniques avancÃ©es
- ğŸŒ **Pratique** - Cas d'usage rÃ©els complets
- ğŸ”’ **SÃ©curitÃ©** - Protection et validation
- âš¡ **Performance** - Optimisations et monitoring
- âœ… **Production** - Checklist et best practices

---

## Introduction

**WebSocket** est un protocole de communication **bidirectionnel full-duplex** sur une seule connexion TCP. Contrairement Ã  HTTP qui est request-response, WebSocket permet au client ET au serveur d'envoyer des messages Ã  tout moment, **sans attendre une requÃªte**.

**Le problÃ¨me que WebSocket rÃ©sout** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           HTTP : Communication half-duplex          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  Client                         Serveur             â”‚
â”‚    â”‚â”€â”€â”€â”€ Request â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚                  â”‚
â”‚    â”‚                             â”‚ [Traite]         â”‚
â”‚    â”‚<â”€â”€â”€â”€ Response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                  â”‚
â”‚    â”‚                             â”‚                  â”‚
â”‚  Le serveur NE PEUT PAS initier une communication   â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        WebSocket : Communication full-duplex        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  Client                         Serveur             â”‚
â”‚    â”‚<â•â•â•â•â•â•â•â• Connexion ouverte â•â•â•â•â•â•â•â•â•â•>â”‚        â”‚
â”‚    â”‚                                       â”‚        â”‚
â”‚    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€ Message 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚        â”‚
â”‚    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€ Message 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚        â”‚
â”‚    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€ Message 3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚        â”‚
â”‚    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€ Message 4 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚        â”‚
â”‚    â”‚                                       â”‚        â”‚
â”‚  Les deux peuvent envoyer Ã  tout moment             â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Cas d'usage parfaits pour WebSocket** :
- ğŸ’¬ **Chat en temps rÃ©el** : messages bidirectionnels instantanÃ©s
- ğŸ® **Jeux multijoueurs** : Ã©tat du jeu synchronisÃ©
- ğŸ“ **Collaboration temps rÃ©el** : Google Docs, Figma
- ğŸ“Š **Trading** : prix en temps rÃ©el, ordres
- ğŸ”” **Notifications** : push instantanÃ© (mais SSE suffit souvent)

**Avantages** :
- âœ… **Bidirectionnel** : client â†” serveur sans restriction
- âœ… **Latence minimale** : < 10ms possible
- âœ… **Efficace** : headers minimaux (2-14 bytes par frame)
- âœ… **Binaire natif** : ArrayBuffer, Blob
- âœ… **Full-duplex** : envoi et rÃ©ception simultanÃ©s

**InconvÃ©nients** :
- âŒ **ComplexitÃ©** : protocole distinct, nÃ©cessite bibliothÃ¨que serveur
- âŒ **Pas de reconnexion auto** : Ã  gÃ©rer manuellement
- âŒ **CompatibilitÃ© proxies** : certains bloquent les connexions WebSocket
- âŒ **ScalabilitÃ©** : maintenir des connexions long-lived

---

## Le protocole WebSocket

### Handshake HTTP initial

WebSocket commence par un **upgrade HTTP** :

```http
# 1. Client â†’ Serveur : Demande d'upgrade
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Extensions: permessage-deflate

# 2. Serveur â†’ Client : Acceptation
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat

# Ã€ partir de maintenant : frames WebSocket binaires
```

**DÃ©tails du handshake** :

```javascript
// Sec-WebSocket-Key : clÃ© alÃ©atoire en base64 (16 bytes)
const key = btoa(crypto.getRandomValues(new Uint8Array(16)));

// Sec-WebSocket-Accept : dÃ©rivÃ© du key
// Accept = Base64(SHA1(Key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"))
const accept = btoa(
    sha1(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")
);
```

**Pourquoi ce mÃ©canisme ?**
- PrÃ©venir les attaques de type "cache poisoning"
- VÃ©rifier que le serveur comprend vraiment WebSocket
- EmpÃªcher les proxies de se mÃ©prendre sur la connexion

### Format des frames WebSocket

AprÃ¨s le handshake, les donnÃ©es sont Ã©changÃ©es via des **frames binaires** :

```
Frame WebSocket (RFC 6455):

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+

Opcodes:
0x0 = Continuation frame
0x1 = Text frame (UTF-8)
0x2 = Binary frame
0x8 = Connection close
0x9 = Ping
0xA = Pong
```

**CaractÃ©ristiques importantes** :

1. **FIN bit** : Indique si c'est le dernier fragment
2. **Opcode** : Type de donnÃ©es (texte, binaire, control)
3. **MASK** : Les messages client â†’ serveur DOIVENT Ãªtre masquÃ©s
4. **Payload length** : Longueur encodÃ©e sur 7, 16 ou 64 bits

**Exemple de frame simple** :

```
Message texte "Hello" du client au serveur:

81 85 37 fa 21 3d 7f 9f 4d 51 58

DÃ©codage:
81 = 10000001 (FIN=1, opcode=1 text)
85 = 10000101 (MASK=1, length=5)
37 fa 21 3d = Masking key
7f 9f 4d 51 58 = "Hello" masquÃ©
```

### Fragmentation des messages

Les gros messages peuvent Ãªtre fragmentÃ©s :

```
Message: "HelloWorld" fragmentÃ© en 3 frames

Frame 1: FIN=0, opcode=1 (text), data="Hello"
Frame 2: FIN=0, opcode=0 (continuation), data="Wor"
Frame 3: FIN=1, opcode=0 (continuation), data="ld"
```

### ContrÃ´le de la connexion

**Ping/Pong** : Heartbeat pour vÃ©rifier que la connexion est vivante.

```
Client â”€â”€[Ping]â”€â”€> Serveur
Client <â”€â”€[Pong]â”€â”€â”€ Serveur

Client â”€â”€[Ping "timestamp"]â”€â”€> Serveur
Client <â”€â”€[Pong "timestamp"]â”€â”€â”€ Serveur (mesure RTT)
```

**Close** : Fermeture propre de la connexion.

```
Client â”€â”€[Close 1000 "Normal"]â”€â”€> Serveur
Client <â”€â”€[Close 1000 "Normal"]â”€â”€â”€ Serveur
[TCP FIN]
```

**Codes de fermeture standard** :

```
1000 = Normal closure
1001 = Going away (page unload)
1002 = Protocol error
1003 = Unsupported data
1006 = Abnormal closure (no close frame)
1007 = Invalid frame payload data
1008 = Policy violation
1009 = Message too big
1010 = Mandatory extension missing
1011 = Internal server error
1015 = TLS handshake failure
```

---

## API WebSocket (Client)

### Utilisation basique

```javascript
/**
 * API WebSocket native du navigateur
 */

// CrÃ©er une connexion
const ws = new WebSocket('wss://server.example.com/chat');

// Ou avec sous-protocoles
const ws = new WebSocket('wss://server.example.com', ['chat', 'superchat']);

// Ã‰tats possibles
console.log(ws.readyState);
// 0 = CONNECTING (connexion en cours)
// 1 = OPEN (connectÃ©)
// 2 = CLOSING (fermeture en cours)
// 3 = CLOSED (fermÃ©)

// Ã‰vÃ©nement : connexion ouverte
ws.addEventListener('open', (event) => {
    console.log('WebSocket connected');

    // Envoyer un message texte
    ws.send('Hello Server!');

    // Envoyer du JSON
    ws.send(JSON.stringify({
        type: 'chat',
        message: 'Hello'
    }));

    // Envoyer du binaire
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setInt32(0, 42);
    ws.send(buffer);

    // Envoyer un Blob
    const blob = new Blob(['Hello'], { type: 'text/plain' });
    ws.send(blob);
});

// Ã‰vÃ©nement : message reÃ§u
ws.addEventListener('message', (event) => {
    console.log('Message received:', event.data);

    // event.data peut Ãªtre :
    // - String (si texte)
    // - ArrayBuffer (si binaire et binaryType='arraybuffer')
    // - Blob (si binaire et binaryType='blob', dÃ©faut)

    if (typeof event.data === 'string') {
        // Message texte
        const data = JSON.parse(event.data);
        handleMessage(data);
    } else if (event.data instanceof ArrayBuffer) {
        // Binaire ArrayBuffer
        const view = new DataView(event.data);
        const value = view.getInt32(0);
        console.log('Received binary:', value);
    } else if (event.data instanceof Blob) {
        // Binaire Blob
        event.data.arrayBuffer().then(buffer => {
            console.log('Received blob:', buffer);
        });
    }
});

// Configurer le type de donnÃ©es binaires
ws.binaryType = 'arraybuffer'; // ou 'blob'

// Ã‰vÃ©nement : erreur
ws.addEventListener('error', (event) => {
    console.error('WebSocket error:', event);
});

// Ã‰vÃ©nement : connexion fermÃ©e
ws.addEventListener('close', (event) => {
    console.log('WebSocket closed');
    console.log('Code:', event.code);
    console.log('Reason:', event.reason);
    console.log('Was clean:', event.wasClean);

    if (!event.wasClean) {
        console.error('Connection lost unexpectedly');
    }
});

// Fermer la connexion
// ws.close();
// ws.close(1000, 'Normal closure');

// VÃ©rifier le bufferedAmount (donnÃ©es en attente d'envoi)
console.log('Buffered bytes:', ws.bufferedAmount);
```

### Wrapper rÃ©utilisable avec reconnexion

```javascript
/**
 * WebSocket avec reconnexion automatique et heartbeat
 */
class ResilientWebSocket {
    constructor(url, options = {}) {
        this.url = url;
        this.protocols = options.protocols;
        this.ws = null;
        this.listeners = new Map();

        // Configuration reconnexion
        this.reconnectEnabled = options.reconnect !== false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = options.maxReconnectAttempts || Infinity;
        this.reconnectInterval = options.reconnectInterval || 1000;
        this.maxReconnectInterval = options.maxReconnectInterval || 30000;
        this.reconnectDecay = options.reconnectDecay || 1.5;

        // Heartbeat
        this.heartbeatEnabled = options.heartbeat !== false;
        this.heartbeatInterval = options.heartbeatInterval || 30000;
        this.heartbeatTimer = null;
        this.lastPong = null;

        // Callbacks
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
        this.onErrorCallback = null;

        // Queue de messages si pas connectÃ©
        this.messageQueue = [];
        this.queueEnabled = options.queue !== false;
    }

    connect() {
        try {
            this.ws = new WebSocket(this.url, this.protocols);

            // GÃ©rer l'ouverture
            this.ws.addEventListener('open', this.handleOpen.bind(this));

            // GÃ©rer les messages
            this.ws.addEventListener('message', this.handleMessage.bind(this));

            // GÃ©rer les erreurs
            this.ws.addEventListener('error', this.handleError.bind(this));

            // GÃ©rer la fermeture
            this.ws.addEventListener('close', this.handleClose.bind(this));

        } catch (error) {
            console.error('Failed to create WebSocket:', error);
            this.scheduleReconnect();
        }
    }

    handleOpen(event) {
        console.log('WebSocket connected');
        this.reconnectAttempts = 0;

        // DÃ©marrer le heartbeat
        if (this.heartbeatEnabled) {
            this.startHeartbeat();
        }

        // Envoyer les messages en queue
        if (this.queueEnabled && this.messageQueue.length > 0) {
            console.log(`Sending ${this.messageQueue.length} queued messages`);
            this.messageQueue.forEach(msg => this.send(msg));
            this.messageQueue = [];
        }

        // Callback
        if (this.onConnectCallback) {
            this.onConnectCallback(event);
        }

        // Dispatcher l'Ã©vÃ©nement open
        this.dispatch('open', event);
    }

    handleMessage(event) {
        // Reset lastPong pour heartbeat
        this.lastPong = Date.now();

        // Dispatcher aux listeners
        this.dispatch('message', event);
    }

    handleError(event) {
        console.error('WebSocket error:', event);

        if (this.onErrorCallback) {
            this.onErrorCallback(event);
        }

        this.dispatch('error', event);
    }

    handleClose(event) {
        console.log('WebSocket closed:', event.code, event.reason);

        this.stopHeartbeat();

        if (this.onDisconnectCallback) {
            this.onDisconnectCallback(event);
        }

        this.dispatch('close', event);

        // Reconnexion si nÃ©cessaire
        if (this.reconnectEnabled && event.code !== 1000) {
            this.scheduleReconnect();
        }
    }

    scheduleReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error('Max reconnect attempts reached');
            return;
        }

        this.reconnectAttempts++;

        const delay = Math.min(
            this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts - 1),
            this.maxReconnectInterval
        );

        console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);

        setTimeout(() => {
            this.connect();
        }, delay);
    }

    startHeartbeat() {
        this.lastPong = Date.now();

        this.heartbeatTimer = setInterval(() => {
            // VÃ©rifier si on a reÃ§u un pong rÃ©cemment
            const timeSinceLastPong = Date.now() - this.lastPong;

            if (timeSinceLastPong > this.heartbeatInterval * 2) {
                console.warn('Heartbeat timeout, closing connection');
                this.ws.close();
                return;
            }

            // Envoyer un ping (navigateur ne peut pas envoyer de ping frame,
            // donc on envoie un message texte)
            if (this.ws.readyState === WebSocket.OPEN) {
                this.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));
            }
        }, this.heartbeatInterval);
    }

    stopHeartbeat() {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
    }

    send(data) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(data);
        } else if (this.queueEnabled) {
            // Mettre en queue si pas connectÃ©
            console.log('WebSocket not open, queuing message');
            this.messageQueue.push(data);
        } else {
            console.error('WebSocket not open and queueing disabled');
        }
    }

    close(code = 1000, reason = '') {
        this.reconnectEnabled = false;

        if (this.ws) {
            this.ws.close(code, reason);
        }
    }

    on(eventType, listener) {
        if (!this.listeners.has(eventType)) {
            this.listeners.set(eventType, new Set());
        }
        this.listeners.get(eventType).add(listener);
        return this;
    }

    off(eventType, listener) {
        const eventListeners = this.listeners.get(eventType);
        if (eventListeners) {
            eventListeners.delete(listener);
        }
        return this;
    }

    dispatch(eventType, event) {
        const eventListeners = this.listeners.get(eventType);
        if (eventListeners) {
            eventListeners.forEach(listener => listener(event));
        }
    }

    onConnect(callback) {
        this.onConnectCallback = callback;
        return this;
    }

    onDisconnect(callback) {
        this.onDisconnectCallback = callback;
        return this;
    }

    onError(callback) {
        this.onErrorCallback = callback;
        return this;
    }

    isConnected() {
        return this.ws && this.ws.readyState === WebSocket.OPEN;
    }

    getReadyState() {
        return this.ws ? this.ws.readyState : WebSocket.CLOSED;
    }
}

// Utilisation
const ws = new ResilientWebSocket('wss://server.example.com/chat', {
    reconnect: true,
    maxReconnectAttempts: 10,
    heartbeat: true,
    heartbeatInterval: 30000,
    queue: true
});

ws.onConnect(() => {
    console.log('Connected!');
    ws.send(JSON.stringify({ type: 'auth', token: 'xxx' }));
});

ws.on('message', (event) => {
    const data = JSON.parse(event.data);

    switch (data.type) {
        case 'pong':
            // Heartbeat rÃ©ponse
            break;
        case 'chat':
            displayMessage(data);
            break;
        default:
            console.log('Unknown message type:', data.type);
    }
});

ws.connect();

// Envoyer un message
function sendMessage(text) {
    ws.send(JSON.stringify({
        type: 'chat',
        text: text,
        timestamp: Date.now()
    }));
}
```

---

## ImplÃ©mentations serveur

### Node.js (ws library)

```javascript
const WebSocket = require('ws');
const http = require('http');

/**
 * Serveur WebSocket avec Node.js
 */

// CrÃ©er un serveur HTTP
const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('WebSocket server running\n');
});

// CrÃ©er un serveur WebSocket
const wss = new WebSocket.Server({
    server,
    // Optionnel : vÃ©rification du handshake
    verifyClient: (info, callback) => {
        // VÃ©rifier l'origin
        const origin = info.origin;
        if (!isOriginAllowed(origin)) {
            callback(false, 403, 'Forbidden');
            return;
        }

        // VÃ©rifier l'authentification
        const token = new URL(info.req.url, 'ws://localhost').searchParams.get('token');
        if (!validateToken(token)) {
            callback(false, 401, 'Unauthorized');
            return;
        }

        callback(true);
    }
});

// Stocker les clients connectÃ©s
const clients = new Set();

// GÃ©rer les nouvelles connexions
wss.on('connection', (ws, req) => {
    const clientId = generateId();
    console.log(`Client ${clientId} connected`);

    // Ajouter le client
    clients.add(ws);
    ws.clientId = clientId;

    // Envoyer un message de bienvenue
    ws.send(JSON.stringify({
        type: 'welcome',
        clientId: clientId,
        message: 'Connected to WebSocket server'
    }));

    // GÃ©rer les messages du client
    ws.on('message', (data, isBinary) => {
        console.log(`Received from ${clientId}:`, data.toString());

        try {
            if (isBinary) {
                handleBinaryMessage(ws, data);
            } else {
                const message = JSON.parse(data);
                handleTextMessage(ws, message);
            }
        } catch (error) {
            console.error('Error handling message:', error);
            ws.send(JSON.stringify({
                type: 'error',
                message: 'Invalid message format'
            }));
        }
    });

    // GÃ©rer le ping/pong
    ws.on('ping', () => {
        console.log(`Ping from ${clientId}`);
    });

    ws.on('pong', () => {
        console.log(`Pong from ${clientId}`);
        ws.isAlive = true;
    });

    // GÃ©rer la fermeture
    ws.on('close', (code, reason) => {
        console.log(`Client ${clientId} disconnected:`, code, reason.toString());
        clients.delete(ws);
    });

    // GÃ©rer les erreurs
    ws.on('error', (error) => {
        console.error(`Error with client ${clientId}:`, error);
    });

    // Marquer comme vivant
    ws.isAlive = true;
});

function handleTextMessage(ws, message) {
    switch (message.type) {
        case 'ping':
            // RÃ©pondre au heartbeat client
            ws.send(JSON.stringify({
                type: 'pong',
                timestamp: message.timestamp
            }));
            break;

        case 'chat':
            // Broadcaster le message
            broadcast({
                type: 'chat',
                from: ws.clientId,
                text: message.text,
                timestamp: Date.now()
            }, ws); // Exclure l'expÃ©diteur
            break;

        case 'private':
            // Message privÃ©
            const target = findClientById(message.to);
            if (target) {
                target.send(JSON.stringify({
                    type: 'private',
                    from: ws.clientId,
                    text: message.text
                }));
            }
            break;

        default:
            console.log('Unknown message type:', message.type);
    }
}

function handleBinaryMessage(ws, data) {
    // Traiter les donnÃ©es binaires
    console.log(`Binary message (${data.length} bytes)`);

    // Exemple : renvoyer en Ã©cho
    ws.send(data, { binary: true });
}

function broadcast(message, exclude = null) {
    const data = JSON.stringify(message);

    clients.forEach((client) => {
        if (client !== exclude && client.readyState === WebSocket.OPEN) {
            client.send(data);
        }
    });
}

function findClientById(clientId) {
    for (const client of clients) {
        if (client.clientId === clientId) {
            return client;
        }
    }
    return null;
}

// Heartbeat pour dÃ©tecter les connexions mortes
const heartbeatInterval = setInterval(() => {
    wss.clients.forEach((ws) => {
        if (ws.isAlive === false) {
            console.log(`Client ${ws.clientId} timeout, terminating`);
            return ws.terminate();
        }

        ws.isAlive = false;
        ws.ping();
    });
}, 30000);

wss.on('close', () => {
    clearInterval(heartbeatInterval);
});

// DÃ©marrer le serveur
server.listen(8080, () => {
    console.log('WebSocket server listening on port 8080');
});

// Helpers
function generateId() {
    return Math.random().toString(36).substring(2, 15);
}

function isOriginAllowed(origin) {
    const allowedOrigins = ['http://localhost:3000', 'https://example.com'];
    return allowedOrigins.includes(origin);
}

function validateToken(token) {
    // ImplÃ©menter la validation JWT ou autre
    return token && token.length > 0;
}
```

### Python (websockets library)

```python
import asyncio
import websockets
import json
from datetime import datetime

"""
Serveur WebSocket avec Python asyncio
"""

# Stocker les clients connectÃ©s
connected_clients = set()
clients_by_id = {}

async def handle_client(websocket, path):
    """GÃ©rer une connexion client."""
    client_id = id(websocket)

    # Enregistrer le client
    connected_clients.add(websocket)
    clients_by_id[client_id] = websocket

    print(f"Client {client_id} connected. Total: {len(connected_clients)}")

    # Message de bienvenue
    await websocket.send(json.dumps({
        'type': 'welcome',
        'client_id': client_id,
        'message': 'Connected to WebSocket server'
    }))

    try:
        async for message in websocket:
            # DÃ©terminer si texte ou binaire
            if isinstance(message, str):
                await handle_text_message(websocket, client_id, message)
            else:
                await handle_binary_message(websocket, client_id, message)

    except websockets.exceptions.ConnectionClosed as e:
        print(f"Client {client_id} disconnected: {e.code} {e.reason}")

    except Exception as e:
        print(f"Error with client {client_id}: {e}")

    finally:
        # Cleanup
        connected_clients.discard(websocket)
        if client_id in clients_by_id:
            del clients_by_id[client_id]
        print(f"Client {client_id} cleaned up. Total: {len(connected_clients)}")

async def handle_text_message(websocket, client_id, message):
    """GÃ©rer un message texte."""
    try:
        data = json.loads(message)
        msg_type = data.get('type')

        if msg_type == 'ping':
            # Heartbeat
            await websocket.send(json.dumps({
                'type': 'pong',
                'timestamp': data.get('timestamp')
            }))

        elif msg_type == 'chat':
            # Broadcaster
            await broadcast({
                'type': 'chat',
                'from': client_id,
                'text': data.get('text'),
                'timestamp': datetime.now().isoformat()
            }, exclude=websocket)

        elif msg_type == 'private':
            # Message privÃ©
            target_id = data.get('to')
            target = clients_by_id.get(target_id)

            if target:
                await target.send(json.dumps({
                    'type': 'private',
                    'from': client_id,
                    'text': data.get('text')
                }))
            else:
                await websocket.send(json.dumps({
                    'type': 'error',
                    'message': f'Client {target_id} not found'
                }))
        else:
            print(f"Unknown message type: {msg_type}")

    except json.JSONDecodeError:
        await websocket.send(json.dumps({
            'type': 'error',
            'message': 'Invalid JSON'
        }))
    except Exception as e:
        print(f"Error handling message: {e}")

async def handle_binary_message(websocket, client_id, data):
    """GÃ©rer un message binaire."""
    print(f"Binary message from {client_id}: {len(data)} bytes")

    # Exemple : renvoyer en Ã©cho
    await websocket.send(data)

async def broadcast(message, exclude=None):
    """Envoyer un message Ã  tous les clients."""
    data = json.dumps(message)

    tasks = []
    for client in connected_clients:
        if client != exclude and client.open:
            tasks.append(client.send(data))

    if tasks:
        await asyncio.gather(*tasks, return_exceptions=True)

async def heartbeat():
    """Envoyer des pings pÃ©riodiques."""
    while True:
        await asyncio.sleep(30)

        tasks = []
        for client in connected_clients:
            if client.open:
                tasks.append(client.ping())

        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)

            # VÃ©rifier les erreurs
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    print(f"Ping failed: {result}")

async def main():
    """Point d'entrÃ©e principal."""
    # DÃ©marrer le heartbeat
    asyncio.create_task(heartbeat())

    # DÃ©marrer le serveur WebSocket
    async with websockets.serve(
        handle_client,
        'localhost',
        8080,
        # Options
        max_size=10 * 1024 * 1024,  # 10MB max message
        compression=None,  # Ou 'deflate' pour compression
        ping_interval=30,
        ping_timeout=10
    ):
        print("WebSocket server running on ws://localhost:8080")
        await asyncio.Future()  # Run forever

if __name__ == '__main__':
    asyncio.run(main())
```

### Go (gorilla/websocket)

```go
package main

import (
    "encoding/json"
    "log"
    "net/http"
    "sync"
    "time"

    "github.com/gorilla/websocket"
)

// Upgrader configure l'upgrade HTTP â†’ WebSocket
var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,

    // VÃ©rification de l'origin
    CheckOrigin: func(r *http.Request) bool {
        origin := r.Header.Get("Origin")
        // ImplÃ©menter la vÃ©rification
        return origin == "http://localhost:3000" || origin == "https://example.com"
    },
}

// Client reprÃ©sente une connexion WebSocket
type Client struct {
    ID   string
    Conn *websocket.Conn
    Send chan []byte
    Hub  *Hub
}

// Hub gÃ¨re tous les clients connectÃ©s
type Hub struct {
    clients    map[*Client]bool
    clientsMux sync.RWMutex

    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

// Message reprÃ©sente un message JSON
type Message struct {
    Type      string      `json:"type"`
    From      string      `json:"from,omitempty"`
    To        string      `json:"to,omitempty"`
    Text      string      `json:"text,omitempty"`
    Timestamp int64       `json:"timestamp,omitempty"`
    Data      interface{} `json:"data,omitempty"`
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte, 256),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.clientsMux.Lock()
            h.clients[client] = true
            h.clientsMux.Unlock()
            log.Printf("Client %s registered. Total: %d", client.ID, len(h.clients))

        case client := <-h.unregister:
            h.clientsMux.Lock()
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.Send)
            }
            h.clientsMux.Unlock()
            log.Printf("Client %s unregistered. Total: %d", client.ID, len(h.clients))

        case message := <-h.broadcast:
            h.clientsMux.RLock()
            for client := range h.clients {
                select {
                case client.Send <- message:
                default:
                    // Canal plein, fermer le client
                    close(client.Send)
                    delete(h.clients, client)
                }
            }
            h.clientsMux.RUnlock()
        }
    }
}

func (c *Client) ReadPump() {
    defer func() {
        c.Hub.unregister <- c
        c.Conn.Close()
    }()

    // Configuration
    c.Conn.SetReadLimit(512 * 1024) // 512KB max
    c.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
    c.Conn.SetPongHandler(func(string) error {
        c.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        return nil
    })

    for {
        messageType, message, err := c.Conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                log.Printf("Unexpected close error: %v", err)
            }
            break
        }

        if messageType == websocket.TextMessage {
            c.handleTextMessage(message)
        } else if messageType == websocket.BinaryMessage {
            c.handleBinaryMessage(message)
        }
    }
}

func (c *Client) WritePump() {
    ticker := time.NewTicker(30 * time.Second)
    defer func() {
        ticker.Stop()
        c.Conn.Close()
    }()

    for {
        select {
        case message, ok := <-c.Send:
            c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))

            if !ok {
                // Hub a fermÃ© le canal
                c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }

            if err := c.Conn.WriteMessage(websocket.TextMessage, message); err != nil {
                return
            }

        case <-ticker.C:
            // Envoyer un ping
            c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
            if err := c.Conn.WriteMessage(websocket.PingMessage, nil); err != nil {
                return
            }
        }
    }
}

func (c *Client) handleTextMessage(data []byte) {
    var msg Message

    if err := json.Unmarshal(data, &msg); err != nil {
        log.Printf("Invalid JSON: %v", err)
        return
    }

    switch msg.Type {
    case "ping":
        // Heartbeat
        c.sendMessage(Message{
            Type:      "pong",
            Timestamp: msg.Timestamp,
        })

    case "chat":
        // Broadcaster
        msg.From = c.ID
        msg.Timestamp = time.Now().Unix()

        msgBytes, _ := json.Marshal(msg)
        c.Hub.broadcast <- msgBytes

    case "private":
        // Message privÃ© (Ã  implÃ©menter)
        log.Printf("Private message to %s: %s", msg.To, msg.Text)

    default:
        log.Printf("Unknown message type: %s", msg.Type)
    }
}

func (c *Client) handleBinaryMessage(data []byte) {
    log.Printf("Binary message: %d bytes", len(data))

    // Renvoyer en Ã©cho
    c.Send <- data
}

func (c *Client) sendMessage(msg Message) {
    data, err := json.Marshal(msg)
    if err != nil {
        log.Printf("Failed to marshal message: %v", err)
        return
    }

    c.Send <- data
}

func serveWs(hub *Hub, w http.ResponseWriter, r *http.Request) {
    // Upgrade HTTP â†’ WebSocket
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Println("Upgrade error:", err)
        return
    }

    // CrÃ©er le client
    client := &Client{
        ID:   generateID(),
        Conn: conn,
        Send: make(chan []byte, 256),
        Hub:  hub,
    }

    // Enregistrer
    hub.register <- client

    // Message de bienvenue
    client.sendMessage(Message{
        Type: "welcome",
        Data: map[string]string{
            "client_id": client.ID,
            "message":   "Connected to WebSocket server",
        },
    })

    // DÃ©marrer les goroutines
    go client.WritePump()
    go client.ReadPump()
}

func generateID() string {
    return fmt.Sprintf("%d", time.Now().UnixNano())
}

func main() {
    hub := NewHub()
    go hub.Run()

    http.HandleFunc("/ws", func(w http.ResponseWriter, r *http.Request) {
        serveWs(hub, w, r)
    })

    log.Println("WebSocket server running on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

---

## Patterns avancÃ©s

### 1. Rooms et namespaces (Socket.IO style)

```javascript
/**
 * SystÃ¨me de rooms pour WebSocket
 */

class RoomManager {
    constructor() {
        this.rooms = new Map(); // roomId -> Set of clients
        this.clientRooms = new Map(); // client -> Set of roomIds
    }

    join(client, roomId) {
        // Ajouter le client Ã  la room
        if (!this.rooms.has(roomId)) {
            this.rooms.set(roomId, new Set());
        }
        this.rooms.get(roomId).add(client);

        // Tracker les rooms du client
        if (!this.clientRooms.has(client)) {
            this.clientRooms.set(client, new Set());
        }
        this.clientRooms.get(client).add(roomId);

        console.log(`Client joined room ${roomId}`);
    }

    leave(client, roomId) {
        const room = this.rooms.get(roomId);
        if (room) {
            room.delete(client);

            if (room.size === 0) {
                this.rooms.delete(roomId);
            }
        }

        const rooms = this.clientRooms.get(client);
        if (rooms) {
            rooms.delete(roomId);
        }

        console.log(`Client left room ${roomId}`);
    }

    leaveAll(client) {
        const rooms = this.clientRooms.get(client);
        if (rooms) {
            rooms.forEach(roomId => {
                this.leave(client, roomId);
            });
        }
        this.clientRooms.delete(client);
    }

    broadcast(roomId, message, exclude = null) {
        const room = this.rooms.get(roomId);
        if (!room) return;

        room.forEach(client => {
            if (client !== exclude && client.readyState === WebSocket.OPEN) {
                client.send(message);
            }
        });
    }

    getClients(roomId) {
        return this.rooms.get(roomId) || new Set();
    }

    getRooms(client) {
        return this.clientRooms.get(client) || new Set();
    }
}

// Utilisation
const roomManager = new RoomManager();

wss.on('connection', (ws) => {
    ws.on('message', (data) => {
        const message = JSON.parse(data);

        switch (message.type) {
            case 'join':
                roomManager.join(ws, message.room);

                // Notifier les autres dans la room
                roomManager.broadcast(message.room, JSON.stringify({
                    type: 'userJoined',
                    user: ws.clientId,
                    room: message.room
                }), ws);
                break;

            case 'leave':
                roomManager.leave(ws, message.room);
                break;

            case 'chat':
                // Envoyer seulement aux clients dans la room
                roomManager.broadcast(message.room, JSON.stringify({
                    type: 'chat',
                    from: ws.clientId,
                    text: message.text,
                    room: message.room
                }), ws);
                break;
        }
    });

    ws.on('close', () => {
        // Quitter toutes les rooms
        roomManager.leaveAll(ws);
    });
});
```

### 2. Acknowledgements (ACK)

```javascript
/**
 * SystÃ¨me d'acknowledgement pour garantir la rÃ©ception
 */

class AckManager {
    constructor(ws) {
        this.ws = ws;
        this.pendingAcks = new Map(); // messageId -> { resolve, reject, timeout }
        this.nextMessageId = 1;
        this.ackTimeout = 5000; // 5 secondes
    }

    send(data, requireAck = false) {
        const messageId = this.nextMessageId++;

        const message = {
            id: messageId,
            ...data
        };

        this.ws.send(JSON.stringify(message));

        if (requireAck) {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    this.pendingAcks.delete(messageId);
                    reject(new Error(`ACK timeout for message ${messageId}`));
                }, this.ackTimeout);

                this.pendingAcks.set(messageId, { resolve, reject, timeout });
            });
        }
    }

    handleAck(messageId) {
        const pending = this.pendingAcks.get(messageId);
        if (pending) {
            clearTimeout(pending.timeout);
            pending.resolve();
            this.pendingAcks.delete(messageId);
        }
    }

    handleNack(messageId, error) {
        const pending = this.pendingAcks.get(messageId);
        if (pending) {
            clearTimeout(pending.timeout);
            pending.reject(new Error(error));
            this.pendingAcks.delete(messageId);
        }
    }
}

// Client
const ackManager = new AckManager(ws);

ws.addEventListener('message', (event) => {
    const data = JSON.parse(event.data);

    if (data.type === 'ack') {
        ackManager.handleAck(data.messageId);
    } else if (data.type === 'nack') {
        ackManager.handleNack(data.messageId, data.error);
    }
});

// Envoyer avec ACK
async function sendChatMessage(text) {
    try {
        await ackManager.send({
            type: 'chat',
            text: text
        }, true);

        console.log('Message delivered!');
    } catch (error) {
        console.error('Message delivery failed:', error);
    }
}

// Serveur : envoyer les ACKs
ws.on('message', (data) => {
    const message = JSON.parse(data);

    try {
        // Traiter le message
        handleMessage(message);

        // Envoyer ACK
        ws.send(JSON.stringify({
            type: 'ack',
            messageId: message.id
        }));

    } catch (error) {
        // Envoyer NACK
        ws.send(JSON.stringify({
            type: 'nack',
            messageId: message.id,
            error: error.message
        }));
    }
});
```

### 3. Message ordering (garantie d'ordre)

```javascript
/**
 * Garantir l'ordre des messages mÃªme avec reconnexions
 */

class OrderedMessageQueue {
    constructor(ws) {
        this.ws = ws;
        this.sendQueue = [];
        this.nextSendSeq = 1;
        this.lastReceivedSeq = 0;
        this.receivedBuffer = new Map(); // seq -> message
    }

    send(data) {
        const seq = this.nextSendSeq++;

        const message = {
            seq: seq,
            ...data
        };

        this.sendQueue.push(message);
        this.flushQueue();
    }

    flushQueue() {
        if (this.ws.readyState !== WebSocket.OPEN) return;

        while (this.sendQueue.length > 0) {
            const message = this.sendQueue[0];

            try {
                this.ws.send(JSON.stringify(message));
                this.sendQueue.shift(); // Retirer seulement si envoyÃ©
            } catch (error) {
                console.error('Failed to send message:', error);
                break;
            }
        }
    }

    handleReceive(message) {
        const seq = message.seq;

        if (seq === this.lastReceivedSeq + 1) {
            // Message dans l'ordre
            this.processMessage(message);
            this.lastReceivedSeq = seq;

            // VÃ©rifier le buffer pour les messages suivants
            this.processBuffer();
        } else if (seq > this.lastReceivedSeq + 1) {
            // Message futur : mettre en buffer
            this.receivedBuffer.set(seq, message);
            console.log(`Buffered out-of-order message seq=${seq}`);
        } else {
            // Message dÃ©jÃ  reÃ§u : ignorer
            console.log(`Duplicate message seq=${seq}, ignoring`);
        }
    }

    processBuffer() {
        while (this.receivedBuffer.has(this.lastReceivedSeq + 1)) {
            const nextSeq = this.lastReceivedSeq + 1;
            const message = this.receivedBuffer.get(nextSeq);

            this.processMessage(message);
            this.lastReceivedSeq = nextSeq;
            this.receivedBuffer.delete(nextSeq);
        }
    }

    processMessage(message) {
        console.log('Processing message:', message);
        // Traiter le message dans l'ordre
    }

    onReconnect() {
        // AprÃ¨s reconnexion, renvoyer les messages en queue
        console.log(`Resending ${this.sendQueue.length} queued messages`);
        this.flushQueue();
    }
}
```

### 4. Binary protocol efficiency

```javascript
/**
 * Protocole binaire efficace pour WebSocket
 */

class BinaryProtocol {
    constructor() {
        // Types de messages
        this.MESSAGE_TYPES = {
            PING: 0x01,
            PONG: 0x02,
            CHAT: 0x03,
            POSITION: 0x04,
            ACTION: 0x05
        };
    }

    /**
     * Encoder un message de chat
     * Format: [type:1byte][userId:4bytes][textLength:2bytes][text:Nbytes]
     */
    encodeChatMessage(userId, text) {
        const encoder = new TextEncoder();
        const textBytes = encoder.encode(text);

        const buffer = new ArrayBuffer(1 + 4 + 2 + textBytes.length);
        const view = new DataView(buffer);

        let offset = 0;

        // Type
        view.setUint8(offset, this.MESSAGE_TYPES.CHAT);
        offset += 1;

        // User ID
        view.setUint32(offset, userId, true); // little-endian
        offset += 4;

        // Text length
        view.setUint16(offset, textBytes.length, true);
        offset += 2;

        // Text
        const uint8View = new Uint8Array(buffer);
        uint8View.set(textBytes, offset);

        return buffer;
    }

    /**
     * DÃ©coder un message de chat
     */
    decodeChatMessage(buffer) {
        const view = new DataView(buffer);
        let offset = 1; // Skip type byte

        // User ID
        const userId = view.getUint32(offset, true);
        offset += 4;

        // Text length
        const textLength = view.getUint16(offset, true);
        offset += 2;

        // Text
        const textBytes = new Uint8Array(buffer, offset, textLength);
        const decoder = new TextDecoder();
        const text = decoder.decode(textBytes);

        return { userId, text };
    }

    /**
     * Encoder une position (jeu)
     * Format: [type:1byte][playerId:4bytes][x:4bytes][y:4bytes][z:4bytes][timestamp:8bytes]
     */
    encodePosition(playerId, x, y, z) {
        const buffer = new ArrayBuffer(1 + 4 + 4 + 4 + 4 + 8);
        const view = new DataView(buffer);

        view.setUint8(0, this.MESSAGE_TYPES.POSITION);
        view.setUint32(1, playerId, true);
        view.setFloat32(5, x, true);
        view.setFloat32(9, y, true);
        view.setFloat32(13, z, true);
        view.setBigUint64(17, BigInt(Date.now()), true);

        return buffer;
    }

    /**
     * DÃ©coder une position
     */
    decodePosition(buffer) {
        const view = new DataView(buffer);

        return {
            playerId: view.getUint32(1, true),
            x: view.getFloat32(5, true),
            y: view.getFloat32(9, true),
            z: view.getFloat32(13, true),
            timestamp: Number(view.getBigUint64(17, true))
        };
    }

    /**
     * Dispatcher selon le type
     */
    decode(buffer) {
        const view = new DataView(buffer);
        const type = view.getUint8(0);

        switch (type) {
            case this.MESSAGE_TYPES.CHAT:
                return { type: 'chat', ...this.decodeChatMessage(buffer) };
            case this.MESSAGE_TYPES.POSITION:
                return { type: 'position', ...this.decodePosition(buffer) };
            // ... autres types
            default:
                throw new Error(`Unknown message type: ${type}`);
        }
    }
}

// Utilisation
const protocol = new BinaryProtocol();

ws.binaryType = 'arraybuffer';

// Envoyer
const positionBuffer = protocol.encodePosition(123, 10.5, 20.3, 5.0);
ws.send(positionBuffer);

// Recevoir
ws.addEventListener('message', (event) => {
    if (event.data instanceof ArrayBuffer) {
        const message = protocol.decode(event.data);
        console.log('Decoded:', message);
    }
});

// Comparaison taille: JSON vs Binaire
const jsonMessage = JSON.stringify({
    type: 'position',
    playerId: 123,
    x: 10.5,
    y: 20.3,
    z: 5.0,
    timestamp: Date.now()
});
console.log('JSON size:', jsonMessage.length); // ~80 bytes

const binaryMessage = protocol.encodePosition(123, 10.5, 20.3, 5.0);
console.log('Binary size:', binaryMessage.byteLength); // 25 bytes

// Ã‰conomie: 68% de rÃ©duction !
```

### 5. Compression (permessage-deflate)

```javascript
/**
 * NÃ©gociation de compression WebSocket
 */

// Client : demander la compression
const ws = new WebSocket('wss://server.example.com', {
    perMessageDeflate: true
});

// Serveur Node.js : activer la compression
const wss = new WebSocket.Server({
    server,
    perMessageDeflate: {
        zlibDeflateOptions: {
            level: 6 // Niveau de compression (0-9)
        },
        zlibInflateOptions: {
            chunkSize: 10 * 1024
        },
        // Seuil en dessous duquel on ne compresse pas
        threshold: 1024 // 1KB
    }
});

// Serveur Go
var upgrader = websocket.Upgrader{
    EnableCompression: true,
}

// Serveur Python
async with websockets.serve(
    handle_client,
    'localhost',
    8080,
    compression='deflate'  # ou None pour dÃ©sactiver
):
    await asyncio.Future()
```

**Mesure de l'impact** :

```javascript
/**
 * Benchmark: compression WebSocket
 */

class CompressionBenchmark {
    constructor(ws) {
        this.ws = ws;
        this.stats = {
            messagesSent: 0,
            bytesSent: 0,
            messagesReceived: 0,
            bytesReceived: 0,
            startTime: Date.now()
        };
    }

    send(data) {
        const size = typeof data === 'string'
            ? new Blob([data]).size
            : data.byteLength;

        this.stats.bytesSent += size;
        this.stats.messagesSent++;

        this.ws.send(data);
    }

    onMessage(event) {
        const size = typeof event.data === 'string'
            ? new Blob([event.data]).size
            : event.data.byteLength;

        this.stats.bytesReceived += size;
        this.stats.messagesReceived++;
    }

    getReport() {
        const elapsed = (Date.now() - this.stats.startTime) / 1000;

        return {
            ...this.stats,
            elapsed: elapsed,
            avgMessageSize: this.stats.bytesSent / this.stats.messagesSent,
            throughput: this.stats.bytesSent / elapsed / 1024, // KB/s
            messagesPerSecond: this.stats.messagesSent / elapsed
        };
    }
}

// Test
const benchmark = new CompressionBenchmark(ws);

ws.addEventListener('message', (event) => {
    benchmark.onMessage(event);
});

// Envoyer 1000 messages JSON
for (let i = 0; i < 1000; i++) {
    const message = {
        type: 'data',
        payload: 'x'.repeat(1000), // 1KB de donnÃ©es rÃ©pÃ©titives
        timestamp: Date.now()
    };

    benchmark.send(JSON.stringify(message));
}

setTimeout(() => {
    console.log('Benchmark results:', benchmark.getReport());
}, 5000);

/*
Sans compression:
- Bytes sent: ~1,050,000
- Throughput: ~210 KB/s

Avec compression (donnÃ©es rÃ©pÃ©titives):
- Bytes sent: ~50,000 (95% de rÃ©duction!)
- Throughput: ~10 KB/s (mais latence rÃ©duite)
*/
```

---

## Cas d'usage rÃ©els

### 1. Chat en temps rÃ©el (Slack-like)

```javascript
/**
 * Application de chat complÃ¨te avec WebSocket
 */

// Client
class ChatClient {
    constructor(wsUrl, userId) {
        this.wsUrl = wsUrl;
        this.userId = userId;
        this.ws = null;
        this.currentRoom = null;
        this.typingUsers = new Set();
        this.typingTimeout = null;
    }

    connect() {
        this.ws = new ResilientWebSocket(this.wsUrl, {
            reconnect: true,
            heartbeat: true
        });

        this.ws.onConnect(() => {
            this.authenticate();
        });

        this.ws.on('message', (event) => {
            const message = JSON.parse(event.data);
            this.handleMessage(message);
        });
    }

    authenticate() {
        this.send({
            type: 'auth',
            userId: this.userId,
            token: localStorage.getItem('authToken')
        });
    }

    joinRoom(roomId) {
        this.currentRoom = roomId;
        this.send({
            type: 'join',
            room: roomId
        });
    }

    sendMessage(text) {
        if (!this.currentRoom) return;

        this.send({
            type: 'chat',
            room: this.currentRoom,
            text: text,
            timestamp: Date.now()
        });

        // ArrÃªter l'indicateur "typing"
        this.stopTyping();
    }

    startTyping() {
        if (!this.currentRoom) return;

        // Envoyer l'indicateur de frappe
        this.send({
            type: 'typing',
            room: this.currentRoom,
            isTyping: true
        });

        // Auto-stop aprÃ¨s 3 secondes d'inactivitÃ©
        clearTimeout(this.typingTimeout);
        this.typingTimeout = setTimeout(() => {
            this.stopTyping();
        }, 3000);
    }

    stopTyping() {
        if (!this.currentRoom) return;

        clearTimeout(this.typingTimeout);

        this.send({
            type: 'typing',
            room: this.currentRoom,
            isTyping: false
        });
    }

    handleMessage(message) {
        switch (message.type) {
            case 'chat':
                this.displayMessage(message);
                break;

            case 'typing':
                if (message.isTyping) {
                    this.typingUsers.add(message.userId);
                } else {
                    this.typingUsers.delete(message.userId);
                }
                this.updateTypingIndicator();
                break;

            case 'userJoined':
                this.showNotification(`${message.userName} joined`);
                break;

            case 'userLeft':
                this.showNotification(`${message.userName} left`);
                break;

            case 'messageDelivered':
                this.markMessageAsDelivered(message.messageId);
                break;

            case 'messageRead':
                this.markMessageAsRead(message.messageId);
                break;
        }
    }

    displayMessage(message) {
        const messageElement = document.createElement('div');
        messageElement.className = 'message';
        messageElement.innerHTML = `
            <div class="message-header">
                <span class="user">${message.userName}</span>
                <span class="time">${new Date(message.timestamp).toLocaleTimeString()}</span>
            </div>
            <div class="message-text">${this.escapeHtml(message.text)}</div>
        `;

        document.getElementById('messages').appendChild(messageElement);

        // Scroll vers le bas
        messageElement.scrollIntoView({ behavior: 'smooth' });

        // Marquer comme lu
        this.send({
            type: 'markRead',
            messageId: message.id
        });
    }

    updateTypingIndicator() {
        const indicator = document.getElementById('typing-indicator');

        if (this.typingUsers.size === 0) {
            indicator.textContent = '';
        } else if (this.typingUsers.size === 1) {
            const user = Array.from(this.typingUsers)[0];
            indicator.textContent = `${user} is typing...`;
        } else {
            indicator.textContent = `${this.typingUsers.size} people are typing...`;
        }
    }

    send(data) {
        this.ws.send(JSON.stringify(data));
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// Serveur (Node.js)
class ChatServer {
    constructor(wss) {
        this.wss = wss;
        this.rooms = new Map(); // roomId -> Set of clients
        this.clients = new Map(); // ws -> client info

        this.setupHandlers();
    }

    setupHandlers() {
        this.wss.on('connection', (ws) => {
            console.log('Client connected');

            ws.on('message', (data) => {
                this.handleMessage(ws, JSON.parse(data));
            });

            ws.on('close', () => {
                this.handleDisconnect(ws);
            });
        });
    }

    handleMessage(ws, message) {
        switch (message.type) {
            case 'auth':
                this.authenticateClient(ws, message);
                break;

            case 'join':
                this.joinRoom(ws, message.room);
                break;

            case 'chat':
                this.handleChatMessage(ws, message);
                break;

            case 'typing':
                this.handleTyping(ws, message);
                break;

            case 'markRead':
                this.handleMarkRead(ws, message);
                break;
        }
    }

    authenticateClient(ws, message) {
        // Valider le token
        const user = validateToken(message.token);

        if (!user) {
            ws.close(1008, 'Invalid token');
            return;
        }

        // Stocker les infos client
        this.clients.set(ws, {
            userId: user.id,
            userName: user.name,
            rooms: new Set()
        });

        ws.send(JSON.stringify({
            type: 'authenticated',
            userId: user.id
        }));
    }

    joinRoom(ws, roomId) {
        const client = this.clients.get(ws);
        if (!client) return;

        // Ajouter Ã  la room
        if (!this.rooms.has(roomId)) {
            this.rooms.set(roomId, new Set());
        }
        this.rooms.get(roomId).add(ws);
        client.rooms.add(roomId);

        // Notifier les autres
        this.broadcastToRoom(roomId, {
            type: 'userJoined',
            userId: client.userId,
            userName: client.userName,
            room: roomId
        }, ws);

        // Envoyer l'historique
        this.sendRoomHistory(ws, roomId);
    }

    handleChatMessage(ws, message) {
        const client = this.clients.get(ws);
        if (!client) return;

        // Sauvegarder en DB
        const savedMessage = saveMessageToDB({
            userId: client.userId,
            room: message.room,
            text: message.text,
            timestamp: message.timestamp
        });

        // Broadcaster
        this.broadcastToRoom(message.room, {
            type: 'chat',
            id: savedMessage.id,
            userId: client.userId,
            userName: client.userName,
            text: message.text,
            timestamp: message.timestamp
        });

        // Confirmer au sender
        ws.send(JSON.stringify({
            type: 'messageDelivered',
            messageId: savedMessage.id
        }));
    }

    handleTyping(ws, message) {
        const client = this.clients.get(ws);
        if (!client) return;

        this.broadcastToRoom(message.room, {
            type: 'typing',
            userId: client.userId,
            userName: client.userName,
            isTyping: message.isTyping
        }, ws);
    }

    handleMarkRead(ws, message) {
        // Mettre Ã  jour en DB
        markMessageAsRead(message.messageId, this.clients.get(ws).userId);

        // Notifier l'expÃ©diteur
        const msg = getMessageById(message.messageId);
        const senderWs = this.findClientByUserId(msg.userId);

        if (senderWs) {
            senderWs.send(JSON.stringify({
                type: 'messageRead',
                messageId: message.messageId,
                readBy: this.clients.get(ws).userId
            }));
        }
    }

    broadcastToRoom(roomId, message, exclude = null) {
        const room = this.rooms.get(roomId);
        if (!room) return;

        const data = JSON.stringify(message);

        room.forEach(client => {
            if (client !== exclude && client.readyState === WebSocket.OPEN) {
                client.send(data);
            }
        });
    }

    handleDisconnect(ws) {
        const client = this.clients.get(ws);
        if (!client) return;

        // Quitter toutes les rooms
        client.rooms.forEach(roomId => {
            const room = this.rooms.get(roomId);
            if (room) {
                room.delete(ws);

                // Notifier les autres
                this.broadcastToRoom(roomId, {
                    type: 'userLeft',
                    userId: client.userId,
                    userName: client.userName
                });
            }
        });

        this.clients.delete(ws);
    }
}
```

### 2. Jeu multijoueur en temps rÃ©el

```javascript
/**
 * Serveur de jeu avec synchronisation d'Ã©tat
 */

class GameServer {
    constructor(wss) {
        this.wss = wss;
        this.games = new Map(); // gameId -> Game
        this.players = new Map(); // ws -> Player

        this.tickRate = 30; // 30 updates par seconde
        this.startGameLoop();
    }

    startGameLoop() {
        setInterval(() => {
            this.games.forEach(game => {
                game.update();
                this.broadcastGameState(game);
            });
        }, 1000 / this.tickRate);
    }

    handlePlayerInput(ws, input) {
        const player = this.players.get(ws);
        if (!player) return;

        const game = this.games.get(player.gameId);
        if (!game) return;

        // Appliquer l'input du joueur
        game.applyInput(player.id, input);
    }

    broadcastGameState(game) {
        const state = game.getState();

        // Optimisation: envoyer seulement les deltas
        const delta = game.getDelta();

        if (Object.keys(delta).length === 0) return;

        // Protocole binaire pour efficacitÃ©
        const buffer = this.encodeGameState(delta);

        game.players.forEach(player => {
            if (player.ws.readyState === WebSocket.OPEN) {
                player.ws.send(buffer);
            }
        });
    }

    encodeGameState(state) {
        // Format binaire compact
        const players = state.players || [];
        const buffer = new ArrayBuffer(1 + players.length * 25);
        const view = new DataView(buffer);

        let offset = 0;

        // Type de message
        view.setUint8(offset, 0x10); // GAME_STATE
        offset += 1;

        // Nombre de joueurs
        view.setUint8(offset, players.length);
        offset += 1;

        // Pour chaque joueur: id(4) + x(4) + y(4) + z(4) + rotation(4) + health(1)
        players.forEach(player => {
            view.setUint32(offset, player.id, true);
            offset += 4;

            view.setFloat32(offset, player.x, true);
            offset += 4;

            view.setFloat32(offset, player.y, true);
            offset += 4;

            view.setFloat32(offset, player.z, true);
            offset += 4;

            view.setFloat32(offset, player.rotation, true);
            offset += 4;

            view.setUint8(offset, player.health);
            offset += 1;
        });

        return buffer;
    }
}

// Client avec prÃ©diction cÃ´tÃ© client
class GameClient {
    constructor(wsUrl) {
        this.ws = new WebSocket(wsUrl);
        this.ws.binaryType = 'arraybuffer';

        this.localPlayer = null;
        this.remotePlayers = new Map();

        this.inputSequence = 0;
        this.pendingInputs = [];

        this.setupHandlers();
        this.startRenderLoop();
    }

    setupHandlers() {
        this.ws.addEventListener('message', (event) => {
            const state = this.decodeGameState(event.data);
            this.reconcileState(state);
        });
    }

    sendInput(input) {
        const seq = this.inputSequence++;

        // Appliquer localement (client-side prediction)
        this.applyInputLocally(input);

        // Stocker pour reconciliation
        this.pendingInputs.push({ seq, input });

        // Envoyer au serveur
        this.ws.send(this.encodeInput(seq, input));
    }

    applyInputLocally(input) {
        // PrÃ©dire le mouvement localement
        if (input.forward) this.localPlayer.z += 0.1;
        if (input.backward) this.localPlayer.z -= 0.1;
        if (input.left) this.localPlayer.x -= 0.1;
        if (input.right) this.localPlayer.x += 0.1;
    }

    reconcileState(serverState) {
        // Server reconciliation
        const serverPlayer = serverState.players.find(p => p.id === this.localPlayer.id);

        if (!serverPlayer) return;

        // Trouver le dernier input traitÃ© par le serveur
        const lastProcessedSeq = serverState.lastProcessedInput;

        // Retirer les inputs traitÃ©s
        this.pendingInputs = this.pendingInputs.filter(
            input => input.seq > lastProcessedSeq
        );

        // RÃ©initialiser Ã  la position du serveur
        this.localPlayer.x = serverPlayer.x;
        this.localPlayer.y = serverPlayer.y;
        this.localPlayer.z = serverPlayer.z;

        // Re-appliquer les inputs en attente
        this.pendingInputs.forEach(({ input }) => {
            this.applyInputLocally(input);
        });

        // Mettre Ã  jour les joueurs distants (avec interpolation)
        serverState.players.forEach(playerData => {
            if (playerData.id === this.localPlayer.id) return;

            let remotePlayer = this.remotePlayers.get(playerData.id);

            if (!remotePlayer) {
                remotePlayer = createPlayer(playerData);
                this.remotePlayers.set(playerData.id, remotePlayer);
            }

            // Interpolation pour mouvement fluide
            remotePlayer.targetX = playerData.x;
            remotePlayer.targetY = playerData.y;
            remotePlayer.targetZ = playerData.z;
        });
    }

    startRenderLoop() {
        const render = () => {
            // Interpoler les positions des joueurs distants
            this.remotePlayers.forEach(player => {
                player.x += (player.targetX - player.x) * 0.3;
                player.y += (player.targetY - player.y) * 0.3;
                player.z += (player.targetZ - player.z) * 0.3;
            });

            // Render le jeu
            this.renderGame();

            requestAnimationFrame(render);
        };

        requestAnimationFrame(render);
    }
}
```

### 3. Collaboration temps rÃ©el (Google Docs-like)

```javascript
/**
 * Ã‰diteur collaboratif avec Operational Transformation
 */

class CollaborativeEditor {
    constructor(wsUrl, documentId) {
        this.wsUrl = wsUrl;
        this.documentId = documentId;
        this.ws = null;

        this.localVersion = 0;
        this.serverVersion = 0;
        this.pendingOperations = [];

        this.cursors = new Map(); // userId -> cursor position

        this.editor = document.getElementById('editor');
        this.setupEditor();
    }

    setupEditor() {
        let typingTimeout;

        this.editor.addEventListener('input', (e) => {
            const operation = this.captureOperation(e);
            this.sendOperation(operation);

            // Envoyer la position du curseur
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                this.sendCursorPosition();
            }, 100);
        });

        this.editor.addEventListener('selectionchange', () => {
            this.sendCursorPosition();
        });
    }

    connect() {
        this.ws = new WebSocket(this.wsUrl);

        this.ws.addEventListener('open', () => {
            this.ws.send(JSON.stringify({
                type: 'join',
                documentId: this.documentId
            }));
        });

        this.ws.addEventListener('message', (event) => {
            const message = JSON.parse(event.data);
            this.handleMessage(message);
        });
    }

    captureOperation(event) {
        // DÃ©tecter le type d'opÃ©ration
        const selection = window.getSelection();
        const range = selection.getRangeAt(0);

        if (event.inputType === 'insertText') {
            return {
                type: 'insert',
                position: range.startOffset,
                text: event.data,
                version: this.localVersion++
            };
        } else if (event.inputType === 'deleteContentBackward') {
            return {
                type: 'delete',
                position: range.startOffset,
                length: 1,
                version: this.localVersion++
            };
        }
        // ... autres types
    }

    sendOperation(operation) {
        // Envoyer au serveur
        this.ws.send(JSON.stringify({
            type: 'operation',
            operation: operation
        }));

        // Stocker en attente
        this.pendingOperations.push(operation);
    }

    handleMessage(message) {
        switch (message.type) {
            case 'operation':
                this.applyRemoteOperation(message.operation);
                break;

            case 'cursor':
                this.updateRemoteCursor(message.userId, message.position);
                break;

            case 'ack':
                this.handleAck(message.version);
                break;
        }
    }

    applyRemoteOperation(remoteOp) {
        // Transformer l'opÃ©ration distante contre les opÃ©rations en attente
        let transformedOp = remoteOp;

        for (const pendingOp of this.pendingOperations) {
            transformedOp = this.transform(transformedOp, pendingOp);
        }

        // Appliquer l'opÃ©ration transformÃ©e
        this.applyOperation(transformedOp);
    }

    transform(op1, op2) {
        // Operational Transformation
        // Cas 1: Deux insertions
        if (op1.type === 'insert' && op2.type === 'insert') {
            if (op1.position < op2.position) {
                return op1;
            } else if (op1.position > op2.position) {
                return {
                    ...op1,
                    position: op1.position + op2.text.length
                };
            } else {
                // Position identique : utiliser l'userId pour tiebreak
                return op1.userId < op2.userId ? op1 : {
                    ...op1,
                    position: op1.position + op2.text.length
                };
            }
        }

        // Cas 2: Insertion vs Suppression
        if (op1.type === 'insert' && op2.type === 'delete') {
            if (op1.position <= op2.position) {
                return op1;
            } else {
                return {
                    ...op1,
                    position: op1.position - op2.length
                };
            }
        }

        // Cas 3: Suppression vs Insertion
        if (op1.type === 'delete' && op2.type === 'insert') {
            if (op1.position < op2.position) {
                return op1;
            } else {
                return {
                    ...op1,
                    position: op1.position + op2.text.length
                };
            }
        }

        // Cas 4: Deux suppressions
        if (op1.type === 'delete' && op2.type === 'delete') {
            if (op1.position < op2.position) {
                return op1;
            } else if (op1.position > op2.position) {
                return {
                    ...op1,
                    position: op1.position - op2.length
                };
            } else {
                // MÃªme position : opÃ©ration annulÃ©e
                return null;
            }
        }

        return op1;
    }

    applyOperation(operation) {
        if (!operation) return;

        const content = this.editor.textContent;

        if (operation.type === 'insert') {
            const before = content.substring(0, operation.position);
            const after = content.substring(operation.position);
            this.editor.textContent = before + operation.text + after;
        } else if (operation.type === 'delete') {
            const before = content.substring(0, operation.position);
            const after = content.substring(operation.position + operation.length);
            this.editor.textContent = before + after;
        }
    }

    sendCursorPosition() {
        const selection = window.getSelection();
        if (selection.rangeCount === 0) return;

        const range = selection.getRangeAt(0);

        this.ws.send(JSON.stringify({
            type: 'cursor',
            position: range.startOffset
        }));
    }

    updateRemoteCursor(userId, position) {
        this.cursors.set(userId, position);
        this.renderCursors();
    }

    renderCursors() {
        // Supprimer les anciens curseurs
        document.querySelectorAll('.remote-cursor').forEach(el => el.remove());

        // Afficher les curseurs des autres utilisateurs
        this.cursors.forEach((position, userId) => {
            const cursor = document.createElement('div');
            cursor.className = 'remote-cursor';
            cursor.style.left = this.getPositionX(position) + 'px';
            cursor.style.top = this.getPositionY(position) + 'px';
            cursor.dataset.userId = userId;

            document.body.appendChild(cursor);
        });
    }
}
```

### 4. Trading platform (real-time market data)

```javascript
/**
 * Plateforme de trading avec flux de prix en temps rÃ©el
 */

class TradingClient {
    constructor(wsUrl) {
        this.ws = new WebSocket(wsUrl);
        this.ws.binaryType = 'arraybuffer';

        this.subscriptions = new Set();
        this.orderBook = new Map(); // symbol -> { bids, asks }
        this.latestPrices = new Map(); // symbol -> price

        this.setupHandlers();
    }

    setupHandlers() {
        this.ws.addEventListener('message', (event) => {
            if (event.data instanceof ArrayBuffer) {
                this.handleBinaryMessage(event.data);
            } else {
                this.handleTextMessage(JSON.parse(event.data));
            }
        });
    }

    subscribe(symbols) {
        symbols.forEach(symbol => this.subscriptions.add(symbol));

        this.ws.send(JSON.stringify({
            type: 'subscribe',
            symbols: symbols
        }));
    }

    unsubscribe(symbols) {
        symbols.forEach(symbol => this.subscriptions.delete(symbol));

        this.ws.send(JSON.stringify({
            type: 'unsubscribe',
            symbols: symbols
        }));
    }

    handleBinaryMessage(buffer) {
        const view = new DataView(buffer);
        const messageType = view.getUint8(0);

        switch (messageType) {
            case 0x01: // PRICE_UPDATE
                this.handlePriceUpdate(buffer);
                break;

            case 0x02: // ORDER_BOOK_UPDATE
                this.handleOrderBookUpdate(buffer);
                break;

            case 0x03: // TRADE
                this.handleTrade(buffer);
                break;
        }
    }

    handlePriceUpdate(buffer) {
        // Format: [type:1][symbol:4][price:8][timestamp:8]
        const view = new DataView(buffer);

        const symbolId = view.getUint32(1, true);
        const price = view.getFloat64(5, true);
        const timestamp = Number(view.getBigUint64(13, true));

        const symbol = this.getSymbolFromId(symbolId);

        this.latestPrices.set(symbol, price);
        this.updatePriceDisplay(symbol, price, timestamp);

        // Calculer la latence
        const latency = Date.now() - timestamp;
        this.recordLatency(latency);
    }

    handleOrderBookUpdate(buffer) {
        // Format: [type:1][symbol:4][side:1][levels:1][price:8,qty:8...]
        const view = new DataView(buffer);
        let offset = 1;

        const symbolId = view.getUint32(offset, true);
        offset += 4;

        const side = view.getUint8(offset); // 0=bid, 1=ask
        offset += 1;

        const levels = view.getUint8(offset);
        offset += 1;

        const symbol = this.getSymbolFromId(symbolId);
        const orderBook = this.orderBook.get(symbol) || { bids: [], asks: [] };

        const updates = [];
        for (let i = 0; i < levels; i++) {
            const price = view.getFloat64(offset, true);
            offset += 8;

            const quantity = view.getFloat64(offset, true);
            offset += 8;

            updates.push({ price, quantity });
        }

        if (side === 0) {
            orderBook.bids = updates;
        } else {
            orderBook.asks = updates;
        }

        this.orderBook.set(symbol, orderBook);
        this.updateOrderBookDisplay(symbol, orderBook);
    }

    placeOrder(symbol, side, price, quantity) {
        this.ws.send(JSON.stringify({
            type: 'placeOrder',
            symbol: symbol,
            side: side, // 'buy' or 'sell'
            price: price,
            quantity: quantity,
            timestamp: Date.now()
        }));
    }

    updatePriceDisplay(symbol, price, timestamp) {
        const element = document.getElementById(`price-${symbol}`);

        // Afficher le prix
        element.textContent = price.toFixed(2);

        // Animation de flash
        const previousPrice = parseFloat(element.dataset.previousPrice || price);

        if (price > previousPrice) {
            element.classList.add('price-up');
            setTimeout(() => element.classList.remove('price-up'), 500);
        } else if (price < previousPrice) {
            element.classList.add('price-down');
            setTimeout(() => element.classList.remove('price-down'), 500);
        }

        element.dataset.previousPrice = price;

        // Afficher la latence
        const latency = Date.now() - timestamp;
        document.getElementById(`latency-${symbol}`).textContent = `${latency}ms`;
    }
}

// Serveur : distribuer les prix
class MarketDataServer {
    constructor(wss) {
        this.wss = wss;
        this.subscriptions = new Map(); // symbol -> Set of clients
        this.clients = new Map(); // ws -> Set of symbols

        this.startMarketDataFeed();
    }

    startMarketDataFeed() {
        // Simuler des mises Ã  jour de prix (en rÃ©alitÃ©, connectÃ© Ã  un exchange)
        setInterval(() => {
            // Pour chaque symbole
            ['BTC/USD', 'ETH/USD', 'AAPL'].forEach(symbol => {
                const price = this.getCurrentPrice(symbol);
                this.broadcastPrice(symbol, price);
            });
        }, 100); // 10 updates par seconde
    }

    broadcastPrice(symbol, price) {
        const clients = this.subscriptions.get(symbol);
        if (!clients || clients.size === 0) return;

        // Encoder en binaire pour efficacitÃ©
        const buffer = this.encodePriceUpdate(symbol, price);

        clients.forEach(ws => {
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(buffer);
            }
        });
    }

    encodePriceUpdate(symbol, price) {
        const buffer = new ArrayBuffer(21);
        const view = new DataView(buffer);

        view.setUint8(0, 0x01); // PRICE_UPDATE
        view.setUint32(1, this.getSymbolId(symbol), true);
        view.setFloat64(5, price, true);
        view.setBigUint64(13, BigInt(Date.now()), true);

        return buffer;
    }
}
```

---

## SÃ©curitÃ© WebSocket

### 1. Authentification

```javascript
/**
 * Authentification sÃ©curisÃ©e via token JWT
 */

// Client : envoyer le token dans l'URL ou premier message
const token = localStorage.getItem('authToken');

// Option 1: Token dans l'URL (simple mais moins sÃ©curisÃ©)
const ws = new WebSocket(`wss://api.example.com/ws?token=${token}`);

// Option 2: Token dans le premier message (recommandÃ©)
const ws = new WebSocket('wss://api.example.com/ws');

ws.addEventListener('open', () => {
    ws.send(JSON.stringify({
        type: 'auth',
        token: token
    }));
});

// Serveur : valider le token
const jwt = require('jsonwebtoken');

wss.on('connection', (ws, req) => {
    let isAuthenticated = false;
    let userId = null;

    // Timeout pour l'authentification
    const authTimeout = setTimeout(() => {
        if (!isAuthenticated) {
            ws.close(1008, 'Authentication timeout');
        }
    }, 5000);

    ws.on('message', (data) => {
        const message = JSON.parse(data);

        if (!isAuthenticated) {
            // PremiÃ¨re message doit Ãªtre l'authentification
            if (message.type !== 'auth') {
                ws.close(1008, 'Authentication required');
                return;
            }

            try {
                const decoded = jwt.verify(message.token, process.env.JWT_SECRET);
                userId = decoded.userId;
                isAuthenticated = true;
                clearTimeout(authTimeout);

                ws.send(JSON.stringify({
                    type: 'authenticated',
                    userId: userId
                }));

            } catch (error) {
                ws.close(1008, 'Invalid token');
                return;
            }
        } else {
            // Traiter les messages normaux
            handleMessage(ws, userId, message);
        }
    });
});
```

### 2. Rate limiting

```javascript
/**
 * Rate limiting pour WebSocket
 */

class RateLimiter {
    constructor(maxRequests, windowMs) {
        this.maxRequests = maxRequests;
        this.windowMs = windowMs;
        this.clients = new Map(); // ws -> { count, resetTime }
    }

    check(ws) {
        const now = Date.now();
        let client = this.clients.get(ws);

        if (!client || now > client.resetTime) {
            client = {
                count: 0,
                resetTime: now + this.windowMs
            };
            this.clients.set(ws, client);
        }

        client.count++;

        if (client.count > this.maxRequests) {
            return false; // Rate limit exceeded
        }

        return true;
    }

    cleanup(ws) {
        this.clients.delete(ws);
    }
}

// Utilisation
const messageLimiter = new RateLimiter(100, 60000); // 100 messages par minute

wss.on('connection', (ws) => {
    ws.on('message', (data) => {
        if (!messageLimiter.check(ws)) {
            ws.send(JSON.stringify({
                type: 'error',
                message: 'Rate limit exceeded'
            }));
            return;
        }

        // Traiter le message
        handleMessage(ws, data);
    });

    ws.on('close', () => {
        messageLimiter.cleanup(ws);
    });
});
```

### 3. Validation des messages

```javascript
/**
 * Validation stricte des messages
 */

const Joi = require('joi');

// SchÃ©mas de validation
const messageSchemas = {
    chat: Joi.object({
        type: Joi.string().valid('chat').required(),
        room: Joi.string().max(100).required(),
        text: Joi.string().max(1000).required()
    }),

    join: Joi.object({
        type: Joi.string().valid('join').required(),
        room: Joi.string().max(100).required()
    })
};

function validateMessage(message) {
    const schema = messageSchemas[message.type];

    if (!schema) {
        throw new Error(`Unknown message type: ${message.type}`);
    }

    const { error, value } = schema.validate(message);

    if (error) {
        throw new Error(`Validation error: ${error.message}`);
    }

    return value;
}

// Utilisation
ws.on('message', (data) => {
    try {
        const message = JSON.parse(data);
        const validated = validateMessage(message);

        handleMessage(ws, validated);

    } catch (error) {
        console.error('Invalid message:', error);
        ws.send(JSON.stringify({
            type: 'error',
            message: 'Invalid message format'
        }));
    }
});
```

### 4. Protection XSS et injection

```javascript
/**
 * Sanitization des donnÃ©es
 */

const DOMPurify = require('isomorphic-dompurify');

function sanitizeMessage(message) {
    return {
        ...message,
        text: DOMPurify.sanitize(message.text, {
            ALLOWED_TAGS: [], // Pas de HTML
            KEEP_CONTENT: true
        })
    };
}

// Client : Ã©chapper le HTML lors de l'affichage
function displayMessage(message) {
    const div = document.createElement('div');
    div.textContent = message.text; // Utiliser textContent, pas innerHTML

    document.getElementById('messages').appendChild(div);
}
```

### 5. CSRF protection

```javascript
/**
 * Protection contre CSRF via Origin check
 */

const allowedOrigins = [
    'https://example.com',
    'https://app.example.com'
];

wss.on('connection', (ws, req) => {
    const origin = req.headers.origin;

    if (!allowedOrigins.includes(origin)) {
        console.warn(`Rejected connection from origin: ${origin}`);
        ws.close(1008, 'Origin not allowed');
        return;
    }

    // Continuer...
});
```

---

## Optimisations et performance

### 1. Message batching

```javascript
/**
 * Regrouper les messages pour rÃ©duire l'overhead
 */

class MessageBatcher {
    constructor(ws, flushInterval = 16) { // ~60 FPS
        this.ws = ws;
        this.queue = [];
        this.flushInterval = flushInterval;
        this.timer = null;
    }

    send(message) {
        this.queue.push(message);

        if (!this.timer) {
            this.timer = setTimeout(() => {
                this.flush();
            }, this.flushInterval);
        }
    }

    flush() {
        if (this.queue.length === 0) return;

        // Envoyer tous les messages en un seul paquet
        this.ws.send(JSON.stringify({
            type: 'batch',
            messages: this.queue
        }));

        this.queue = [];
        this.timer = null;
    }
}

// Utilisation pour un jeu
const batcher = new MessageBatcher(ws);

// Update loop
setInterval(() => {
    const position = getPlayerPosition();

    batcher.send({
        type: 'position',
        x: position.x,
        y: position.y,
        z: position.z
    });
}, 16); // 60 FPS

// Les messages sont automatiquement batched
```

### 2. Lazy loading et pagination

```javascript
/**
 * Charger les donnÃ©es progressivement
 */

class LazyLoadManager {
    constructor(ws) {
        this.ws = ws;
        this.loadedMessages = [];
        this.hasMore = true;
        this.loading = false;
    }

    async loadMore() {
        if (!this.hasMore || this.loading) return;

        this.loading = true;

        return new Promise((resolve) => {
            const requestId = Math.random().toString(36);

            const handler = (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'messages' && data.requestId === requestId) {
                    this.loadedMessages.push(...data.messages);
                    this.hasMore = data.hasMore;
                    this.loading = false;

                    this.ws.removeEventListener('message', handler);
                    resolve(data.messages);
                }
            };

            this.ws.addEventListener('message', handler);

            this.ws.send(JSON.stringify({
                type: 'loadMessages',
                requestId: requestId,
                offset: this.loadedMessages.length,
                limit: 50
            }));
        });
    }
}

// Utilisation avec scroll infini
const lazyLoader = new LazyLoadManager(ws);

document.getElementById('messages').addEventListener('scroll', async (e) => {
    const element = e.target;

    if (element.scrollTop === 0) {
        // ScrollÃ© en haut : charger plus
        const oldHeight = element.scrollHeight;

        const messages = await lazyLoader.loadMore();

        if (messages.length > 0) {
            prependMessages(messages);

            // Maintenir la position de scroll
            const newHeight = element.scrollHeight;
            element.scrollTop = newHeight - oldHeight;
        }
    }
});
```

### 3. Connection pooling (serveur)

```javascript
/**
 * Pool de connexions pour scale horizontal
 */

const Redis = require('ioredis');

class WebSocketCluster {
    constructor(wss) {
        this.wss = wss;

        // Redis pub/sub pour communication inter-serveurs
        this.pub = new Redis();
        this.sub = new Redis();

        this.serverId = process.env.SERVER_ID || 'server-1';
        this.localClients = new Map(); // ws -> client info

        this.setupPubSub();
    }

    setupPubSub() {
        // S'abonner aux broadcasts
        this.sub.subscribe('ws:broadcast', (err) => {
            if (err) {
                console.error('Failed to subscribe:', err);
            }
        });

        this.sub.on('message', (channel, message) => {
            if (channel === 'ws:broadcast') {
                const data = JSON.parse(message);

                // Ne pas rebroadcaster ses propres messages
                if (data.serverId === this.serverId) return;

                this.broadcastLocal(data.message);
            }
        });
    }

    broadcast(message) {
        // Broadcaster localement
        this.broadcastLocal(message);

        // Broadcaster aux autres serveurs via Redis
        this.pub.publish('ws:broadcast', JSON.stringify({
            serverId: this.serverId,
            message: message
        }));
    }

    broadcastLocal(message) {
        const data = JSON.stringify(message);

        this.localClients.forEach((client, ws) => {
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(data);
            }
        });
    }

    addClient(ws, clientInfo) {
        this.localClients.set(ws, clientInfo);

        // Stocker dans Redis pour permettre le routing
        this.pub.hset(
            'ws:clients',
            clientInfo.userId,
            JSON.stringify({
                serverId: this.serverId,
                connectedAt: Date.now()
            })
        );
    }

    removeClient(ws) {
        const client = this.localClients.get(ws);

        if (client) {
            this.pub.hdel('ws:clients', client.userId);
            this.localClients.delete(ws);
        }
    }

    async sendToUser(userId, message) {
        // VÃ©rifier si l'utilisateur est sur ce serveur
        const localClient = Array.from(this.localClients.entries())
            .find(([ws, client]) => client.userId === userId);

        if (localClient) {
            const [ws] = localClient;
            ws.send(JSON.stringify(message));
            return;
        }

        // Sinon, trouver le serveur et publier
        const userServer = await this.pub.hget('ws:clients', userId);

        if (userServer) {
            const { serverId } = JSON.parse(userServer);

            this.pub.publish(`ws:server:${serverId}`, JSON.stringify({
                type: 'sendToUser',
                userId: userId,
                message: message
            }));
        }
    }
}
```

---

## Monitoring et debugging

### 1. MÃ©triques cÃ´tÃ© serveur

```javascript
/**
 * Collecte de mÃ©triques WebSocket
 */

const prometheus = require('prom-client');

class WebSocketMetrics {
    constructor() {
        // MÃ©triques Prometheus
        this.activeConnections = new prometheus.Gauge({
            name: 'ws_active_connections',
            help: 'Number of active WebSocket connections'
        });

        this.totalConnections = new prometheus.Counter({
            name: 'ws_total_connections',
            help: 'Total number of WebSocket connections'
        });

        this.messagesSent = new prometheus.Counter({
            name: 'ws_messages_sent_total',
            help: 'Total messages sent',
            labelNames: ['type']
        });

        this.messagesReceived = new prometheus.Counter({
            name: 'ws_messages_received_total',
            help: 'Total messages received',
            labelNames: ['type']
        });

        this.messageLatency = new prometheus.Histogram({
            name: 'ws_message_latency_seconds',
            help: 'Message processing latency',
            buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1]
        });

        this.errors = new prometheus.Counter({
            name: 'ws_errors_total',
            help: 'Total WebSocket errors',
            labelNames: ['type']
        });
    }

    recordConnection() {
        this.activeConnections.inc();
        this.totalConnections.inc();
    }

    recordDisconnection() {
        this.activeConnections.dec();
    }

    recordMessageSent(type) {
        this.messagesSent.inc({ type });
    }

    recordMessageReceived(type) {
        this.messagesReceived.inc({ type });
    }

    recordLatency(latency) {
        this.messageLatency.observe(latency);
    }

    recordError(type) {
        this.errors.inc({ type });
    }
}

const metrics = new WebSocketMetrics();

wss.on('connection', (ws) => {
    metrics.recordConnection();

    ws.on('message', (data) => {
        const start = Date.now();

        try {
            const message = JSON.parse(data);
            metrics.recordMessageReceived(message.type);

            handleMessage(ws, message);

            const latency = (Date.now() - start) / 1000;
            metrics.recordLatency(latency);

        } catch (error) {
            metrics.recordError('parse_error');
        }
    });

    ws.on('close', () => {
        metrics.recordDisconnection();
    });
});

// Endpoint Prometheus
app.get('/metrics', async (req, res) => {
    res.set('Content-Type', prometheus.register.contentType);
    res.end(await prometheus.register.metrics());
});
```

### 2. Logging structurÃ©

```javascript
/**
 * Logging avec contexte
 */

const winston = require('winston');

const logger = winston.createLogger({
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
    ),
    transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'websocket.log' })
    ]
});

wss.on('connection', (ws, req) => {
    const clientId = generateId();
    const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress;

    logger.info('WebSocket connection', {
        clientId,
        ip,
        userAgent: req.headers['user-agent']
    });

    ws.on('message', (data) => {
        try {
            const message = JSON.parse(data);

            logger.debug('Message received', {
                clientId,
                messageType: message.type,
                size: data.length
            });

        } catch (error) {
            logger.error('Parse error', {
                clientId,
                error: error.message,
                data: data.toString().substring(0, 100)
            });
        }
    });

    ws.on('close', (code, reason) => {
        logger.info('WebSocket disconnection', {
            clientId,
            code,
            reason: reason.toString()
        });
    });

    ws.on('error', (error) => {
        logger.error('WebSocket error', {
            clientId,
            error: error.message,
            stack: error.stack
        });
    });
});
```

### 3. Debugging tools

```javascript
/**
 * WebSocket debugger pour le dÃ©veloppement
 */

class WebSocketDebugger {
    constructor(ws) {
        this.ws = ws;
        this.messageLog = [];
        this.maxLogSize = 1000;

        this.setupInterceptors();
        this.exposeToDevTools();
    }

    setupInterceptors() {
        // Intercepter send
        const originalSend = this.ws.send.bind(this.ws);

        this.ws.send = (data) => {
            this.logMessage('sent', data);
            originalSend(data);
        };

        // Intercepter message
        this.ws.addEventListener('message', (event) => {
            this.logMessage('received', event.data);
        });
    }

    logMessage(direction, data) {
        const entry = {
            direction,
            timestamp: Date.now(),
            size: typeof data === 'string' ? data.length : data.byteLength,
            data: this.formatData(data)
        };

        this.messageLog.push(entry);

        if (this.messageLog.length > this.maxLogSize) {
            this.messageLog.shift();
        }

        console.log(`[WS ${direction}]`, entry.data);
    }

    formatData(data) {
        if (typeof data === 'string') {
            try {
                return JSON.parse(data);
            } catch {
                return data;
            }
        } else if (data instanceof ArrayBuffer) {
            return `Binary (${data.byteLength} bytes)`;
        }
        return data;
    }

    exposeToDevTools() {
        window.__wsDebug = {
            getLog: () => this.messageLog,
            clearLog: () => this.messageLog = [],
            getStats: () => ({
                totalMessages: this.messageLog.length,
                sent: this.messageLog.filter(m => m.direction === 'sent').length,
                received: this.messageLog.filter(m => m.direction === 'received').length,
                totalSize: this.messageLog.reduce((sum, m) => sum + m.size, 0)
            }),
            replay: (index) => {
                const msg = this.messageLog[index];
                if (msg && msg.direction === 'sent') {
                    this.ws.send(
                        typeof msg.data === 'object'
                            ? JSON.stringify(msg.data)
                            : msg.data
                    );
                }
            }
        };

        console.log('WebSocket debugger available at window.__wsDebug');
    }
}

// Utilisation en dÃ©veloppement
if (process.env.NODE_ENV === 'development') {
    const debugger = new WebSocketDebugger(ws);
}
```

---

## Checklist pour production

- [ ] **SÃ©curitÃ©** :
  - [ ] Utiliser WSS (WebSocket Secure) en production
  - [ ] Authentification implÃ©mentÃ©e (JWT recommandÃ©)
  - [ ] Validation stricte des messages
  - [ ] Rate limiting configurÃ©
  - [ ] Origin check activÃ©
  - [ ] Messages sanitized (XSS protection)

- [ ] **Reconnexion** :
  - [ ] Reconnexion automatique implÃ©mentÃ©e
  - [ ] Exponential backoff configurÃ©
  - [ ] Queue de messages si dÃ©connectÃ©
  - [ ] Heartbeat ping/pong actif

- [ ] **Performance** :
  - [ ] Protocole binaire pour donnÃ©es frÃ©quentes
  - [ ] Compression activÃ©e si pertinent
  - [ ] Message batching implÃ©mentÃ©
  - [ ] Pas de blocking operations dans handlers

- [ ] **ScalabilitÃ©** :
  - [ ] Load balancer avec sticky sessions
  - [ ] Redis pub/sub pour scale horizontal
  - [ ] Limite de connexions par serveur
  - [ ] Cleanup des connexions mortes

- [ ] **Monitoring** :
  - [ ] MÃ©triques exposÃ©es (Prometheus)
  - [ ] Logging structurÃ© en place
  - [ ] Alertes configurÃ©es (latence, erreurs, connexions)
  - [ ] Dashboards crÃ©Ã©s (Grafana)

- [ ] **Error handling** :
  - [ ] Gestion des dÃ©connexions
  - [ ] Retry logic pour envoi de messages
  - [ ] Fallback si WebSocket non supportÃ©
  - [ ] Codes de fermeture appropriÃ©s

- [ ] **Testing** :
  - [ ] Tests unitaires des handlers
  - [ ] Tests d'intÃ©gration
  - [ ] Load testing (1000+ connexions simultanÃ©es)
  - [ ] Chaos engineering (dÃ©connexions alÃ©atoires)

---

## Conclusion

**WebSocket** est la technologie de choix pour la **communication bidirectionnelle temps rÃ©el** sur le web. Elle offre :

- âœ… **Performance maximale** : latence < 10ms, overhead minimal
- âœ… **FlexibilitÃ©** : texte et binaire, full-duplex
- âœ… **MaturitÃ©** : largement supportÃ©, Ã©cosystÃ¨me riche

**Cas d'usage idÃ©aux** :
- ğŸ’¬ Chat et messaging
- ğŸ® Jeux multijoueurs
- ğŸ“ Collaboration temps rÃ©el
- ğŸ“Š Dashboards live
- ğŸ’° Trading et finance

**Quand NE PAS utiliser WebSocket** :
- Communication unidirectionnelle simple â†’ SSE suffit
- Mises Ã  jour rares (< 1/minute) â†’ Polling suffit
- Pas de support serveur WebSocket â†’ Fallback SSE/Long-polling

**Comparaison finale** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Technique    â”‚ Direction â”‚ Latence â”‚ ComplexitÃ© â”‚ Use â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
â”‚  Polling      â”‚     â†’     â”‚  Haute  â”‚   Faible   â”‚ 5%  â”‚
â”‚  Long-Polling â”‚     â†’     â”‚  Moyenneâ”‚   Moyenne  â”‚ 10% â”‚
â”‚  SSE          â”‚     â†’     â”‚  Basse  â”‚   Faible   â”‚ 25% â”‚
â”‚  WebSocket    â”‚    â†”â†”     â”‚  TrÃ¨s   â”‚   Moyenne  â”‚ 60% â”‚
â”‚               â”‚           â”‚  Basse  â”‚            â”‚     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Prochaine section** : Nous explorerons les **protocoles de haut niveau** comme Socket.IO qui simplifient l'utilisation de WebSocket avec des fonctionnalitÃ©s supplÃ©mentaires (rooms, acknowledgements, fallbacks automatiques).

---


â­ï¸ [Comparaison et critÃ¨res de choix selon le cas d'usage](/08-programmation-reseau/09.4-comparaison-choix.md)
