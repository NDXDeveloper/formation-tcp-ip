üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.10.1 REST : principes et contraintes r√©seau

# Table des mati√®res

## [Introduction](#introduction-1)

## [Les six contraintes architecturales de REST](#les-six-contraintes-architecturales-de-rest-1)

### [1. Client-Serveur (Client-Server)](#1-client-serveur-client-server-1)

### [2. Sans √©tat (Stateless)](#2-sans-%C3%A9tat-stateless-1)

### [3. Cache (Cacheable)](#3-cache-cacheable-1)

### [4. Interface uniforme (Uniform Interface)](#4-interface-uniforme-uniform-interface-1)
- 4a. Identification des ressources
- 4b. Manipulation via repr√©sentations
- 4c. Messages auto-descriptifs
- 4d. HATEOAS (Hypermedia As The Engine Of Application State)

### [5. Syst√®me en couches (Layered System)](#5-syst%C3%A8me-en-couches-layered-system-1)

### [6. Code √† la demande (Code-On-Demand) - Optionnel](#6-code-%C3%A0-la-demande-code-on-demand---optionnel-1)

## [M√©thodes HTTP et s√©mantique r√©seau](#m%C3%A9thodes-http-et-s%C3%A9mantique-r%C3%A9seau-1)
- GET - Lecture de ressource
- POST - Cr√©ation de ressource
- PUT - Remplacement complet
- PATCH - Modification partielle
- DELETE - Suppression
- OPTIONS - M√©tadonn√©es

## [Codes de statut HTTP et leur s√©mantique r√©seau](#codes-de-statut-http-et-leur-s%C3%A9mantique-r%C3%A9seau-1)
- 2xx - Succ√®s
- 3xx - Redirection
- 4xx - Erreurs client
- 5xx - Erreurs serveur

## [Versioning d'API](#versioning-dapi-1)
- Approche 1 : URL versioning
- Approche 2 : Header versioning
- Approche 3 : Query parameter
- Strat√©gie de d√©pr√©ciation

## [Gestion des erreurs r√©seau c√¥t√© client](#gestion-des-erreurs-r%C3%A9seau-c%C3%B4t%C3%A9-client-1)
- Retry avec backoff exponentiel
- Circuit Breaker

## [Performance et optimisation r√©seau](#performance-et-optimisation-r%C3%A9seau-1)
- Compression
- Pagination
- Champs s√©lectifs (Field Selection)
- Batch Requests

## [S√©curit√©](#s%C3%A9curit%C3%A9-1)
- HTTPS obligatoire
- CORS (Cross-Origin Resource Sharing)
- Rate Limiting

## [Conclusion](#conclusion-1)

---

**Temps de lecture estim√©** : 30 minutes
**Contraintes REST** : 6
**M√©thodes HTTP d√©taill√©es** : 6
**Codes de statut** : 4 cat√©gories
**Exemples de code** : Python, JavaScript, Go
**Patterns avanc√©s** : Retry, Circuit Breaker, Pagination, Batch

---

## Introduction

REST (Representational State Transfer) n'est pas un protocole ni une technologie, mais un **style architectural** d√©fini par Roy Fielding dans sa th√®se de doctorat en 2000. Contrairement √† une id√©e re√ßue, REST n'est pas synonyme de "API HTTP avec JSON" : c'est un ensemble de contraintes architecturales qui, lorsqu'elles sont respect√©es, garantissent des propri√©t√©s sp√©cifiques en termes de scalabilit√©, de performance et de maintenabilit√©.

La plupart des APIs dites "RESTful" ne respectent qu'une partie de ces contraintes. Comprendre les principes fondamentaux de REST permet de concevoir des APIs r√©seau efficaces, m√™me si on fait des compromis pragmatiques sur certains aspects.

## Les six contraintes architecturales de REST

Roy Fielding a d√©fini six contraintes qui caract√©risent une architecture REST. Chacune a des implications r√©seau directes.

### 1. Client-Serveur (Client-Server)

**Principe :** S√©paration des pr√©occupations entre le client (interface utilisateur) et le serveur (stockage des donn√©es).

**Implications r√©seau :**

Cette contrainte impose une communication explicite via le r√©seau, avec un protocole d√©fini (g√©n√©ralement HTTP). Le client et le serveur √©voluent ind√©pendamment tant que l'interface reste stable.

```
Architecture classique :

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client    ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ HTTP ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí    ‚îÇ   Serveur   ‚îÇ
‚îÇ  (Browser)  ‚îÇ ‚Üê‚îÄ‚îÄ‚îÄ Response ‚îÄ‚îÄ   ‚îÇ   (API)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                                    ‚îÇ
     ‚îú‚îÄ G√®re l'UI                         ‚îú‚îÄ G√®re les donn√©es
     ‚îú‚îÄ √âtat local                        ‚îú‚îÄ Logique m√©tier
     ‚îî‚îÄ Pr√©sentation                      ‚îî‚îÄ Persistance
```

**Exemple concret - Application e-commerce :**

```javascript
// Client (React) - G√®re uniquement l'affichage
const ProductList = () => {
  const [products, setProducts] = useState([]);

  useEffect(() => {
    // Communication r√©seau explicite
    fetch('https://api.shop.com/products')
      .then(res => res.json())
      .then(data => setProducts(data));
  }, []);

  return <div>{products.map(p => <ProductCard {...p} />)}</div>;
};

// Serveur (Node.js) - G√®re uniquement les donn√©es
app.get('/products', async (req, res) => {
  const products = await db.products.findAll();
  res.json(products);
});
```

**Avantages r√©seau :**
- D√©ploiement ind√©pendant du client et du serveur
- Mise √† jour du client sans red√©ploiement serveur
- Multiples clients (web, mobile, IoT) pour une m√™me API
- Load balancing simplifi√© c√¥t√© serveur

### 2. Sans √©tat (Stateless)

**Principe :** Chaque requ√™te du client vers le serveur doit contenir **toutes les informations** n√©cessaires pour comprendre et traiter la requ√™te. Le serveur ne stocke aucun contexte de session entre les requ√™tes.

**Implications r√©seau critiques :**

Cette contrainte est probablement la plus importante pour la scalabilit√© r√©seau. Elle signifie que :
- Pas de session serveur (pas de sticky sessions n√©cessaires)
- Chaque requ√™te est ind√©pendante
- Le contexte est transmis via headers, tokens, ou dans le payload

```
Requ√™te 1 : GET /cart
Headers: Authorization: Bearer eyJhbGc...
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí
                                       Serveur d√©code le token,
                                       identifie l'utilisateur,
                                       retourne son panier
‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Response: { items: [...], total: 150 }

Requ√™te 2 : POST /cart/items
Headers: Authorization: Bearer eyJhbGc...
Body: { productId: 123, quantity: 2 }
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí
                                       Serveur re-d√©code le token,
                                       re-identifie l'utilisateur,
                                       ajoute au panier
‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Response: { items: [...], total: 200 }
```

**Exemple - Authentification stateless avec JWT :**

```python
# Serveur Python (Flask)
from flask import Flask, request, jsonify
import jwt
from datetime import datetime, timedelta

app = Flask(__name__)
SECRET_KEY = "votre-secret-securise"

@app.route('/login', methods=['POST'])
def login():
    username = request.json.get('username')
    password = request.json.get('password')

    # Validation des credentials
    if validate_credentials(username, password):
        # G√©n√©ration du token JWT (toutes les infos dans le token)
        payload = {
            'user_id': get_user_id(username),
            'username': username,
            'roles': get_user_roles(username),
            'exp': datetime.utcnow() + timedelta(hours=24)
        }
        token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')

        return jsonify({'token': token}), 200

    return jsonify({'error': 'Invalid credentials'}), 401

@app.route('/products', methods=['GET'])
def get_products():
    # Chaque requ√™te contient le token
    auth_header = request.headers.get('Authorization')

    if not auth_header:
        return jsonify({'error': 'No token provided'}), 401

    try:
        # D√©codage du token (pas de lookup en base)
        token = auth_header.split(' ')[1]
        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])

        # L'identit√© de l'utilisateur est dans le token
        user_id = payload['user_id']

        # R√©cup√©ration des produits
        products = get_products_for_user(user_id)
        return jsonify(products), 200

    except jwt.ExpiredSignatureError:
        return jsonify({'error': 'Token expired'}), 401
    except jwt.InvalidTokenError:
        return jsonify({'error': 'Invalid token'}), 401
```

**Impact r√©seau positif :**

1. **Scalabilit√© horizontale :** Aucune affinit√© de session n√©cessaire
```
Client ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ> Requ√™te 1 ‚îÄ‚îÄ> Serveur A
         ‚îú‚îÄ‚îÄ> Requ√™te 2 ‚îÄ‚îÄ> Serveur B  ‚Üê Fonctionne car stateless
         ‚îî‚îÄ‚îÄ> Requ√™te 3 ‚îÄ‚îÄ> Serveur C

Load balancer peut distribuer al√©atoirement
```

2. **R√©silience :** Panne d'un serveur sans perte de session
```
Requ√™te 1 ‚îÄ‚îÄ> Serveur A (crash apr√®s r√©ponse)
Requ√™te 2 ‚îÄ‚îÄ> Serveur B (fonctionne car pas de d√©pendance)
```

3. **Cache efficace :** Pas d'√©tat = r√©ponses cachables facilement
```
GET /products?category=electronics
Cache-Control: public, max-age=3600

‚Üí Peut √™tre cach√© par CDN, reverse proxy, navigateur
```

**Co√ªt r√©seau :**

- **Overhead de transmission :** Le token JWT est envoy√© dans chaque requ√™te
```
Taille typique d'un JWT : 200-500 bytes
Pour 100 requ√™tes : 20-50 KB suppl√©mentaires

Comparaison avec session ID :
Session ID : 32 bytes √ó 100 = 3.2 KB
JWT : 300 bytes √ó 100 = 30 KB

Overhead : ~27 KB (mais pas de lookup serveur)
```

- **CPU serveur :** D√©codage/validation du token √† chaque requ√™te
- **Compromis :** Bande passante contre scalabilit√© et simplicit√©

**Anti-pattern courant - Session serveur :**

```javascript
// ‚ùå MAUVAIS - Viole la contrainte stateless
app.use(session({
  secret: 'secret-key',
  resave: false,
  saveUninitialized: true,
  store: new RedisStore({ client: redisClient })
}));

app.post('/login', (req, res) => {
  // Stocke l'√©tat dans la session serveur
  req.session.userId = user.id;
  req.session.username = user.username;
  res.json({ message: 'Logged in' });
});

app.get('/profile', (req, res) => {
  // D√©pend de l'√©tat serveur
  const userId = req.session.userId;
  // ...
});

// Probl√®mes r√©seau :
// - N√©cessite sticky sessions (affinit√© load balancer)
// - √âtat partag√© entre serveurs (Redis)
// - Complexit√© de synchronisation
```

### 3. Cache (Cacheable)

**Principe :** Les r√©ponses doivent d√©finir explicitement si elles sont cachables ou non. Le cache am√©liore l'efficacit√© r√©seau en √©liminant certaines interactions client-serveur.

**Implications r√©seau :**

REST s'appuie sur les m√©canismes de cache HTTP pour r√©duire la latence et la charge r√©seau.

**Headers de contr√¥le de cache :**

```http
GET /api/products/123 HTTP/1.1
Host: api.shop.com

HTTP/1.1 200 OK
Cache-Control: public, max-age=3600
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Last-Modified: Wed, 01 Dec 2024 12:00:00 GMT
Content-Type: application/json

{
  "id": 123,
  "name": "Laptop",
  "price": 999.99
}
```

**Niveaux de cache :**

```
Client (Browser)
    ‚Üì
Cache navigateur (memory/disk)
    ‚Üì
CDN (Cloudflare, Akamai)
    ‚Üì
Reverse Proxy (Nginx, Varnish)
    ‚Üì
Application Server
    ‚Üì
Database
```

**Exemple - Configuration de cache optimale :**

```javascript
// Node.js avec Express
app.get('/products/:id', async (req, res) => {
  const product = await db.products.findById(req.params.id);

  if (!product) {
    return res.status(404).json({ error: 'Product not found' });
  }

  // Calcul de l'ETag bas√© sur le contenu
  const etag = crypto
    .createHash('md5')
    .update(JSON.stringify(product))
    .digest('hex');

  // V√©rification du cache client
  if (req.headers['if-none-match'] === etag) {
    // Le client a d√©j√† la bonne version
    return res.status(304).end(); // Not Modified - pas de body
  }

  // Configuration du cache
  res.set({
    'Cache-Control': 'public, max-age=3600', // 1 heure
    'ETag': etag,
    'Last-Modified': product.updatedAt.toUTCString()
  });

  res.json(product);
});
```

**Impact r√©seau mesurable :**

```
Sc√©nario : Page produit visit√©e 1000 fois/heure

Sans cache :
- 1000 requ√™tes compl√®tes
- Taille moyenne : 5 KB/r√©ponse
- Bande passante : 5 MB/heure
- Latence moyenne : 200ms

Avec cache (80% hit rate) :
- 200 requ√™tes compl√®tes (5 KB)
- 800 r√©ponses 304 Not Modified (0.5 KB headers seulement)
- Bande passante : 1 MB + 0.4 MB = 1.4 MB/heure
- Latence moyenne : 50ms (cache) + 20% √ó 200ms = 90ms

√âconomie :
- Bande passante : 72% de r√©duction
- Latence : 55% d'am√©lioration
- Charge serveur : 80% de r√©duction
```

**Strat√©gies de cache par type de ressource :**

```javascript
// Ressources immuables (versionn√©es)
app.get('/static/v1.2.3/app.js', (req, res) => {
  res.set('Cache-Control', 'public, max-age=31536000, immutable');
  // 1 an de cache, ne jamais revalider
  res.sendFile('app.js');
});

// Donn√©es fr√©quemment mises √† jour
app.get('/api/stock/:productId', async (req, res) => {
  const stock = await getStock(req.params.productId);

  res.set({
    'Cache-Control': 'public, max-age=60', // 1 minute
    'ETag': generateETag(stock)
  });
  res.json(stock);
});

// Donn√©es personnalis√©es
app.get('/api/user/cart', authenticateUser, async (req, res) => {
  const cart = await getCart(req.user.id);

  res.set({
    'Cache-Control': 'private, max-age=300', // Cache navigateur uniquement
    'ETag': generateETag(cart)
  });
  res.json(cart);
});

// Donn√©es temps r√©el
app.get('/api/live-prices', async (req, res) => {
  const prices = await getLivePrices();

  res.set({
    'Cache-Control': 'no-cache, must-revalidate', // Toujours revalider
    'ETag': generateETag(prices)
  });
  res.json(prices);
});
```

**Invalidation de cache :**

Le probl√®me classique : "Il n'y a que deux choses difficiles en informatique : l'invalidation de cache et nommer les choses."

```python
# Strat√©gie 1 : Versioning dans l'URL
GET /api/v1/products/123?v=1638360000
# Changement de version = nouvelle URL = nouveau cache

# Strat√©gie 2 : Purge explicite (Varnish, Cloudflare)
import requests

def update_product(product_id, data):
    # Mise √† jour en base
    db.products.update(product_id, data)

    # Purge du cache CDN
    requests.request(
        'PURGE',
        f'https://cdn.shop.com/api/products/{product_id}',
        headers={'X-Purge-Key': PURGE_SECRET}
    )

# Strat√©gie 3 : TTL court + validation ETag
# Le cache expire rapidement, mais la revalidation est rapide avec ETag
```

### 4. Interface uniforme (Uniform Interface)

**Principe :** L'interface entre client et serveur doit √™tre uniforme et standardis√©e. C'est la contrainte la plus distinctive de REST.

Cette contrainte se d√©cline en quatre sous-contraintes :

#### 4a. Identification des ressources

**Chaque ressource a un identifiant unique (URI).**

```
Bonnes pratiques :

‚úÖ /users/123                    (ressource sp√©cifique)
‚úÖ /users                        (collection)
‚úÖ /users/123/orders             (sous-ressource)
‚úÖ /users/123/orders/456         (ressource imbriqu√©e)

‚ùå /getUser?id=123              (verbe dans l'URL)
‚ùå /user_details.php?userId=123 (d√©pendance √† la techno)
‚ùå /api/v1/getUserById          (pas RESTful)
```

**Exemple - API de blog :**

```
Ressources et leurs URIs :

Articles :
GET    /articles              ‚Üí Liste des articles
GET    /articles/42           ‚Üí Article sp√©cifique
POST   /articles              ‚Üí Cr√©er un article
PUT    /articles/42           ‚Üí Remplacer l'article
PATCH  /articles/42           ‚Üí Modifier partiellement
DELETE /articles/42           ‚Üí Supprimer l'article

Commentaires (sous-ressource) :
GET    /articles/42/comments           ‚Üí Commentaires de l'article 42
POST   /articles/42/comments           ‚Üí Ajouter un commentaire
GET    /articles/42/comments/7         ‚Üí Commentaire sp√©cifique
DELETE /articles/42/comments/7         ‚Üí Supprimer le commentaire
```

**Impact r√©seau :**

Les URIs pr√©visibles permettent :
- **D√©couvrabilit√©** : Navigation intuitive
- **Bookmarkabilit√©** : Liens stables partageables
- **Cache efficace** : URLs canoniques, pas de param√®tres variables inutiles

```javascript
// ‚úÖ Bon - URL canonique, cachable
GET /products?category=electronics&sort=price&order=asc

// ‚ùå Mauvais - Param√®tres redondants, cache fragment√©
GET /products?category=electronics&sort=price&order=asc&timestamp=1638360000&session=xyz
```

#### 4b. Manipulation via repr√©sentations

**Les clients manipulent les ressources via leurs repr√©sentations (JSON, XML, HTML, etc.).**

Le serveur envoie une repr√©sentation de la ressource, pas la ressource elle-m√™me.

```http
GET /users/123 HTTP/1.1
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "username": "john_doe",
  "email": "john@example.com",
  "created_at": "2024-01-15T10:00:00Z"
}
```

**Content Negotiation :**

Le client peut demander diff√©rentes repr√©sentations de la m√™me ressource.

```http
# Client demande JSON
GET /users/123 HTTP/1.1
Accept: application/json

# Client demande XML
GET /users/123 HTTP/1.1
Accept: application/xml

# Client demande HTML (pour navigateur)
GET /users/123 HTTP/1.1
Accept: text/html
```

**Exemple en Go :**

```go
// Serveur Go avec content negotiation
func getUserHandler(w http.ResponseWriter, r *http.Request) {
    userID := mux.Vars(r)["id"]
    user := db.GetUser(userID)

    // Content negotiation bas√© sur Accept header
    acceptHeader := r.Header.Get("Accept")

    switch {
    case strings.Contains(acceptHeader, "application/json"):
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)

    case strings.Contains(acceptHeader, "application/xml"):
        w.Header().Set("Content-Type", "application/xml")
        xml.NewEncoder(w).Encode(user)

    case strings.Contains(acceptHeader, "text/html"):
        w.Header().Set("Content-Type", "text/html")
        renderHTML(w, "user.html", user)

    default:
        // Default: JSON
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)
    }
}
```

**Impact r√©seau :**

- **Flexibilit√©** : M√™me URI, diff√©rents formats selon le client
- **Compression** : Content-Encoding (gzip, brotli) appliqu√© selon capacit√©s client
- **Versioning implicite** : Nouveaux formats sans changer l'URI

```http
GET /api/products/123 HTTP/1.1
Accept: application/vnd.company.product.v2+json
Accept-Encoding: gzip, br

# Serveur peut retourner version 2 du format, compress√© en Brotli
```

#### 4c. Messages auto-descriptifs

**Chaque message contient assez d'informations pour √™tre compris sans contexte additionnel.**

```http
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 1234
Cache-Control: public, max-age=3600
ETag: "abc123"
Last-Modified: Wed, 01 Dec 2024 12:00:00 GMT
Link: </api/users/123/orders>; rel="orders"

{
  "id": 123,
  "username": "john_doe",
  "_links": {
    "self": { "href": "/users/123" },
    "orders": { "href": "/users/123/orders" },
    "avatar": { "href": "/users/123/avatar" }
  }
}
```

**Chaque √©l√©ment informe :**
- `Content-Type` : Format de la r√©ponse
- `Content-Length` : Taille pour buffer allocation
- `Cache-Control` : Instructions de cache
- `ETag` : Version pour validation cache
- `Last-Modified` : Date de modification
- `Link` : Relations avec autres ressources (hypermedia)

**Impact r√©seau :**

- Clients peuvent prendre des d√©cisions de cache sans logique custom
- Proxies peuvent router/transformer sans connaissance m√©tier
- Debugging simplifi√© (headers auto-explicatifs)

#### 4d. HATEOAS (Hypermedia As The Engine Of Application State)

**Le client navigue l'API via des hyperliens fournis par le serveur.**

C'est la contrainte la moins respect√©e en pratique, mais la plus puissante th√©oriquement.

```json
// R√©ponse HATEOAS compl√®te
{
  "order": {
    "id": 789,
    "status": "pending",
    "total": 150.00,
    "items": [...]
  },
  "_links": {
    "self": {
      "href": "/orders/789"
    },
    "payment": {
      "href": "/orders/789/payment",
      "method": "POST",
      "description": "Pay for this order"
    },
    "cancel": {
      "href": "/orders/789",
      "method": "DELETE",
      "description": "Cancel this order"
    },
    "items": {
      "href": "/orders/789/items"
    }
  },
  "_actions": {
    "pay": {
      "href": "/orders/789/payment",
      "method": "POST",
      "fields": [
        { "name": "payment_method", "type": "string", "required": true },
        { "name": "amount", "type": "number", "required": true }
      ]
    }
  }
}
```

**Le client peut :**
- D√©couvrir les actions possibles dynamiquement
- Suivre les liens sans hardcoder les URLs
- S'adapter aux changements d'URL c√¥t√© serveur

**Exemple - Client g√©n√©rique :**

```javascript
// Client qui suit les liens dynamiquement
async function processOrder(orderId) {
  // 1. R√©cup√©rer la commande
  const orderResponse = await fetch(`/orders/${orderId}`);
  const order = await orderResponse.json();

  // 2. V√©rifier les actions disponibles (pas de hardcode)
  if (order._links.payment) {
    // L'action de paiement est disponible
    const paymentUrl = order._links.payment.href;

    await fetch(paymentUrl, {
      method: order._links.payment.method || 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        payment_method: 'credit_card',
        amount: order.total
      })
    });
  } else {
    // Pas de lien payment = action non disponible (d√©j√† pay√© ?)
    console.log('Cannot pay for this order');
  }
}
```

**Avantages r√©seau et √©volutivit√© :**

1. **D√©couplage URL :** Le serveur peut changer les URLs sans casser les clients
2. **Versioning progressif :** Nouveaux liens ajout√©s sans breaking change
3. **Documentation dynamique :** L'API se d√©crit elle-m√™me

**Limitation pratique :**

HATEOAS est rarement impl√©ment√© compl√®tement car :
- Overhead de taille de r√©ponse (liens additionnels)
- Complexit√© c√¥t√© client
- Pr√©f√©rence pour des clients fortement typ√©s (OpenAPI/Swagger)

**Compromis courant :**

```json
// Approche hybride : liens pour navigation, types pour validation
{
  "user": {
    "id": 123,
    "username": "john_doe"
  },
  "links": {
    "self": "/users/123",
    "orders": "/users/123/orders"
  }
}
```

### 5. Syst√®me en couches (Layered System)

**Principe :** L'architecture peut √™tre compos√©e de plusieurs couches. Chaque composant ne peut voir que la couche imm√©diate avec laquelle il interagit.

```
Client
  ‚Üì
CDN (Cloudflare)
  ‚Üì
Load Balancer (AWS ELB)
  ‚Üì
Reverse Proxy (Nginx)
  ‚Üì
API Gateway
  ‚Üì
Application Server
  ‚Üì
Database
```

**Le client ne sait pas (et ne devrait pas savoir) combien de couches existent entre lui et le serveur final.**

**Implications r√©seau :**

Chaque couche peut optimiser les performances r√©seau :

```javascript
// Configuration Nginx (Reverse Proxy)
http {
  # Cache des r√©ponses
  proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=api_cache:10m;

  # Compression
  gzip on;
  gzip_types application/json;

  # Rate limiting
  limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;

  upstream api_servers {
    server api1.internal:3000;
    server api2.internal:3000;
    server api3.internal:3000;
  }

  server {
    listen 80;

    location /api/ {
      # Rate limiting
      limit_req zone=api_limit burst=20;

      # Cache
      proxy_cache api_cache;
      proxy_cache_valid 200 5m;

      # Headers pour le client
      add_header X-Cache-Status $upstream_cache_status;

      # Proxy vers upstream
      proxy_pass http://api_servers;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
    }
  }
}
```

**Avantages r√©seau :**

1. **Scalabilit√©** : Ajout de couches sans modification client
2. **S√©curit√©** : Firewall, WAF √† diff√©rents niveaux
3. **Performance** : Cache √† plusieurs niveaux
4. **R√©silience** : Retry, circuit breaker par couche

**Exemple - Tra√ßage de requ√™te multi-couches :**

```http
GET /api/products/123 HTTP/1.1
Host: api.example.com

# R√©ponse avec headers de toutes les couches
HTTP/1.1 200 OK
X-Cache: HIT (CDN Cloudflare)
X-Proxy-Cache: MISS (Nginx)
X-Served-By: api-server-3
X-Response-Time: 45ms
Via: 1.1 cloudflare, 1.1 nginx-proxy
```

### 6. Code √† la demande (Code-On-Demand) - Optionnel

**Principe :** Le serveur peut √©tendre temporairement les fonctionnalit√©s du client en transmettant du code ex√©cutable (JavaScript, Java applets, etc.).

Cette contrainte est **optionnelle** et rarement utilis√©e dans les APIs modernes.

```html
<!-- Exemple classique : JavaScript charg√© depuis le serveur -->
GET /app HTTP/1.1

HTTP/1.1 200 OK
Content-Type: text/html

<html>
  <body>
    <div id="app"></div>
    <!-- Code fourni par le serveur -->
    <script src="/static/app-v1.2.3.js"></script>
  </body>
</html>
```

**Implications r√©seau :**

- Le client t√©l√©charge du code suppl√©mentaire (overhead r√©seau)
- Mais r√©duit le nombre d'appels API ensuite (logique c√¥t√© client)

## M√©thodes HTTP et s√©mantique r√©seau

REST s'appuie sur les m√©thodes HTTP pour d√©finir les op√©rations sur les ressources.

### GET - Lecture de ressource

**Caract√©ristiques r√©seau :**
- **Idempotent** : Multiples appels identiques = m√™me r√©sultat
- **Safe** : Ne modifie pas l'√©tat serveur
- **Cachable** : Peut √™tre cach√© agressivement

```http
GET /products/123 HTTP/1.1
Host: api.shop.com
Accept: application/json
If-None-Match: "abc123"  # ETag pour validation cache

# R√©ponse avec cache
HTTP/1.1 200 OK
Cache-Control: public, max-age=3600
ETag: "abc123"
Content-Length: 456

{ "id": 123, "name": "Laptop", "price": 999 }
```

**Erreurs courantes :**

```javascript
// ‚ùå MAUVAIS - GET qui modifie l'√©tat
app.get('/users/:id/activate', (req, res) => {
  db.users.update(req.params.id, { active: true });
  res.json({ success: true });
});
// Probl√®me : peut √™tre cach√©, appel√© par des crawlers, etc.

// ‚úÖ BON - POST/PUT pour modifications
app.post('/users/:id/activation', (req, res) => {
  db.users.update(req.params.id, { active: true });
  res.json({ success: true });
});
```

### POST - Cr√©ation de ressource

**Caract√©ristiques r√©seau :**
- **Non-idempotent** : Multiples appels = multiples cr√©ations
- **Non-safe** : Modifie l'√©tat serveur
- **Non-cachable** : R√©ponse g√©n√©ralement pas cach√©e

```http
POST /products HTTP/1.1
Host: api.shop.com
Content-Type: application/json
Content-Length: 78

{
  "name": "New Laptop",
  "price": 1299.99,
  "category": "electronics"
}

# R√©ponse avec location de la nouvelle ressource
HTTP/1.1 201 Created
Location: /products/124
Content-Type: application/json

{
  "id": 124,
  "name": "New Laptop",
  "price": 1299.99,
  "category": "electronics",
  "created_at": "2024-12-07T10:30:00Z"
}
```

**Header Location :**

Crucial pour REST - indique l'URI de la ressource cr√©√©e.

```javascript
// Node.js - Bonne pratique
app.post('/products', async (req, res) => {
  const product = await db.products.create(req.body);

  res
    .status(201)
    .location(`/products/${product.id}`)  // URI de la nouvelle ressource
    .json(product);
});
```

**Gestion de l'idempotence avec cl√© d'idempotence :**

Pour √©viter les cr√©ations doubles en cas de retry r√©seau :

```http
POST /orders HTTP/1.1
Idempotency-Key: 123e4567-e89b-12d3-a456-426614174000
Content-Type: application/json

{ "items": [...], "total": 150 }
```

```python
# Serveur Python
import uuid
from flask import Flask, request

app = Flask(__name__)
idempotency_cache = {}  # En production : Redis

@app.route('/orders', methods=['POST'])
def create_order():
    idempotency_key = request.headers.get('Idempotency-Key')

    if idempotency_key:
        # V√©rifier si la requ√™te a d√©j√† √©t√© trait√©e
        if idempotency_key in idempotency_cache:
            # Retourner la r√©ponse en cache
            return idempotency_cache[idempotency_key], 200

    # Cr√©er la commande
    order = db.orders.create(request.json)
    response = jsonify(order)

    # Mettre en cache pour 24h
    if idempotency_key:
        idempotency_cache[idempotency_key] = (response.get_json(), 201)

    return response, 201
```

### PUT - Remplacement complet

**Caract√©ristiques r√©seau :**
- **Idempotent** : Multiples appels identiques = m√™me r√©sultat final
- **Non-safe** : Modifie l'√©tat serveur
- **Non-cachable**

```http
PUT /products/123 HTTP/1.1
Host: api.shop.com
Content-Type: application/json

{
  "name": "Updated Laptop",
  "price": 899.99,
  "category": "electronics",
  "description": "New description"
}

HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "name": "Updated Laptop",
  "price": 899.99,
  "category": "electronics",
  "description": "New description",
  "updated_at": "2024-12-07T11:00:00Z"
}
```

**Idempotence en pratique :**

```javascript
// Appel 1
PUT /products/123
{ "name": "Laptop", "price": 999 }
‚Üí Produit mis √† jour

// Appel 2 (identique)
PUT /products/123
{ "name": "Laptop", "price": 999 }
‚Üí Produit inchang√© (m√™me √©tat final)

// R√©sultat identique = idempotent
```

**Cr√©ation vs Mise √† jour :**

PUT peut aussi cr√©er une ressource si l'ID est connu √† l'avance :

```http
# Client g√©n√®re l'ID (UUID)
PUT /products/550e8400-e29b-41d4-a716-446655440000 HTTP/1.1
Content-Type: application/json

{ "name": "New Product", "price": 50 }

# Si la ressource n'existe pas
HTTP/1.1 201 Created
Location: /products/550e8400-e29b-41d4-a716-446655440000

# Si la ressource existe d√©j√†
HTTP/1.1 200 OK
```

### PATCH - Modification partielle

**Caract√©ristiques r√©seau :**
- **G√©n√©ralement non-idempotent** (d√©pend du patch)
- **Non-safe**
- **Non-cachable**

```http
PATCH /products/123 HTTP/1.1
Host: api.shop.com
Content-Type: application/json

{
  "price": 849.99
}

HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "name": "Laptop",  # Inchang√©
  "price": 849.99,   # Modifi√©
  "category": "electronics",  # Inchang√©
  "updated_at": "2024-12-07T11:15:00Z"
}
```

**Format JSON Patch (RFC 6902) :**

Permet des modifications plus complexes et pr√©visibles :

```http
PATCH /products/123 HTTP/1.1
Content-Type: application/json-patch+json

[
  { "op": "replace", "path": "/price", "value": 849.99 },
  { "op": "add", "path": "/tags/-", "value": "sale" },
  { "op": "remove", "path": "/discount" }
]
```

**Diff√©rence PUT vs PATCH :**

```
Ressource actuelle :
{ "id": 123, "name": "Laptop", "price": 999, "stock": 10 }

PUT /products/123
{ "name": "Laptop", "price": 899 }
‚Üí R√©sultat : { "id": 123, "name": "Laptop", "price": 899 }
  (stock supprim√© !)

PATCH /products/123
{ "price": 899 }
‚Üí R√©sultat : { "id": 123, "name": "Laptop", "price": 899, "stock": 10 }
  (stock conserv√©)
```

### DELETE - Suppression

**Caract√©ristiques r√©seau :**
- **Idempotent** : Supprimer 2√ó une ressource = m√™me r√©sultat (elle n'existe plus)
- **Non-safe**
- **Non-cachable**

```http
DELETE /products/123 HTTP/1.1
Host: api.shop.com

HTTP/1.1 204 No Content

# Ou avec r√©ponse d√©taill√©e
HTTP/1.1 200 OK
Content-Type: application/json

{
  "message": "Product deleted successfully",
  "deleted_at": "2024-12-07T11:30:00Z"
}
```

**Idempotence du DELETE :**

```javascript
// Appel 1
DELETE /products/123
‚Üí 204 No Content (ressource supprim√©e)

// Appel 2 (m√™me requ√™te)
DELETE /products/123
‚Üí 404 Not Found OU 204 No Content

// Les deux sont acceptables et consid√©r√©s comme idempotents
// Car l'√©tat final est identique : la ressource n'existe pas
```

**Soft delete :**

En pratique, beaucoup d'APIs font du soft delete :

```javascript
app.delete('/products/:id', async (req, res) => {
  // Pas vraiment supprim√©, juste marqu√©
  await db.products.update(req.params.id, {
    deleted: true,
    deleted_at: new Date()
  });

  res.status(204).end();
});

// Les GET ne retournent plus cette ressource
app.get('/products/:id', async (req, res) => {
  const product = await db.products.findOne({
    id: req.params.id,
    deleted: false  // Filtre
  });

  if (!product) {
    return res.status(404).json({ error: 'Not found' });
  }

  res.json(product);
});
```

### OPTIONS - M√©tadonn√©es

Utilis√© pour d√©couvrir les op√©rations support√©es (souvent pour CORS) :

```http
OPTIONS /products/123 HTTP/1.1
Host: api.shop.com

HTTP/1.1 200 OK
Allow: GET, PUT, PATCH, DELETE
Access-Control-Allow-Methods: GET, PUT, PATCH, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
```

## Codes de statut HTTP et leur s√©mantique r√©seau

Les codes de statut HTTP communiquent le r√©sultat d'une op√©ration de mani√®re standardis√©e.

### 2xx - Succ√®s

```
200 OK               - Succ√®s g√©n√©ral (GET, PUT, PATCH)
201 Created          - Ressource cr√©√©e (POST)
202 Accepted         - Traitement asynchrone accept√©
204 No Content       - Succ√®s sans corps de r√©ponse (DELETE)
```

**Exemple 202 Accepted :**

Pour op√©rations longues (g√©n√©ration de rapport, etc.) :

```http
POST /reports/generate HTTP/1.1
Content-Type: application/json

{ "type": "sales", "year": 2024 }

HTTP/1.1 202 Accepted
Location: /reports/jobs/abc-123
Content-Type: application/json

{
  "job_id": "abc-123",
  "status": "processing",
  "status_url": "/reports/jobs/abc-123"
}
```

Client peut ensuite poller :

```http
GET /reports/jobs/abc-123 HTTP/1.1

HTTP/1.1 200 OK
Content-Type: application/json

{
  "job_id": "abc-123",
  "status": "completed",
  "result_url": "/reports/abc-123.pdf"
}
```

### 3xx - Redirection

```
301 Moved Permanently    - Ressource d√©plac√©e d√©finitivement
302 Found               - Redirection temporaire
304 Not Modified        - Cache valide (avec ETag/Last-Modified)
307 Temporary Redirect  - Redirection temporaire (m√©thode pr√©serv√©e)
308 Permanent Redirect  - Redirection permanente (m√©thode pr√©serv√©e)
```

**Impact r√©seau de la 304 :**

```http
# Requ√™te avec ETag
GET /products/123 HTTP/1.1
If-None-Match: "abc123"

# Serveur v√©rifie que l'ETag est toujours valide
HTTP/1.1 304 Not Modified
ETag: "abc123"
# Pas de body ‚Üí √©conomie de bande passante

# Client utilise sa version en cache
```

### 4xx - Erreurs client

```
400 Bad Request          - Requ√™te malform√©e
401 Unauthorized         - Authentication requise
403 Forbidden            - Acc√®s interdit
404 Not Found            - Ressource inexistante
405 Method Not Allowed   - M√©thode HTTP non support√©e
409 Conflict             - Conflit (ex: contrainte unicit√©)
422 Unprocessable Entity - Validation √©chou√©e
429 Too Many Requests    - Rate limiting
```

**Exemple - Validation d√©taill√©e :**

```http
POST /users HTTP/1.1
Content-Type: application/json

{
  "username": "ab",
  "email": "invalid-email",
  "age": -5
}

HTTP/1.1 422 Unprocessable Entity
Content-Type: application/json

{
  "error": "Validation failed",
  "details": [
    {
      "field": "username",
      "message": "Must be at least 3 characters"
    },
    {
      "field": "email",
      "message": "Invalid email format"
    },
    {
      "field": "age",
      "message": "Must be a positive number"
    }
  ]
}
```

**Rate limiting avec 429 :**

```http
GET /api/products HTTP/1.1

HTTP/1.1 429 Too Many Requests
Retry-After: 60
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1638363600

{
  "error": "Rate limit exceeded",
  "retry_after_seconds": 60
}
```

### 5xx - Erreurs serveur

```
500 Internal Server Error - Erreur serveur g√©n√©rique
502 Bad Gateway          - Erreur du serveur upstream
503 Service Unavailable  - Service temporairement indisponible
504 Gateway Timeout      - Timeout du serveur upstream
```

**Bonnes pratiques :**

```javascript
app.get('/products/:id', async (req, res) => {
  try {
    const product = await db.products.findById(req.params.id);

    if (!product) {
      // 404 - Client error (ressource n'existe pas)
      return res.status(404).json({
        error: 'Product not found',
        product_id: req.params.id
      });
    }

    res.json(product);

  } catch (error) {
    console.error('Database error:', error);

    // 500 - Server error (probl√®me serveur, pas du client)
    res.status(500).json({
      error: 'Internal server error',
      message: 'An error occurred while fetching the product'
    });
  }
});
```

## Versioning d'API

Le versioning est crucial pour l'√©volution d'une API sans casser les clients existants.

### Approche 1 : URL versioning

**La plus r√©pandue :**

```
/api/v1/products
/api/v2/products
/api/v3/products
```

**Avantages :**
- Simplicit√© et clart√©
- Facile √† router et √† cacher
- Versioning √©vident dans les logs

**Inconv√©nients :**
- Viole le principe REST que l'URI identifie la ressource (pas sa version)
- Duplication de code c√¥t√© serveur

```javascript
// Impl√©mentation Node.js
const express = require('express');
const app = express();

// v1 de l'API
app.get('/api/v1/products/:id', async (req, res) => {
  const product = await db.products.findById(req.params.id);

  // Format v1
  res.json({
    id: product.id,
    name: product.name,
    price: product.price
  });
});

// v2 de l'API (plus de d√©tails)
app.get('/api/v2/products/:id', async (req, res) => {
  const product = await db.products.findById(req.params.id);

  // Format v2 avec champs additionnels
  res.json({
    id: product.id,
    name: product.name,
    price: product.price,
    currency: 'USD',
    stock: product.stock,
    images: product.images
  });
});
```

### Approche 2 : Header versioning

**Plus RESTful :**

```http
GET /api/products/123 HTTP/1.1
Accept: application/vnd.company.api+json;version=1

GET /api/products/123 HTTP/1.1
Accept: application/vnd.company.api+json;version=2
```

**Avantages :**
- URI stable (principe REST respect√©)
- Content negotiation standard

**Inconv√©nients :**
- Moins visible (dans les headers)
- Cache plus complexe (doit consid√©rer le header Accept)
- Debugging moins √©vident

```javascript
// Middleware de versioning
app.use((req, res, next) => {
  const acceptHeader = req.headers.accept || '';

  // Parse version from Accept header
  const versionMatch = acceptHeader.match(/version=(\d+)/);
  req.apiVersion = versionMatch ? parseInt(versionMatch[1]) : 1;

  next();
});

app.get('/api/products/:id', async (req, res) => {
  const product = await db.products.findById(req.params.id);

  if (req.apiVersion === 2) {
    // Format v2
    res.json({
      id: product.id,
      name: product.name,
      price: product.price,
      currency: 'USD',
      stock: product.stock
    });
  } else {
    // Format v1 (default)
    res.json({
      id: product.id,
      name: product.name,
      price: product.price
    });
  }
});
```

### Approche 3 : Query parameter

```
/api/products/123?version=1
/api/products/123?version=2
```

**Avantages :**
- Simple

**Inconv√©nients :**
- Pollue l'URI
- Cache fragment√©
- Rarement recommand√©

### Strat√©gie de d√©pr√©ciation

```http
GET /api/v1/products/123 HTTP/1.1

HTTP/1.1 200 OK
Deprecation: true
Sunset: Sat, 31 Dec 2025 23:59:59 GMT
Link: </api/v2/products/123>; rel="successor-version"
Warning: 299 - "API v1 is deprecated. Please migrate to v2 by Dec 2025"

{
  "id": 123,
  "name": "Product"
}
```

## Gestion des erreurs r√©seau c√¥t√© client

Les clients REST doivent g√©rer les erreurs r√©seau de mani√®re r√©siliente.

### Retry avec backoff exponentiel

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let lastError;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);

      // Succ√®s
      if (response.ok) {
        return response;
      }

      // Erreurs non-retriable
      if (response.status >= 400 && response.status < 500) {
        // 4xx = erreur client, pas la peine de retry
        throw new Error(`Client error: ${response.status}`);
      }

      // 5xx = erreur serveur, on peut retry
      lastError = new Error(`Server error: ${response.status}`);

    } catch (error) {
      // Erreurs r√©seau (timeout, connection refused, etc.)
      lastError = error;
    }

    // Si ce n'est pas le dernier essai, attendre avant de retry
    if (attempt < maxRetries) {
      // Backoff exponentiel : 1s, 2s, 4s, 8s...
      const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw lastError;
}

// Utilisation
try {
  const response = await fetchWithRetry('https://api.example.com/products');
  const data = await response.json();
} catch (error) {
  console.error('Failed after retries:', error);
}
```

### Circuit Breaker

Pattern pour √©viter de surcharger un service d√©faillant :

```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureThreshold = threshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }

  async call(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      // Try to recover
      this.state = 'HALF_OPEN';
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }

  onFailure() {
    this.failureCount++;

    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}

// Utilisation
const breaker = new CircuitBreaker(5, 60000);

async function getProducts() {
  return breaker.call(async () => {
    const response = await fetch('https://api.example.com/products');
    if (!response.ok) throw new Error('API error');
    return response.json();
  });
}
```

## Performance et optimisation r√©seau

### Compression

**Toujours activer la compression pour JSON :**

```javascript
// Serveur Node.js
const compression = require('compression');
app.use(compression());

// R√©duction typique : 60-80% pour JSON
// Exemple : 100 KB ‚Üí 20-40 KB
```

```http
GET /api/products HTTP/1.1
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Encoding: br
Content-Length: 3456  # Taille compress√©e
# Taille originale : ~15 KB

[...]  # Donn√©es compress√©es en Brotli
```

### Pagination

**√âviter de charger toutes les ressources d'un coup :**

```javascript
// ‚ùå MAUVAIS - Peut retourner 10,000 produits
GET /api/products

// ‚úÖ BON - Pagination
GET /api/products?page=1&limit=50
GET /api/products?offset=0&limit=50
```

**Impl√©mentation avec cursor-based pagination :**

```javascript
app.get('/api/products', async (req, res) => {
  const limit = Math.min(parseInt(req.query.limit) || 50, 100);
  const cursor = req.query.cursor;

  let query = db.products.find();

  if (cursor) {
    // Continuer apr√®s le cursor
    query = query.where('id').gt(cursor);
  }

  const products = await query.limit(limit + 1).sort('id');

  // V√©rifier s'il y a une page suivante
  const hasMore = products.length > limit;
  const items = hasMore ? products.slice(0, -1) : products;

  const response = {
    data: items,
    pagination: {
      limit,
      has_more: hasMore
    }
  };

  if (hasMore) {
    response.pagination.next_cursor = items[items.length - 1].id;
    response.pagination.next_url = `/api/products?limit=${limit}&cursor=${response.pagination.next_cursor}`;
  }

  res.json(response);
});
```

**R√©ponse :**

```json
{
  "data": [
    { "id": 1, "name": "Product 1" },
    { "id": 2, "name": "Product 2" },
    ...
  ],
  "pagination": {
    "limit": 50,
    "has_more": true,
    "next_cursor": "50",
    "next_url": "/api/products?limit=50&cursor=50"
  }
}
```

### Champs s√©lectifs (Field Selection)

**Permettre au client de sp√©cifier les champs d√©sir√©s :**

```
GET /api/products/123?fields=id,name,price

‚Üí { "id": 123, "name": "Laptop", "price": 999 }

vs

GET /api/products/123

‚Üí {
    "id": 123,
    "name": "Laptop",
    "price": 999,
    "description": "...",  # Non demand√©
    "images": [...],       # Non demand√©
    "reviews": [...]       # Non demand√©
  }
```

**Impl√©mentation :**

```javascript
app.get('/api/products/:id', async (req, res) => {
  const product = await db.products.findById(req.params.id);

  if (!product) {
    return res.status(404).json({ error: 'Not found' });
  }

  // Field selection
  const fields = req.query.fields;

  if (fields) {
    const fieldList = fields.split(',');
    const filtered = {};

    fieldList.forEach(field => {
      if (product[field] !== undefined) {
        filtered[field] = product[field];
      }
    });

    return res.json(filtered);
  }

  // Retourner tout si pas de fields
  res.json(product);
});
```

### Batch Requests

**Permettre plusieurs op√©rations en une requ√™te :**

```http
POST /api/batch HTTP/1.1
Content-Type: application/json

{
  "requests": [
    { "method": "GET", "url": "/products/1" },
    { "method": "GET", "url": "/products/2" },
    { "method": "POST", "url": "/cart/items", "body": { "productId": 1 } }
  ]
}

HTTP/1.1 200 OK

{
  "responses": [
    { "status": 200, "body": { "id": 1, "name": "Product 1" } },
    { "status": 200, "body": { "id": 2, "name": "Product 2" } },
    { "status": 201, "body": { "itemId": 123 } }
  ]
}
```

**√âconomie r√©seau :**
- 1 connexion TCP au lieu de 3
- 1 handshake TLS au lieu de 3
- Overhead HTTP r√©duit

## S√©curit√©

### HTTPS obligatoire

```javascript
// Redirection automatique HTTP ‚Üí HTTPS
app.use((req, res, next) => {
  if (!req.secure && req.get('x-forwarded-proto') !== 'https') {
    return res.redirect(301, `https://${req.hostname}${req.url}`);
  }
  next();
});

// HSTS - Force HTTPS pour les prochaines visites
app.use((req, res, next) => {
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  next();
});
```

### CORS (Cross-Origin Resource Sharing)

```javascript
app.use((req, res, next) => {
  // Autoriser certaines origines
  const allowedOrigins = ['https://app.example.com', 'https://mobile.example.com'];
  const origin = req.headers.origin;

  if (allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }

  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.setHeader('Access-Control-Max-Age', '86400'); // Cache preflight 24h

  // Preflight request
  if (req.method === 'OPTIONS') {
    return res.status(204).end();
  }

  next();
});
```

### Rate Limiting

```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Max 100 requ√™tes par IP
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    res.status(429).json({
      error: 'Too many requests',
      retry_after: Math.ceil(req.rateLimit.resetTime / 1000)
    });
  }
});

app.use('/api/', limiter);
```

## Conclusion

REST est bien plus qu'une simple convention de nommage d'URLs. C'est un style architectural qui, lorsqu'il est correctement appliqu√©, offre :

**Avantages r√©seau :**
- **Scalabilit√©** : Stateless permet le load balancing simple
- **Performance** : Cache √† plusieurs niveaux
- **R√©silience** : Idempotence et retry logic
- **Simplicit√©** : Standards HTTP universels

**Contraintes √† respecter :**
- S√©paration client-serveur
- Sans √©tat (pas de sessions serveur)
- Cachabilit√© explicite
- Interface uniforme (URIs, m√©thodes HTTP, codes statut)
- Syst√®me en couches
- (Optionnel) Code √† la demande

**Dans la pratique :**
- Rares sont les APIs parfaitement RESTful
- Les compromis pragmatiques sont acceptables
- L'important est de comprendre les implications r√©seau de chaque choix

**Prochaine section :** 8.10.2 gRPC : HTTP/2 et Protocol Buffers

---

**Points cl√©s √† retenir :**
- REST = contraintes architecturales, pas juste "HTTP + JSON"
- Stateless = scalabilit√©, mais overhead de transmission
- Cache = performance cruciale (ETag, Cache-Control)
- M√©thodes HTTP ont des s√©mantiques r√©seau pr√©cises (idempotence, safety)
- Codes de statut communiquent le r√©sultat de mani√®re standardis√©e
- HTTPS, compression, pagination sont essentiels en production

‚è≠Ô∏è [gRPC : HTTP/2 et Protocol Buffers](/08-programmation-reseau/10.2-grpc.md)
