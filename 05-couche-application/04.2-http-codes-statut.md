ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 5.4.2 Codes de statut HTTP

## Introduction

Les **codes de statut HTTP** (HTTP status codes) sont des nombres Ã  trois chiffres que le serveur renvoie dans chaque rÃ©ponse HTTP pour indiquer le rÃ©sultat du traitement de la requÃªte. Ils constituent un langage standardisÃ© permettant au client de comprendre immÃ©diatement ce qui s'est passÃ© : la requÃªte a-t-elle rÃ©ussi ? Y a-t-il eu une erreur ? Faut-il effectuer une action supplÃ©mentaire ?

Chaque fois que votre navigateur affiche une page web, tÃ©lÃ©charge un fichier, ou qu'une API retourne des donnÃ©es, un code de statut accompagne la rÃ©ponse. Certains sont cÃ©lÃ¨bres (comme le fameux **404 Not Found**), d'autres moins connus mais tout aussi importants.

## Structure d'un code de statut

Un code de statut HTTP se compose de **trois chiffres** et d'une **phrase de raison** (reason phrase) :

```http
HTTP/1.1 200 OK
         â”‚   â”‚
         â”‚   â””â”€ Phrase de raison (description textuelle)
         â””â”€ Code numÃ©rique (3 chiffres)
```

**Exemples :**
```http
HTTP/1.1 200 OK
HTTP/1.1 404 Not Found
HTTP/1.1 500 Internal Server Error
HTTP/1.1 201 Created
```

**Note importante :** La phrase de raison est **informative** et peut varier. C'est le **code numÃ©rique** qui compte vraiment pour l'interprÃ©tation par les programmes.

## Les cinq catÃ©gories de codes

Les codes de statut sont organisÃ©s en **5 catÃ©gories** selon leur premier chiffre :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1xx  â”‚  Informationnels  â”‚  Traitement en cours       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  2xx  â”‚  SuccÃ¨s           â”‚  RequÃªte rÃ©ussie           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  3xx  â”‚  Redirection      â”‚  Action supplÃ©mentaire     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  4xx  â”‚  Erreur client    â”‚  ProblÃ¨me dans la requÃªte  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  5xx  â”‚  Erreur serveur   â”‚  ProblÃ¨me cÃ´tÃ© serveur     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### MnÃ©motechnique simple

```
1xx â†’ "Attends, je traite..."
2xx â†’ "Super, tout va bien !"
3xx â†’ "Va voir ailleurs..."
4xx â†’ "Tu as fait une erreur"
5xx â†’ "J'ai fait une erreur"
```

## 1xx - Codes informationnels

Les codes **1xx** indiquent que le serveur a reÃ§u la requÃªte et continue de la traiter. Ils sont **rarement visibles** par les utilisateurs finaux car ils sont gÃ©rÃ©s en arriÃ¨re-plan.

### 100 Continue

**Usage :** Le client peut continuer Ã  envoyer le corps de la requÃªte.

**Contexte :** UtilisÃ© avec l'en-tÃªte `Expect: 100-continue` pour Ã©viter d'envoyer un gros corps de requÃªte si le serveur va le rejeter.

```http
Client envoie :
POST /upload HTTP/1.1
Host: api.example.com
Content-Length: 104857600
Expect: 100-continue

Serveur rÃ©pond :
HTTP/1.1 100 Continue

Client envoie maintenant les 100 MB de donnÃ©es...
```

**Avantage :** Ã‰vite de gaspiller de la bande passante si le serveur va rejeter la requÃªte (par exemple, authentification invalide).

### 101 Switching Protocols

**Usage :** Le serveur accepte de changer de protocole selon la demande du client.

**Exemple concret : WebSocket**
```http
Client :
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade

Serveur :
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade

â†’ La connexion passe maintenant de HTTP Ã  WebSocket
```

### 103 Early Hints

**Usage :** Permet au serveur d'envoyer des indices prÃ©liminaires pendant qu'il prÃ©pare la rÃ©ponse finale.

```http
HTTP/1.1 103 Early Hints
Link: </style.css>; rel=preload; as=style
Link: </script.js>; rel=preload; as=script

[Le serveur continue de prÃ©parer la rÃ©ponse...]

HTTP/1.1 200 OK
Content-Type: text/html
[HTML complet]
```

**Avantage :** Le navigateur peut commencer Ã  prÃ©charger les ressources avant de recevoir la page HTML complÃ¨te.

## 2xx - Codes de succÃ¨s

Les codes **2xx** indiquent que la requÃªte a Ã©tÃ© **reÃ§ue, comprise et acceptÃ©e avec succÃ¨s**.

### 200 OK

**Le code le plus courant.** Tout s'est bien passÃ©.

**Exemples :**

**1. RÃ©cupÃ©ration d'une page web**
```http
GET /index.html HTTP/1.1
Host: www.example.com

RÃ©ponse :
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<!DOCTYPE html>
<html>
...
</html>
```

**2. API REST - Lecture**
```http
GET /api/users/123 HTTP/1.1

RÃ©ponse :
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "name": "Alice Dupont"
}
```

**3. API REST - Mise Ã  jour**
```http
PUT /api/users/123 HTTP/1.1
Content-Type: application/json

{"name": "Alice Martin"}

RÃ©ponse :
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "name": "Alice Martin",
  "updated_at": "2025-12-06T10:30:00Z"
}
```

### 201 Created

**Ressource crÃ©Ã©e avec succÃ¨s.** UtilisÃ© principalement avec POST.

```http
POST /api/users HTTP/1.1
Content-Type: application/json

{
  "name": "Bob Martin",
  "email": "bob@example.com"
}

RÃ©ponse :
HTTP/1.1 201 Created
Location: /api/users/124
Content-Type: application/json

{
  "id": 124,
  "name": "Bob Martin",
  "email": "bob@example.com",
  "created_at": "2025-12-06T10:35:00Z"
}
```

**Points importants :**
- En-tÃªte `Location` : Indique l'URI de la ressource crÃ©Ã©e
- Le corps de la rÃ©ponse contient gÃ©nÃ©ralement la ressource crÃ©Ã©e avec son ID gÃ©nÃ©rÃ©

### 202 Accepted

**RequÃªte acceptÃ©e mais traitement non terminÃ©.** UtilisÃ© pour les opÃ©rations asynchrones.

```http
POST /api/reports/generate HTTP/1.1
Content-Type: application/json

{
  "type": "annual",
  "year": 2024
}

RÃ©ponse :
HTTP/1.1 202 Accepted
Content-Type: application/json

{
  "message": "Report generation started",
  "job_id": "job-789",
  "status_url": "/api/jobs/job-789"
}
```

**Cas d'usage typiques :**
- GÃ©nÃ©ration de rapports longs
- Traitement d'images/vidÃ©os
- Envoi d'emails en masse
- Calculs complexes

**Le client doit ensuite :**
```http
GET /api/jobs/job-789 HTTP/1.1

RÃ©ponse :
HTTP/1.1 200 OK
{
  "job_id": "job-789",
  "status": "completed",
  "result_url": "/api/reports/annual-2024.pdf"
}
```

### 204 No Content

**SuccÃ¨s mais pas de contenu Ã  retourner.** Souvent utilisÃ© avec DELETE.

```http
DELETE /api/users/123 HTTP/1.1

RÃ©ponse :
HTTP/1.1 204 No Content
```

**Pas de body dans la rÃ©ponse.** Le simple fait de recevoir 204 confirme la suppression.

**Autre usage : Mise Ã  jour sans contenu**
```http
PATCH /api/users/123/settings HTTP/1.1
Content-Type: application/json

{"notifications_enabled": false}

RÃ©ponse :
HTTP/1.1 204 No Content

â†’ Modification effectuÃ©e, pas besoin de retourner la ressource
```

### 206 Partial Content

**Contenu partiel retournÃ©.** UtilisÃ© pour les tÃ©lÃ©chargements en plusieurs parties (range requests).

```http
GET /video.mp4 HTTP/1.1
Range: bytes=0-1023

RÃ©ponse :
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/10485760
Content-Length: 1024

[1024 premiers octets du fichier]
```

**Cas d'usage :**
- Streaming vidÃ©o/audio
- TÃ©lÃ©chargement de gros fichiers avec reprise
- Lecture de parties spÃ©cifiques d'un fichier

**Exemple de reprise de tÃ©lÃ©chargement :**
```
1. TÃ©lÃ©chargement interrompu Ã  50%
2. Client redemande :
   GET /largefile.zip
   Range: bytes=52428800-

3. Serveur reprend Ã  50% :
   HTTP/1.1 206 Partial Content
   Content-Range: bytes 52428800-104857600/104857600
```

## 3xx - Codes de redirection

Les codes **3xx** indiquent que le client doit effectuer une **action supplÃ©mentaire** pour complÃ©ter la requÃªte, gÃ©nÃ©ralement une redirection vers une autre URL.

### 301 Moved Permanently

**Redirection permanente.** La ressource a Ã©tÃ© dÃ©placÃ©e dÃ©finitivement vers une nouvelle URL.

```http
GET /old-page.html HTTP/1.1
Host: www.example.com

RÃ©ponse :
HTTP/1.1 301 Moved Permanently
Location: https://www.example.com/new-page.html

Le navigateur redirige automatiquement vers la nouvelle URL
```

**Impact SEO :** Les moteurs de recherche mettent Ã  jour leurs index pour pointer vers la nouvelle URL.

**Cas d'usage :**
```
Migration HTTP â†’ HTTPS :
http://example.com â†’ https://example.com (301)

Changement de domaine :
http://old-domain.com â†’ http://new-domain.com (301)

Restructuration d'URL :
/blog/2024/12/article â†’ /articles/article (301)
```

**Le navigateur met en cache les redirections 301**, donc Ã  utiliser seulement si la redirection est vraiment permanente.

### 302 Found (Temporary Redirect)

**Redirection temporaire.** La ressource est temporairement Ã  une autre URL.

```http
GET /products/laptop HTTP/1.1

RÃ©ponse :
HTTP/1.1 302 Found
Location: /products/laptop-on-sale
```

**DiffÃ©rence avec 301 :**
- 301 : "Cette page a dÃ©mÃ©nagÃ© pour toujours"
- 302 : "Cette page est temporairement ailleurs"

**Cas d'usage :**
```
Maintenance :
/service â†’ /maintenance.html (302)

Promotion temporaire :
/product â†’ /product-special-offer (302)

Authentification :
/dashboard â†’ /login (302)
```

### 303 See Other

**Voir ailleurs avec GET.** UtilisÃ© aprÃ¨s un POST pour rediriger vers une page de rÃ©sultat.

```http
POST /create-account HTTP/1.1
Content-Type: application/json

{"username": "alice", "email": "alice@example.com"}

RÃ©ponse :
HTTP/1.1 303 See Other
Location: /account/welcome
```

**Pattern PRG (Post-Redirect-Get) :**
```
1. User submits form â†’ POST /submit
2. Server processes â†’ 303 See Other, Location: /success
3. Browser does GET /success
4. User sees success page

Avantage : F5 (refresh) ne resoumets pas le formulaire
```

### 304 Not Modified

**Ressource non modifiÃ©e.** UtilisÃ© avec le cache HTTP.

```http
GET /style.css HTTP/1.1
If-Modified-Since: Thu, 05 Dec 2025 10:00:00 GMT

RÃ©ponse :
HTTP/1.1 304 Not Modified

â†’ Le navigateur utilise sa version en cache
```

**Ã‰conomie de bande passante :**
```
Sans 304 :
- Client demande â†’ Serveur envoie 100 KB

Avec 304 :
- Client demande â†’ Serveur rÃ©pond "pas changÃ©"
- Client utilise le cache â†’ 0 KB transfÃ©rÃ©
```

**Avec ETag :**
```http
GET /data.json HTTP/1.1
If-None-Match: "33a64df551425fcc55e4d42a148795d9"

RÃ©ponse :
HTTP/1.1 304 Not Modified
ETag: "33a64df551425fcc55e4d42a148795d9"
```

### 307 Temporary Redirect

**Redirection temporaire stricte.** Comme 302, mais **la mÃ©thode HTTP ne doit pas changer**.

```http
POST /api/submit HTTP/1.1
Content-Type: application/json

{"data": "test"}

RÃ©ponse :
HTTP/1.1 307 Temporary Redirect
Location: /api/v2/submit

â†’ Le client doit refaire POST vers /api/v2/submit (pas GET)
```

**DiffÃ©rence 302 vs 307 :**
```
302 : Le client peut changer POST en GET lors de la redirection
307 : Le client DOIT garder POST
```

### 308 Permanent Redirect

**Redirection permanente stricte.** Comme 301, mais **la mÃ©thode HTTP ne doit pas changer**.

```http
POST /api/v1/users HTTP/1.1

RÃ©ponse :
HTTP/1.1 308 Permanent Redirect
Location: /api/v2/users

â†’ Le client doit utiliser /api/v2/users pour tous les futurs POST
```

## 4xx - Erreurs client

Les codes **4xx** indiquent que la requÃªte contient une **erreur cÃ´tÃ© client** : mauvaise syntaxe, ressource inexistante, autorisation manquante, etc.

### 400 Bad Request

**RequÃªte mal formÃ©e.** Le serveur ne peut pas comprendre la requÃªte.

```http
POST /api/users HTTP/1.1
Content-Type: application/json

{invalid json}

RÃ©ponse :
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "Invalid JSON syntax",
  "message": "Expected ',' or '}' at position 12"
}
```

**Cas d'usage courants :**
```
- JSON mal formÃ©
- ParamÃ¨tres manquants
- Valeurs invalides
- Format de donnÃ©es incorrect
```

**Exemple avec validation :**
```http
POST /api/users HTTP/1.1
Content-Type: application/json

{
  "name": "",
  "email": "invalid-email"
}

RÃ©ponse :
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "Validation failed",
  "details": {
    "name": "Name is required",
    "email": "Invalid email format"
  }
}
```

### 401 Unauthorized

**Authentification requise ou Ã©chouÃ©e.** Techniquement, ce code signifie "non authentifiÃ©" (pas "non autorisÃ©").

```http
GET /api/private/data HTTP/1.1

RÃ©ponse :
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="API"
Content-Type: application/json

{
  "error": "Authentication required",
  "message": "Please provide a valid access token"
}
```

**Avec token invalide :**
```http
GET /api/private/data HTTP/1.1
Authorization: Bearer invalid-token

RÃ©ponse :
HTTP/1.1 401 Unauthorized
Content-Type: application/json

{
  "error": "Invalid token",
  "message": "The provided token is expired or invalid"
}
```

**Flow typique :**
```
1. Client â†’ GET /protected-resource
2. Server â†’ 401 Unauthorized
3. Client â†’ POST /login (credentials)
4. Server â†’ 200 OK (avec token)
5. Client â†’ GET /protected-resource (avec token)
6. Server â†’ 200 OK (donnÃ©es)
```

### 403 Forbidden

**AccÃ¨s interdit.** Le serveur comprend la requÃªte mais refuse de l'autoriser.

```http
DELETE /api/admin/users/1 HTTP/1.1
Authorization: Bearer user-token

RÃ©ponse :
HTTP/1.1 403 Forbidden
Content-Type: application/json

{
  "error": "Insufficient permissions",
  "message": "You don't have permission to delete admin users"
}
```

**DiffÃ©rence 401 vs 403 :**
```
401 : "Qui es-tu ? Identifie-toi !"
      â†’ Solution : S'authentifier

403 : "Je sais qui tu es, mais tu n'as pas le droit"
      â†’ Solution : Demander les permissions nÃ©cessaires
```

**Exemples de 403 :**
```
- Utilisateur normal tente d'accÃ©der Ã  un endpoint admin
- Tentative de modifier une ressource d'un autre utilisateur
- Rate limiting dÃ©passÃ©
- AccÃ¨s gÃ©ographique bloquÃ©
- IP blacklistÃ©e
```

### 404 Not Found

**Le plus cÃ©lÃ¨bre !** La ressource demandÃ©e n'existe pas.

```http
GET /api/users/99999 HTTP/1.1

RÃ©ponse :
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "Not found",
  "message": "User with ID 99999 does not exist"
}
```

**Page web 404 :**
```http
GET /non-existent-page.html HTTP/1.1

RÃ©ponse :
HTTP/1.1 404 Not Found
Content-Type: text/html

<!DOCTYPE html>
<html>
<head><title>Page Not Found</title></head>
<body>
  <h1>404 - Page Not Found</h1>
  <p>The page you're looking for doesn't exist.</p>
</body>
</html>
```

**Bonnes pratiques pour 404 :**
- Message clair et utile
- Liens vers des pages existantes
- Barre de recherche
- Design cohÃ©rent avec le site

### 405 Method Not Allowed

**MÃ©thode HTTP non supportÃ©e** pour cette ressource.

```http
POST /api/users/123 HTTP/1.1

RÃ©ponse :
HTTP/1.1 405 Method Not Allowed
Allow: GET, PUT, PATCH, DELETE
Content-Type: application/json

{
  "error": "Method not allowed",
  "message": "POST is not supported for this endpoint",
  "allowed_methods": ["GET", "PUT", "PATCH", "DELETE"]
}
```

**L'en-tÃªte `Allow`** indique les mÃ©thodes supportÃ©es.

**Exemple :**
```
GET    /api/users/123  âœ… AutorisÃ©
PUT    /api/users/123  âœ… AutorisÃ©
POST   /api/users/123  âŒ 405 Method Not Allowed
DELETE /api/users/123  âœ… AutorisÃ©
```

### 406 Not Acceptable

**Format de rÃ©ponse non acceptable.** Le serveur ne peut pas produire une rÃ©ponse dans le format demandÃ©.

```http
GET /api/data HTTP/1.1
Accept: application/xml

RÃ©ponse :
HTTP/1.1 406 Not Acceptable
Content-Type: application/json

{
  "error": "Not acceptable",
  "message": "This endpoint only supports application/json",
  "supported_formats": ["application/json"]
}
```

**NÃ©gociation de contenu :**
```http
GET /api/data HTTP/1.1
Accept: application/json, application/xml

Serveur peut choisir :
HTTP/1.1 200 OK
Content-Type: application/json
```

### 408 Request Timeout

**Timeout de la requÃªte.** Le client n'a pas envoyÃ© la requÃªte complÃ¨te dans le dÃ©lai imparti.

```http
POST /api/upload HTTP/1.1
Content-Length: 104857600
[connexion lente, donnÃ©es arrivent trop lentement]

RÃ©ponse (aprÃ¨s timeout) :
HTTP/1.1 408 Request Timeout
Content-Type: text/plain

Request timeout - please retry your upload
```

### 409 Conflict

**Conflit avec l'Ã©tat actuel** de la ressource.

```http
PUT /api/users/123 HTTP/1.1
If-Match: "version-5"
Content-Type: application/json

{"name": "Alice Updated"}

RÃ©ponse :
HTTP/1.1 409 Conflict
ETag: "version-6"
Content-Type: application/json

{
  "error": "Conflict",
  "message": "The resource has been modified by another user",
  "current_version": "version-6"
}
```

**Autres exemples de 409 :**
```
CrÃ©ation d'un utilisateur avec email dÃ©jÃ  existant :
POST /api/users
{"email": "alice@example.com"}
â†’ 409 Conflict (email already exists)

Suppression avec dÃ©pendances :
DELETE /api/categories/5
â†’ 409 Conflict (category has associated products)

Modification concurrente :
Deux utilisateurs modifient la mÃªme ressource simultanÃ©ment
â†’ 409 Conflict (version mismatch)
```

### 410 Gone

**Ressource dÃ©finitivement supprimÃ©e.** Plus fort que 404.

```http
GET /api/v1/old-endpoint HTTP/1.1

RÃ©ponse :
HTTP/1.1 410 Gone
Content-Type: application/json

{
  "error": "Gone",
  "message": "This endpoint has been permanently removed",
  "alternative": "/api/v2/new-endpoint"
}
```

**DiffÃ©rence 404 vs 410 :**
```
404 : "Je ne trouve pas cette ressource"
      (elle n'a peut-Ãªtre jamais existÃ©)

410 : "Cette ressource existait mais a Ã©tÃ© supprimÃ©e dÃ©finitivement"
      (ne cherchez plus, elle ne reviendra pas)
```

### 413 Payload Too Large

**Corps de requÃªte trop volumineux.**

```http
POST /api/upload HTTP/1.1
Content-Length: 524288000
Content-Type: multipart/form-data

[500 MB de donnÃ©es...]

RÃ©ponse :
HTTP/1.1 413 Payload Too Large
Content-Type: application/json

{
  "error": "Payload too large",
  "message": "Maximum upload size is 100MB",
  "max_size": 104857600,
  "received_size": 524288000
}
```

### 414 URI Too Long

**URL trop longue.**

```http
GET /search?q=very+long+query+with+hundreds+of+parameters... HTTP/1.1

RÃ©ponse :
HTTP/1.1 414 URI Too Long

{
  "error": "URI too long",
  "message": "Please use POST for large queries"
}
```

**Solution :** Utiliser POST avec les paramÃ¨tres dans le body.

### 415 Unsupported Media Type

**Type de contenu non supportÃ©.**

```http
POST /api/users HTTP/1.1
Content-Type: text/plain

Some plain text data

RÃ©ponse :
HTTP/1.1 415 Unsupported Media Type
Content-Type: application/json

{
  "error": "Unsupported media type",
  "message": "This endpoint only accepts application/json",
  "supported_types": ["application/json"]
}
```

### 418 I'm a teapot

**Code humoristique** de la RFC 2324 (April Fools' joke, 1998).

```http
GET /brew-coffee HTTP/1.1

RÃ©ponse :
HTTP/1.1 418 I'm a teapot
Content-Type: text/plain

ğŸ«– I'm a teapot! I cannot brew coffee.
```

**Note :** Parfois implÃ©mentÃ© pour l'humour, mais pas un vrai code d'erreur.

### 429 Too Many Requests

**Rate limiting dÃ©passÃ©.** Trop de requÃªtes envoyÃ©es.

```http
GET /api/data HTTP/1.1

RÃ©ponse (aprÃ¨s 100 requÃªtes en 1 minute) :
HTTP/1.1 429 Too Many Requests
Retry-After: 60
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1701871200
Content-Type: application/json

{
  "error": "Rate limit exceeded",
  "message": "You have exceeded the rate limit of 100 requests per minute",
  "retry_after": 60
}
```

**Headers utiles :**
```
X-RateLimit-Limit: 100        â†’ Limite totale
X-RateLimit-Remaining: 0      â†’ RequÃªtes restantes
X-RateLimit-Reset: 1701871200 â†’ Timestamp de reset
Retry-After: 60               â†’ Secondes Ã  attendre
```

**Gestion cÃ´tÃ© client :**
```python
import time
import requests

response = requests.get('https://api.example.com/data')

if response.status_code == 429:
    retry_after = int(response.headers.get('Retry-After', 60))
    print(f"Rate limited. Waiting {retry_after} seconds...")
    time.sleep(retry_after)
    response = requests.get('https://api.example.com/data')
```

## 5xx - Erreurs serveur

Les codes **5xx** indiquent que le **serveur a rencontrÃ© une erreur** ou est incapable de traiter la requÃªte, mÃªme si celle-ci est valide.

### 500 Internal Server Error

**Erreur gÃ©nÃ©rique du serveur.** Quelque chose s'est mal passÃ© cÃ´tÃ© serveur.

```http
GET /api/users HTTP/1.1

RÃ©ponse :
HTTP/1.1 500 Internal Server Error
Content-Type: application/json

{
  "error": "Internal server error",
  "message": "An unexpected error occurred",
  "request_id": "req-abc123"
}
```

**Causes typiques :**
```
- Exception non gÃ©rÃ©e dans le code
- Erreur de base de donnÃ©es
- Bug dans le code serveur
- ProblÃ¨me de configuration
- Ressource manquante (fichier de config, etc.)
```

**Bonnes pratiques :**
```python
# CÃ´tÃ© serveur - Log dÃ©taillÃ©
try:
    result = process_request()
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    return {
        "error": "Internal server error",
        "request_id": request_id  # Pour le support
    }, 500

# Ne PAS exposer les dÃ©tails techniques au client !
# Mauvais :
{
  "error": "DatabaseError: Connection to 'db.internal' failed"
}
```

### 501 Not Implemented

**FonctionnalitÃ© non implÃ©mentÃ©e.** Le serveur ne supporte pas la fonctionnalitÃ© requise.

```http
GET /api/v2/advanced-feature HTTP/1.1

RÃ©ponse :
HTTP/1.1 501 Not Implemented
Content-Type: application/json

{
  "error": "Not implemented",
  "message": "This feature is not yet implemented",
  "planned_release": "Q2 2026"
}
```

### 502 Bad Gateway

**Passerelle dÃ©faillante.** Le serveur, agissant comme une passerelle ou proxy, a reÃ§u une rÃ©ponse invalide du serveur en amont.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client â”‚â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ Nginx   â”‚â”€â”€â”€â”€Xâ”€â”€â”€>â”‚ Backend  â”‚
â”‚        â”‚         â”‚ (Proxy) â”‚         â”‚ (Crashed)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â”‚
                   502 Bad Gateway
```

```http
GET /api/data HTTP/1.1

RÃ©ponse :
HTTP/1.1 502 Bad Gateway
Content-Type: text/html

<html>
<body>
  <h1>502 Bad Gateway</h1>
  <p>The server received an invalid response from the upstream server.</p>
</body>
</html>
```

**Causes courantes :**
- Backend server down
- Timeout backend
- Erreur de configuration du proxy
- ProblÃ¨me rÃ©seau entre proxy et backend

### 503 Service Unavailable

**Service temporairement indisponible.** Souvent dÃ» Ã  une surcharge ou une maintenance.

```http
GET /api/data HTTP/1.1

RÃ©ponse :
HTTP/1.1 503 Service Unavailable
Retry-After: 3600
Content-Type: application/json

{
  "error": "Service unavailable",
  "message": "The service is temporarily unavailable due to maintenance",
  "retry_after": 3600,
  "maintenance_window": "2025-12-06 02:00-04:00 UTC"
}
```

**Usage typique :**
```
Page de maintenance :
HTTP/1.1 503 Service Unavailable
Retry-After: 3600

Surcharge serveur :
HTTP/1.1 503 Service Unavailable
Retry-After: 60

DÃ©ploiement en cours :
HTTP/1.1 503 Service Unavailable
Retry-After: 300
```

**Pattern de circuit breaker :**
```
Si backend fail > 50% :
  â†’ Retourner 503 immÃ©diatement
  â†’ Ã‰vite de surcharger un backend dÃ©jÃ  en difficultÃ©
  â†’ RÃ©essayer pÃ©riodiquement
```

### 504 Gateway Timeout

**Timeout de la passerelle.** Le proxy n'a pas reÃ§u de rÃ©ponse Ã  temps du serveur en amont.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client â”‚â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ Nginx   â”‚â”€â”€â”€â”€â”€â”€â”€?>â”‚ Backend  â”‚
â”‚        â”‚         â”‚ (Proxy) â”‚  â±ï¸     â”‚ (Slow)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â”‚
                   504 Gateway Timeout
```

```http
GET /api/heavy-computation HTTP/1.1

RÃ©ponse (aprÃ¨s 30s de timeout) :
HTTP/1.1 504 Gateway Timeout
Content-Type: application/json

{
  "error": "Gateway timeout",
  "message": "The server did not respond in time"
}
```

**DiffÃ©rence 502 vs 504 :**
```
502 : Le backend a rÃ©pondu, mais la rÃ©ponse est invalide
504 : Le backend n'a pas rÃ©pondu du tout (timeout)
```

## Codes de statut moins courants mais utiles

### 422 Unprocessable Entity

**EntitÃ© non traitable.** La requÃªte est bien formÃ©e mais contient des erreurs sÃ©mantiques.

```http
POST /api/users HTTP/1.1
Content-Type: application/json

{
  "email": "alice@example.com",
  "age": -5
}

RÃ©ponse :
HTTP/1.1 422 Unprocessable Entity
Content-Type: application/json

{
  "error": "Validation error",
  "details": {
    "age": "Age must be a positive number"
  }
}
```

**DiffÃ©rence 400 vs 422 :**
```
400 : JSON mal formÃ©, syntaxe invalide
422 : JSON valide, mais donnÃ©es invalides sÃ©mantiquement
```

### 451 Unavailable For Legal Reasons

**Indisponible pour des raisons lÃ©gales.** Contenu censurÃ© ou bloquÃ©.

```http
GET /article/sensitive-topic HTTP/1.1

RÃ©ponse :
HTTP/1.1 451 Unavailable For Legal Reasons
Content-Type: text/html

<html>
<body>
  <h1>Content Unavailable</h>1>
  <p>This content is not available in your region due to legal restrictions.</p>
</body>
</html>
```

**RÃ©fÃ©rence :** Code inspirÃ© du livre "Fahrenheit 451" de Ray Bradbury.

### 511 Network Authentication Required

**Authentification rÃ©seau requise.** UtilisÃ© par les captive portals (Wi-Fi publics).

```http
GET /any-url HTTP/1.1

RÃ©ponse :
HTTP/1.1 511 Network Authentication Required
Content-Type: text/html

<html>
<body>
  <h1>Wi-Fi Login Required</h1>
  <p>Please log in to access the internet.</p>
  <form action="/wifi-login" method="post">
    ...
  </form>
</body>
</html>
```

## Utilisation pratique des codes de statut

### Dans les APIs REST

**Mapping CRUD â†’ Status Codes**

```
CREATE (POST /users)
âœ… SuccÃ¨s : 201 Created
âŒ DonnÃ©es invalides : 400 Bad Request / 422 Unprocessable Entity
âŒ Conflit (email existe) : 409 Conflict

READ (GET /users/123)
âœ… SuccÃ¨s : 200 OK
âŒ Non trouvÃ© : 404 Not Found
âŒ Non authentifiÃ© : 401 Unauthorized
âŒ Non autorisÃ© : 403 Forbidden

UPDATE (PUT /users/123)
âœ… SuccÃ¨s : 200 OK / 204 No Content
âŒ Non trouvÃ© : 404 Not Found
âŒ DonnÃ©es invalides : 400 Bad Request
âŒ Conflit version : 409 Conflict

DELETE (DELETE /users/123)
âœ… SuccÃ¨s : 204 No Content
âŒ Non trouvÃ© : 404 Not Found
âŒ DÃ©pendances : 409 Conflict
```

### Gestion des erreurs cÃ´tÃ© client

**JavaScript (fetch)**
```javascript
async function fetchUser(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);

    switch (response.status) {
      case 200:
        return await response.json();

      case 404:
        throw new Error('User not found');

      case 401:
        // Rediriger vers login
        window.location.href = '/login';
        break;

      case 403:
        throw new Error('Access forbidden');

      case 429:
        const retryAfter = response.headers.get('Retry-After');
        throw new Error(`Rate limited. Retry after ${retryAfter}s`);

      case 500:
      case 502:
      case 503:
        throw new Error('Server error. Please try again later');

      default:
        throw new Error(`Unexpected status: ${response.status}`);
    }
  } catch (error) {
    console.error('Error fetching user:', error);
    throw error;
  }
}
```

**Python (requests)**
```python
import requests
from requests.exceptions import HTTPError

def get_user(user_id):
    try:
        response = requests.get(f'https://api.example.com/users/{user_id}')
        response.raise_for_status()  # LÃ¨ve une exception pour 4xx/5xx
        return response.json()

    except HTTPError as e:
        if e.response.status_code == 404:
            print("User not found")
        elif e.response.status_code == 401:
            print("Authentication required")
        elif e.response.status_code == 429:
            retry_after = e.response.headers.get('Retry-After', 60)
            print(f"Rate limited. Wait {retry_after}s")
        elif 500 <= e.response.status_code < 600:
            print("Server error")
        else:
            print(f"HTTP error: {e.response.status_code}")
        raise
```

### Retry logic basÃ©e sur les codes

```python
import time
from requests.exceptions import HTTPError

def fetch_with_retry(url, max_retries=3):
    for attempt in range(max_retries):
        try:
            response = requests.get(url)

            # SuccÃ¨s
            if response.status_code == 200:
                return response.json()

            # Erreurs non retryables
            if response.status_code in [400, 401, 403, 404]:
                response.raise_for_status()

            # Rate limiting
            if response.status_code == 429:
                retry_after = int(response.headers.get('Retry-After', 60))
                print(f"Rate limited. Waiting {retry_after}s...")
                time.sleep(retry_after)
                continue

            # Erreurs serveur (5xx) - retry avec backoff
            if 500 <= response.status_code < 600:
                wait_time = 2 ** attempt  # Exponential backoff
                print(f"Server error. Retrying in {wait_time}s...")
                time.sleep(wait_time)
                continue

            # Autre erreur
            response.raise_for_status()

        except Exception as e:
            if attempt == max_retries - 1:
                raise
            print(f"Attempt {attempt + 1} failed: {e}")

    raise Exception(f"Failed after {max_retries} attempts")
```

## Bonnes pratiques

### 1. Utilisez les codes appropriÃ©s

```python
# âœ… Bon
@app.route('/users/<int:user_id>')
def get_user(user_id):
    user = User.query.get(user_id)
    if not user:
        return {'error': 'User not found'}, 404
    return user.to_dict(), 200

# âŒ Mauvais - Toujours 200 mÃªme en cas d'erreur
@app.route('/users/<int:user_id>')
def get_user(user_id):
    user = User.query.get(user_id)
    if not user:
        return {'error': 'User not found'}, 200  # âŒ Devrait Ãªtre 404
    return user.to_dict(), 200
```

### 2. Fournissez des messages d'erreur clairs

```json
âœ… Bon :
{
  "error": "Validation failed",
  "message": "The email address is already in use",
  "details": {
    "field": "email",
    "value": "alice@example.com",
    "constraint": "unique"
  },
  "request_id": "req-abc123"
}

âŒ Mauvais :
{
  "error": "Error"
}
```

### 3. Soyez cohÃ©rent

```
Choisissez une structure d'erreur et utilisez-la partout :

{
  "error": "Type d'erreur",
  "message": "Description pour l'utilisateur",
  "details": {},
  "request_id": "Pour le debugging"
}
```

### 4. N'exposez pas les dÃ©tails techniques

```json
âŒ Ã€ Ã©viter en production :
{
  "error": "DatabaseError: connection refused to postgresql://admin:password123@db.internal:5432/prod"
}

âœ… PrÃ©fÃ©rez :
{
  "error": "Service temporarily unavailable",
  "request_id": "req-abc123"
}
```

### 5. Utilisez les headers appropriÃ©s

```http
# Pour les redirections
Location: /new-url

# Pour le cache
Cache-Control: max-age=3600
ETag: "abc123"

# Pour le rate limiting
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 42
X-RateLimit-Reset: 1701871200
Retry-After: 60

# Pour CORS
Access-Control-Allow-Origin: https://app.example.com
```

### 6. Documentez vos codes de statut

```yaml
# OpenAPI/Swagger
paths:
  /users/{id}:
    get:
      responses:
        '200':
          description: User found
        '404':
          description: User not found
        '401':
          description: Authentication required
        '403':
          description: Insufficient permissions
        '500':
          description: Internal server error
```

## TestabilitÃ© et codes de statut

```python
# Tests unitaires
def test_get_user_success():
    response = client.get('/api/users/123')
    assert response.status_code == 200
    assert 'name' in response.json()

def test_get_user_not_found():
    response = client.get('/api/users/99999')
    assert response.status_code == 404
    assert 'error' in response.json()

def test_create_user_validation_error():
    response = client.post('/api/users', json={
        'email': 'invalid-email'
    })
    assert response.status_code == 400
    assert 'validation' in response.json()['error'].lower()

def test_rate_limiting():
    # Faire 101 requÃªtes
    for i in range(101):
        response = client.get('/api/data')
        if i < 100:
            assert response.status_code == 200
        else:
            assert response.status_code == 429
```

## Outils de debugging

### Chrome DevTools

```
1. Ouvrir DevTools (F12)
2. Onglet "Network"
3. Actualiser la page
4. Cliquer sur une requÃªte
5. Voir : Status, Headers, Response, Timing
```

### curl avec verbose

```bash
curl -v https://api.example.com/users/123

# Output :
> GET /users/123 HTTP/1.1
> Host: api.example.com
< HTTP/1.1 200 OK
< Content-Type: application/json
< Content-Length: 125

{"id":123,"name":"Alice"}
```

### httpie (alternative Ã  curl)

```bash
http GET https://api.example.com/users/123

HTTP/1.1 200 OK
Content-Type: application/json

{
    "id": 123,
    "name": "Alice"
}
```

---

## Points clÃ©s Ã  retenir

ğŸ”‘ **1xx** : Informationnels - Traitement en cours

ğŸ”‘ **2xx** : SuccÃ¨s - Tout s'est bien passÃ©
- 200 OK, 201 Created, 204 No Content

ğŸ”‘ **3xx** : Redirection - Action supplÃ©mentaire nÃ©cessaire
- 301 Permanent, 302 Temporary, 304 Not Modified

ğŸ”‘ **4xx** : Erreur client - ProblÃ¨me dans la requÃªte
- 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 429 Too Many Requests

ğŸ”‘ **5xx** : Erreur serveur - ProblÃ¨me cÃ´tÃ© serveur
- 500 Internal Error, 502 Bad Gateway, 503 Service Unavailable

ğŸ”‘ **Utilisez les codes appropriÃ©s** : Ils permettent aux clients de rÃ©agir correctement

ğŸ”‘ **Fournissez des messages clairs** : Aidez les dÃ©veloppeurs Ã  comprendre l'erreur

ğŸ”‘ **Soyez cohÃ©rent** : Utilisez la mÃªme structure d'erreur partout

ğŸ”‘ **Ne divulguez pas les dÃ©tails techniques** : SÃ©curitÃ© avant tout

---

## Ce que nous allons voir ensuite

Dans la prochaine section **5.4.3 Headers et cookies**, nous explorerons :
- Les en-tÃªtes HTTP essentiels
- La gestion des cookies
- Les mÃ©canismes de cache
- Les headers de sÃ©curitÃ©
- La nÃ©gociation de contenu

**Les codes de statut et les headers HTTP forment ensemble le langage complet de communication HTTP !** ğŸ‘‰

---

*Les codes de statut HTTP sont le vocabulaire standardisÃ© qui permet aux serveurs de communiquer clairement avec les clients. MaÃ®triser leur signification et leur usage appropriÃ© est essentiel pour dÃ©velopper des applications web robustes et pour diagnostiquer efficacement les problÃ¨mes rÃ©seau.*

â­ï¸ [Headers et cookies](/05-couche-application/04.3-http-headers-cookies.md)
