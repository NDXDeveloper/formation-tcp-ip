ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 5.4.4 HTTP/1.1 : Connexions persistantes et pipelining

## Introduction

HTTP/1.1, publiÃ© en 1997 et standardisÃ© dans la RFC 2616 (puis rÃ©visÃ© dans la RFC 7230-7235 en 2014), a reprÃ©sentÃ© une **Ã©volution majeure** par rapport Ã  HTTP/1.0. Cette version a introduit des optimisations cruciales qui ont permis au Web de passer Ã  l'Ã©chelle et de supporter des applications plus complexes.

**Les innovations principales d'HTTP/1.1 :**
- âœ… Connexions persistantes (keep-alive) par dÃ©faut
- âœ… Pipelining de requÃªtes
- âœ… Chunked transfer encoding
- âœ… Header Host obligatoire (hÃ©bergement virtuel)
- âœ… Meilleure gestion du cache
- âœ… Support des byte ranges
- âœ… Nouvelles mÃ©thodes (PUT, DELETE, etc.)

HTTP/1.1 est restÃ© le standard dominant pendant **prÃ¨s de 20 ans** (1997-2015), jusqu'Ã  l'arrivÃ©e d'HTTP/2. MÃªme aujourd'hui, en 2025, HTTP/1.1 est encore largement utilisÃ©.

## Le problÃ¨me d'HTTP/1.0

### Connexions non persistantes

Dans HTTP/1.0, **chaque requÃªte nÃ©cessitait une nouvelle connexion TCP** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚                            â”‚ Serveur â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ TCP SYN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚<â”€â”€â”€ TCP SYN-ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚â”€â”€â”€â”€ TCP ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ GET /index.html â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚<â”€â”€â”€ 200 OK [HTML] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ TCP FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚<â”€â”€â”€ TCP FIN-ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ TCP SYN (nouvelle connexion) â”€â”€â”€>â”‚
     â”‚<â”€â”€â”€ TCP SYN-ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚â”€â”€â”€â”€ TCP ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ GET /style.css â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚<â”€â”€â”€ 200 OK [CSS] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ TCP FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ TCP SYN (encore une nouvelle!) â”€>â”‚
     â”‚<â”€â”€â”€ TCP SYN-ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚â”€â”€â”€â”€ TCP ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ GET /logo.png â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚<â”€â”€â”€ 200 OK [Image] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ TCP FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
```

### Impact sur les performances

**ProblÃ¨mes majeurs :**

1. **Latence importante** : Chaque connexion TCP nÃ©cessite un 3-way handshake
   ```
   RTT (Round-Trip Time) typique : 50-100ms

   Page avec 10 ressources en HTTP/1.0 :
   - 10 handshakes TCP = 10 Ã— 50ms = 500ms juste pour les handshakes !
   - Sans compter le transfert des donnÃ©es
   ```

2. **Overhead du handshake** : CoÃ»t en temps et ressources
   ```
   Pour chaque ressource :
   - 3 paquets pour le handshake (SYN, SYN-ACK, ACK)
   - 4 paquets pour la fermeture (FIN, ACK, FIN, ACK)
   - Total : 7 paquets supplÃ©mentaires par ressource
   ```

3. **Congestion TCP slow start** : Chaque nouvelle connexion recommence Ã  zÃ©ro
   ```
   TCP commence lentement puis accÃ©lÃ¨re
   Avec de nouvelles connexions constantes, on ne profite jamais de la vitesse max
   ```

**Exemple concret :**

```
Page web typique (annÃ©e 2000) :
- 1 HTML
- 3 CSS
- 5 JavaScript
- 20 images
= 29 ressources

HTTP/1.0 :
29 connexions TCP Ã— (50ms handshake + 50ms transfert) = 2900ms
â†’ PrÃ¨s de 3 secondes juste pour Ã©tablir les connexions !

Avec latence rÃ©seau de 100ms : 5800ms (presque 6 secondes)
```

### Tentative de solution : Connection: keep-alive

HTTP/1.0 a introduit un mÃ©canisme **optionnel** :

```http
Client â†’
GET /index.html HTTP/1.0
Connection: keep-alive

Serveur â†’
HTTP/1.0 200 OK
Connection: keep-alive

[La connexion reste ouverte pour la prochaine requÃªte]

Client â†’ (mÃªme connexion TCP)
GET /style.css HTTP/1.0
Connection: keep-alive
```

**ProblÃ¨mes :**
- Optionnel, pas activÃ© par dÃ©faut
- Support incohÃ©rent entre navigateurs et serveurs
- NÃ©cessitait nÃ©gociation explicite

## HTTP/1.1 : Connexions persistantes par dÃ©faut

### Le changement fondamental

HTTP/1.1 a rendu les **connexions persistantes obligatoires par dÃ©faut** :

```http
Client â†’
GET /index.html HTTP/1.1
Host: www.example.com

Serveur â†’
HTTP/1.1 200 OK
[HTML content]

[La connexion reste AUTOMATIQUEMENT ouverte]

Client â†’ (mÃªme connexion TCP)
GET /style.css HTTP/1.1
Host: www.example.com

Serveur â†’
HTTP/1.1 200 OK
[CSS content]

[Connexion toujours ouverte]

Client â†’ (toujours la mÃªme connexion)
GET /logo.png HTTP/1.1
Host: www.example.com
```

### SchÃ©ma comparatif

```
HTTP/1.0 (connexions sÃ©parÃ©es)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Connexion 1 : GET /index.html â”€â”€â”€â”
                                 â”œâ”€ 3 handshakes TCP
Connexion 2 : GET /style.css â”€â”€â”€â”€â”¤   = 3 Ã— RTT overhead
                                 â”‚
Connexion 3 : GET /logo.png â”€â”€â”€â”€â”€â”˜


HTTP/1.1 (connexion persistante)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Connexion 1 : â”Œâ”€ GET /index.html
              â”œâ”€ GET /style.css
              â””â”€ GET /logo.png

1 seul handshake TCP = 1 Ã— RTT
Ã‰conomie : 2 RTT dans cet exemple
```

### BÃ©nÃ©fices mesurables

**Gains de performance :**

```
Page avec 30 ressources, RTT = 50ms

HTTP/1.0 :
30 connexions Ã— 50ms = 1500ms de latence

HTTP/1.1 :
1 connexion Ã— 50ms = 50ms de latence

Gain : 1450ms (96% d'amÃ©lioration)
```

**Ã‰conomie de ressources :**
```
CÃ´tÃ© serveur :
- Moins de sockets ouverts
- Moins de handshakes Ã  traiter
- RÃ©duction de l'usage CPU et mÃ©moire

CÃ´tÃ© client :
- Moins de ports locaux utilisÃ©s
- Moins de contexte TCP Ã  maintenir
```

### ContrÃ´le des connexions persistantes

**Garder la connexion ouverte (dÃ©faut) :**
```http
HTTP/1.1 200 OK
Connection: keep-alive
Keep-Alive: timeout=5, max=100

Signification :
- timeout=5  : Fermer aprÃ¨s 5 secondes d'inactivitÃ©
- max=100    : Maximum 100 requÃªtes sur cette connexion
```

**Fermer la connexion :**
```http
HTTP/1.1 200 OK
Connection: close

â†’ Le serveur fermera la connexion aprÃ¨s cette rÃ©ponse
```

**Exemple d'utilisation de close :**
```http
Client â†’ (10Ã¨me requÃªte sur la mÃªme connexion)
GET /final-resource HTTP/1.1
Host: www.example.com
Connection: close

Serveur â†’
HTTP/1.1 200 OK
Connection: close
[contenu]

[Connexion fermÃ©e]
```

### Gestion du timeout

**ScÃ©nario typique :**

```python
# Configuration serveur (exemple Nginx)
keepalive_timeout 65;        # 65 secondes d'inactivitÃ©
keepalive_requests 100;      # Max 100 requÃªtes par connexion

Timeline :
T=0s   : Connexion Ã©tablie
T=1s   : GET /page1
T=2s   : GET /page2
T=3s   : GET /page3
...
T=10s  : DerniÃ¨re requÃªte
T=11s  : InactivitÃ©...
T=20s  : InactivitÃ©...
T=40s  : InactivitÃ©...
T=65s  : InactivitÃ©...
T=75s  : Timeout ! Connexion fermÃ©e par le serveur
```

**Valeurs typiques :**
```
Apache : keepalive_timeout 5s
Nginx  : keepalive_timeout 65s
Node.js: keepAliveTimeout 5000ms (5s)
```

## Pipelining HTTP

### Concept

Le **pipelining** permet d'envoyer **plusieurs requÃªtes sans attendre les rÃ©ponses**, sur la mÃªme connexion.

### Sans pipelining (HTTP/1.1 classique)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚                            â”‚ Serveur â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ GET /file1.css â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                  [attente...] â±ï¸     â”‚
     â”‚<â”€â”€â”€ 200 OK [file1.css] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ GET /file2.js â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                  [attente...] â±ï¸     â”‚
     â”‚<â”€â”€â”€ 200 OK [file2.js] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ GET /file3.png â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                  [attente...] â±ï¸     â”‚
     â”‚<â”€â”€â”€ 200 OK [file3.png] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚

Total : 3 RTT (1 RTT par requÃªte/rÃ©ponse)
```

### Avec pipelining

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚                            â”‚ Serveur â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                                      â”‚
     â”‚â”€â”€â”€â”€ GET /file1.css â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚â”€â”€â”€â”€ GET /file2.js â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚â”€â”€â”€â”€ GET /file3.png â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                      â”‚
     â”‚<â”€â”€â”€ 200 OK [file1.css] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚<â”€â”€â”€ 200 OK [file2.js] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     â”‚<â”€â”€â”€ 200 OK [file3.png] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚

Total : ~1 RTT (toutes les requÃªtes envoyÃ©es d'un coup)

Gain : 2 RTT Ã©conomisÃ©s
```

### Exemple de pipelining

**RequÃªtes envoyÃ©es sans attendre :**
```http
GET /style1.css HTTP/1.1
Host: www.example.com

GET /style2.css HTTP/1.1
Host: www.example.com

GET /script.js HTTP/1.1
Host: www.example.com

GET /logo.png HTTP/1.1
Host: www.example.com
```

**RÃ©ponses reÃ§ues dans l'ordre :**
```http
HTTP/1.1 200 OK
Content-Type: text/css
Content-Length: 1234
[contenu de style1.css]

HTTP/1.1 200 OK
Content-Type: text/css
Content-Length: 5678
[contenu de style2.css]

HTTP/1.1 200 OK
Content-Type: application/javascript
Content-Length: 9012
[contenu de script.js]

HTTP/1.1 200 OK
Content-Type: image/png
Content-Length: 34567
[contenu de logo.png]
```

### RÃ¨gles du pipelining

**Contraintes importantes :**

1. **Les rÃ©ponses doivent arriver dans l'ordre** (FIFO)
   ```
   RequÃªtes : A, B, C
   RÃ©ponses : A, B, C (dans cet ordre obligatoirement)
   ```

2. **Uniquement pour les mÃ©thodes idempotentes** (GET, HEAD)
   ```
   âœ… Pipeline GET requests
   âŒ Ne PAS pipeline POST (non-idempotent)
   ```

3. **Le serveur doit supporter le pipelining**
   ```
   Pas tous les serveurs supportent correctement
   ```

### Le problÃ¨me du Head-of-Line Blocking

**Le talon d'Achille du pipelining :**

```
RequÃªtes pipelined :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ File A â”‚  â”‚ File B â”‚  â”‚ File C â”‚
â”‚ (gros) â”‚  â”‚(petit) â”‚  â”‚(petit) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“           â†“           â†“
EnvoyÃ©es simultanÃ©ment

RÃ©ponses (doivent arriver dans l'ordre) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ File A (gros)             â”‚ â† Bloque tout !
â”‚ [........................]â”‚
â”‚ [........................]â”‚ â±ï¸ B et C attendent
â”‚ [........................]â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ File B â”‚  â”‚ File C â”‚
    â”‚(petit) â”‚  â”‚(petit) â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ProblÃ¨me : B et C sont prÃªts mais doivent attendre A
```

**Impact concret :**
```
ScÃ©nario :
- File A : 5 MB (5 secondes de transfert)
- File B : 5 KB (0.01 seconde)
- File C : 10 KB (0.02 seconde)

Sans pipelining :
A : 5s, B : 0.01s, C : 0.02s
Total : 5.03s

Avec pipelining (head-of-line blocking) :
Tous attendent A â†’ Total : 5s
B et C n'arrivent qu'aprÃ¨s A

Gain : Minimal car A bloque tout
```

### Pourquoi le pipelining a Ã©chouÃ©

**En thÃ©orie :** Excellente idÃ©e, gains significatifs

**En pratique :** Rarement utilisÃ©

**Raisons :**

1. **Support incohÃ©rent**
   ```
   Certains proxies ne supportent pas le pipelining
   Certains serveurs ont des bugs
   RÃ©sultat : DÃ©sactivÃ© par dÃ©faut dans les navigateurs
   ```

2. **Head-of-line blocking**
   ```
   Une seule grosse ressource bloque toutes les suivantes
   Performance imprÃ©visible
   ```

3. **ComplexitÃ© de l'implÃ©mentation**
   ```
   NÃ©cessite gestion d'Ã©tat complexe
   Difficile de dÃ©tecter et rÃ©cupÃ©rer des erreurs
   ```

4. **Alternatives plus efficaces**
   ```
   Les navigateurs ont prÃ©fÃ©rÃ© ouvrir plusieurs connexions
   (gÃ©nÃ©ralement 6 connexions parallÃ¨les par domaine)
   ```

**Statistiques d'utilisation :**
```
Chrome : Pipelining dÃ©sactivÃ© par dÃ©faut
Firefox : DÃ©sactivÃ© par dÃ©faut depuis 2013
Safari : Jamais vraiment supportÃ©
Edge : DÃ©sactivÃ©

Conclusion : Le pipelining HTTP/1.1 est essentiellement mort
```

## Chunked Transfer Encoding

### Le problÃ¨me Ã  rÃ©soudre

**ScÃ©nario :** Le serveur gÃ©nÃ¨re une rÃ©ponse dynamique et ne connaÃ®t pas la taille Ã  l'avance.

```python
# Exemple : GÃ©nÃ©ration de rapport
@app.route('/report')
def generate_report():
    # On ne sait pas combien de donnÃ©es seront gÃ©nÃ©rÃ©es
    # Ã‡a peut prendre du temps

    # Sans chunked : Il faut TOUT gÃ©nÃ©rer d'abord
    data = []
    for item in large_dataset:  # 10 millions d'items
        data.append(process(item))

    full_report = ''.join(data)

    # ProblÃ¨mes :
    # - Utilisateur attend tout avant de voir quoi que ce soit
    # - Grosse utilisation mÃ©moire
    # - Pas de Content-Length avant d'avoir tout

    return full_report
```

### La solution : Chunked Encoding

Permet d'envoyer la rÃ©ponse **par morceaux (chunks)** au fur et Ã  mesure.

**Header spÃ©cial :**
```http
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Content-Type: text/html
```

**Format des chunks :**
```
[Taille du chunk en hexadÃ©cimal]\r\n
[DonnÃ©es du chunk]\r\n
[Taille du chunk suivant]\r\n
[DonnÃ©es]\r\n
...
0\r\n
\r\n
```

### Exemple concret

**RÃ©ponse chunked :**
```http
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Content-Type: text/plain

5\r\n
Hello\r\n
7\r\n
 World!\r\n
0\r\n
\r\n
```

**DÃ©codage :**
```
Chunk 1 : Taille = 5 (hex) = 5 bytes â†’ "Hello"
Chunk 2 : Taille = 7 (hex) = 7 bytes â†’ " World!"
Chunk 3 : Taille = 0 â†’ Fin de transmission

RÃ©sultat final : "Hello World!"
```

### Exemple avec donnÃ©es rÃ©elles

```http
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Content-Type: application/json

1a\r\n
{"items":[{"id":1,"name":"Alice"}\r\n
1c\r\n
,{"id":2,"name":"Bob"}\r\n
1e\r\n
,{"id":3,"name":"Charlie"}]}\r\n
0\r\n
\r\n
```

**DÃ©codage :**
```
1a (hex) = 26 bytes
1c (hex) = 28 bytes
1e (hex) = 30 bytes
0 = fin

Total : {"items":[{"id":1,"name":"Alice"},{"id":2,"name":"Bob"},{"id":3,"name":"Charlie"}]}
```

### ImplÃ©mentation serveur

**Python (Flask) :**
```python
from flask import Flask, Response
import time

app = Flask(__name__)

def generate_chunks():
    """GÃ©nÃ¨re des donnÃ©es par morceaux"""
    for i in range(10):
        time.sleep(0.5)  # Simule un traitement
        yield f"Chunk {i}\n"

@app.route('/chunked')
def chunked_response():
    return Response(
        generate_chunks(),
        mimetype='text/plain',
        # Flask gÃ¨re automatiquement Transfer-Encoding: chunked
    )
```

**Node.js (Express) :**
```javascript
app.get('/chunked', (req, res) => {
  res.setHeader('Content-Type', 'text/plain');
  // Pas de Content-Length â†’ automatiquement chunked

  let count = 0;
  const interval = setInterval(() => {
    res.write(`Chunk ${count}\n`);
    count++;

    if (count === 10) {
      clearInterval(interval);
      res.end();  // Envoie le chunk de taille 0
    }
  }, 500);
});
```

### Cas d'usage du chunked encoding

**1. Streaming de donnÃ©es**
```python
@app.route('/stream-logs')
def stream_logs():
    def generate():
        with open('/var/log/app.log') as f:
            for line in f:
                yield line

    return Response(generate(), mimetype='text/plain')
```

**2. Server-Sent Events (SSE)**
```python
@app.route('/events')
def events():
    def generate():
        while True:
            # Envoie un Ã©vÃ©nement toutes les secondes
            yield f"data: {get_current_data()}\n\n"
            time.sleep(1)

    return Response(generate(), mimetype='text/event-stream')
```

**3. GÃ©nÃ©ration dynamique de gros fichiers**
```python
@app.route('/export')
def export_data():
    def generate():
        yield "Name,Email,Date\n"  # En-tÃªte CSV

        for user in User.query.all():  # Millions d'utilisateurs
            yield f"{user.name},{user.email},{user.created}\n"

    return Response(
        generate(),
        mimetype='text/csv',
        headers={'Content-Disposition': 'attachment; filename=users.csv'}
    )
```

**Avantages :**
```
âœ… Pas besoin de connaÃ®tre la taille totale Ã  l'avance
âœ… L'utilisateur voit les donnÃ©es arriver progressivement
âœ… Ã‰conomie de mÃ©moire (pas besoin de tout stocker)
âœ… RÃ©duction du Time-To-First-Byte (TTFB)
```

## Le header Host : HÃ©bergement virtuel

### Pourquoi Host est obligatoire en HTTP/1.1

**ProblÃ¨me en HTTP/1.0 :**
```
Serveur avec IP 192.0.2.1 hÃ©berge :
- www.site1.com
- www.site2.com
- www.site3.com

RequÃªte HTTP/1.0 :
GET /index.html HTTP/1.0

Question : Quel site servir ? ğŸ¤·
Le serveur ne peut pas savoir !
```

**Solution HTTP/1.1 : Header Host obligatoire**
```http
GET /index.html HTTP/1.1
Host: www.site2.com

â†’ Le serveur sait qu'il faut servir site2.com
```

### HÃ©bergement virtuel basÃ© sur le nom

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Serveur Web (192.0.2.1)             â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ VirtualHost  â”‚                   â”‚
â”‚  â”‚ site1.com    â”‚ â† Host: site1.com â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ VirtualHost  â”‚                   â”‚
â”‚  â”‚ site2.com    â”‚ â† Host: site2.com â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ VirtualHost  â”‚                   â”‚
â”‚  â”‚ site3.com    â”‚ â† Host: site3.com â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Configuration Apache :**
```apache
<VirtualHost *:80>
    ServerName www.site1.com
    DocumentRoot /var/www/site1
</VirtualHost>

<VirtualHost *:80>
    ServerName www.site2.com
    DocumentRoot /var/www/site2
</VirtualHost>

<VirtualHost *:80>
    ServerName www.site3.com
    DocumentRoot /var/www/site3
</VirtualHost>
```

**Configuration Nginx :**
```nginx
server {
    listen 80;
    server_name www.site1.com;
    root /var/www/site1;
}

server {
    listen 80;
    server_name www.site2.com;
    root /var/www/site2;
}

server {
    listen 80;
    server_name www.site3.com;
    root /var/www/site3;
}
```

### Impact Ã©conomique

```
Avant HTTP/1.1 :
- 1 site web = 1 adresse IP
- Avec 1000 sites = besoin de 1000 IPs
- CoÃ»t : Ã‰norme (pÃ©nurie d'IPv4)

Avec HTTP/1.1 et Host :
- 1000 sites web = 1 seule adresse IP
- Ã‰conomie : Massive
- Permet l'hÃ©bergement mutualisÃ© (shared hosting)
```

## Autres amÃ©liorations d'HTTP/1.1

### Range Requests (tÃ©lÃ©chargement partiel)

**Demander une partie d'un fichier :**
```http
GET /video.mp4 HTTP/1.1
Host: media.example.com
Range: bytes=0-1023

RÃ©ponse :
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/10485760
Content-Length: 1024

[1024 premiers octets]
```

**Cas d'usage :**
```
- Streaming vidÃ©o (commencer au milieu)
- Reprise de tÃ©lÃ©chargement interrompu
- TÃ©lÃ©chargement parallÃ¨le
```

**Reprise de tÃ©lÃ©chargement :**
```
1. DÃ©but du tÃ©lÃ©chargement
   GET /bigfile.zip
   â†’ TÃ©lÃ©charge 50 MB sur 100 MB
   â†’ Connexion interrompue

2. Reprise
   GET /bigfile.zip
   Range: bytes=52428800-
   â†’ Reprend Ã  partir de 50 MB
   â†’ TÃ©lÃ©charge les 50 MB restants
```

### Cache amÃ©liorÃ©

**Nouveaux headers de cache :**
```http
# ETag (validation forte)
HTTP/1.1 200 OK
ETag: "33a64df551425fcc55e4d42a148795d9"

# RequÃªte conditionnelle
GET /data.json HTTP/1.1
If-None-Match: "33a64df551425fcc55e4d42a148795d9"

# RÃ©ponse si non modifiÃ©
HTTP/1.1 304 Not Modified

# Cache-Control (remplace Expires)
Cache-Control: max-age=3600, must-revalidate
```

### Nouvelles mÃ©thodes HTTP

HTTP/1.1 a formalisÃ© plusieurs mÃ©thodes :

```http
PUT /resource HTTP/1.1      â†’ CrÃ©er/remplacer
DELETE /resource HTTP/1.1   â†’ Supprimer
OPTIONS /resource HTTP/1.1  â†’ DÃ©couvrir les options
TRACE /resource HTTP/1.1    â†’ Diagnostic
```

### Support de compression

```http
Client â†’
Accept-Encoding: gzip, deflate

Serveur â†’
HTTP/1.1 200 OK
Content-Encoding: gzip
Content-Length: 1234

[donnÃ©es compressÃ©es]
```

**Impact :**
```
Fichier HTML : 100 KB
Avec gzip : 15 KB
Ã‰conomie : 85%
```

## Limitations d'HTTP/1.1

MalgrÃ© ses amÃ©liorations, HTTP/1.1 a des limitations qui ont conduit Ã  HTTP/2.

### 1. Head-of-Line Blocking

**Le problÃ¨me persistant :**
```
Une connexion TCP â†’ Une seule "file" de requÃªtes/rÃ©ponses

RequÃªte lente bloque toutes les suivantes :

GET /heavy-resource (5 secondes)
GET /quick-resource (bloquÃ©, attend 5 secondes)
GET /another-quick (bloquÃ©, attend encore)
```

### 2. Connexions multiples = Workaround, pas solution

**Les navigateurs ouvrent 6 connexions en parallÃ¨le :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚          â”‚ Serveur â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”œâ”€ Connexion 1 â”€â”€â”€â”€â”€â”€â”¤
     â”œâ”€ Connexion 2 â”€â”€â”€â”€â”€â”€â”¤
     â”œâ”€ Connexion 3 â”€â”€â”€â”€â”€â”€â”¤
     â”œâ”€ Connexion 4 â”€â”€â”€â”€â”€â”€â”¤
     â”œâ”€ Connexion 5 â”€â”€â”€â”€â”€â”€â”¤
     â””â”€ Connexion 6 â”€â”€â”€â”€â”€â”€â”˜

Permet 6 requÃªtes en parallÃ¨le
```

**ProblÃ¨mes :**
```
- Overhead : 6 Ã— handshakes TCP
- Overhead : 6 Ã— slow start
- Limite arbitraire : Pourquoi 6 et pas 10 ou 20 ?
- Congestion rÃ©seau
- Utilisation sous-optimale de la bande passante
```

### 3. Headers redondants

**Gaspillage de bande passante :**
```http
RequÃªte 1 :
GET /file1.css HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
Accept: text/css,*/*;q=0.1
Accept-Language: fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7
Accept-Encoding: gzip, deflate, br
Cookie: session=abc123; prefs=dark_mode; lang=fr
â†’ ~500 bytes de headers

RequÃªte 2 :
GET /file2.css HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
Accept: text/css,*/*;q=0.1
Accept-Language: fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7
Accept-Encoding: gzip, deflate, br
Cookie: session=abc123; prefs=dark_mode; lang=fr
â†’ ~500 bytes IDENTIQUES (gaspillage)

Pour 100 requÃªtes : 50 KB de headers redondants !
```

### 4. Priorisation impossible

**Pas de mÃ©canisme de prioritÃ© :**
```
HTML critique et image dÃ©corative ont la mÃªme prioritÃ©
Impossible de dire "tÃ©lÃ©charge le CSS avant les images"
```

### 5. Pas de server push

**Le serveur ne peut pas Ãªtre proactif :**
```
Serveur sait que le client va demander :
- index.html
- style.css (rÃ©fÃ©rencÃ© dans index.html)
- script.js (rÃ©fÃ©rencÃ© dans index.html)

Mais doit attendre que le client demande chaque ressource
```

## Solutions de contournement (avant HTTP/2)

### 1. Domain Sharding

**DÃ©couper les ressources sur plusieurs domaines :**
```html
<!-- Au lieu de tout sur www.example.com -->
<link rel="stylesheet" href="http://www.example.com/style.css">
<script src="http://www.example.com/script.js"></script>
<img src="http://www.example.com/image1.png">
<img src="http://www.example.com/image2.png">

<!-- RÃ©partir sur plusieurs domaines -->
<link rel="stylesheet" href="http://css.example.com/style.css">
<script src="http://js.example.com/script.js"></script>
<img src="http://img1.example.com/image1.png">
<img src="http://img2.example.com/image2.png">

Permet : 6 connexions par domaine
4 domaines = 24 connexions en parallÃ¨le
```

**ProblÃ¨me :**
```
- Overhead DNS (rÃ©solution de 4 domaines)
- Overhead TCP (24 handshakes)
- Configuration complexe
- Pas optimal
```

### 2. ConcatÃ©nation de fichiers

**Regrouper plusieurs fichiers en un :**
```html
<!-- Au lieu de : -->
<script src="jquery.js"></script>
<script src="utils.js"></script>
<script src="app.js"></script>
<script src="plugins.js"></script>

<!-- ConcatÃ©ner en un seul -->
<script src="bundle.js"></script>
```

**ProblÃ¨me :**
```
- Perte de cache granulaire
- Un changement = tout retÃ©lÃ©charger
- ComplexitÃ© de build
```

### 3. CSS Sprites

**Regrouper plusieurs images en une :**
```css
/* Au lieu de 20 requÃªtes pour 20 icÃ´nes */
.icon-home { background: url(sprite.png) 0 0; }
.icon-user { background: url(sprite.png) -20px 0; }
.icon-settings { background: url(sprite.png) -40px 0; }

/* Une seule requÃªte pour sprite.png */
```

### 4. Data URIs

**Inclure les images directement dans le CSS/HTML :**
```css
/* Au lieu de : */
background: url(small-icon.png);

/* Encoder en base64 dans le CSS : */
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUg...);
```

**ProblÃ¨me :**
```
- Augmente la taille du CSS/HTML
- Pas de cache sÃ©parÃ©
- Base64 = +33% de taille
```

### 5. Inlining

**Inclure le CSS/JS directement dans le HTML :**
```html
<style>
  /* Tout le CSS ici au lieu de <link> */
  body { font-family: Arial; }
  .header { background: #333; }
  /* ... */
</style>

<script>
  // Tout le JS ici au lieu de <script src="">
  function init() { /* ... */ }
</script>
```

**Toutes ces solutions sont des "hacks" pour contourner les limitations d'HTTP/1.1**

## Chronologie et adoption

```
1996 : HTTP/1.0 (RFC 1945)
       â†“
1997 : HTTP/1.1 (RFC 2068)
       â†“
1999 : RFC 2616 (rÃ©vision HTTP/1.1)
       â†“
       [18 ans de domination]
       â†“
2014 : RFC 7230-7235 (HTTP/1.1 rÃ©visÃ©)
       â†“
2015 : HTTP/2 (RFC 7540)
```

**Part de marchÃ© aujourd'hui (2025) :**
```
HTTP/1.1 : ~20-30% (legacy, APIs simples)
HTTP/2   : ~60-70% (standard actuel)
HTTP/3   : ~10-20% (adoption croissante)
```

## VÃ©rifier la version HTTP utilisÃ©e

### Chrome DevTools

```
1. F12 â†’ Network
2. Actualiser la page
3. Cliquer sur une requÃªte
4. Voir "Protocol" :
   - "http/1.1" ou "h2" (HTTP/2) ou "h3" (HTTP/3)
```

### curl

```bash
# Voir la version HTTP
curl -I -v https://www.example.com

# Forcer HTTP/1.1
curl --http1.1 https://www.example.com

# Forcer HTTP/2
curl --http2 https://www.example.com
```

### Code

**Python :**
```python
import requests

response = requests.get('https://www.example.com')
print(response.raw.version)
# 11 â†’ HTTP/1.1
# 20 â†’ HTTP/2
```

**JavaScript (browser) :**
```javascript
fetch('https://www.example.com')
  .then(response => {
    console.log(response.headers.get('alt-svc'));
    // Indique les versions alternatives disponibles
  });
```

---

## Points clÃ©s Ã  retenir

ğŸ”‘ **Connexions persistantes** : Par dÃ©faut en HTTP/1.1, Ã©conomie massive de RTT

ğŸ”‘ **Pipelining** : Bonne idÃ©e en thÃ©orie, Ã©chec en pratique (head-of-line blocking)

ğŸ”‘ **Chunked encoding** : Permet le streaming de donnÃ©es sans connaÃ®tre la taille

ğŸ”‘ **Header Host obligatoire** : Permet l'hÃ©bergement virtuel (plusieurs sites, une IP)

ğŸ”‘ **Keep-Alive** : timeout et max requests contrÃ´lent la durÃ©e de vie des connexions

ğŸ”‘ **Range requests** : TÃ©lÃ©chargement partiel et reprise

ğŸ”‘ **Limitations** : Head-of-line blocking, headers redondants, pas de priorisation

ğŸ”‘ **Workarounds** : Domain sharding, concatÃ©nation, sprites (hacks avant HTTP/2)

ğŸ”‘ **HTTP/1.1 = Standard pendant 18 ans** : De 1997 Ã  2015

ğŸ”‘ **Toujours utilisÃ©** : ~20-30% du web en 2025, surtout pour APIs simples

---

## Ce que nous allons voir ensuite

Dans la prochaine section **5.4.5 HTTP/2 : multiplexage et server push**, nous explorerons :
- Le multiplexage qui rÃ©sout le head-of-line blocking
- La compression des headers (HPACK)
- Le server push proactif
- Les streams et la priorisation
- Les gains de performance rÃ©els

**HTTP/2 rÃ©sout les problÃ¨mes fondamentaux d'HTTP/1.1 avec une approche complÃ¨tement diffÃ©rente !** ğŸ‘‰

---

*HTTP/1.1 a Ã©tÃ© le pilier du Web pendant prÃ¨s de deux dÃ©cennies. Ses innovations (connexions persistantes, chunked encoding, hÃ©bergement virtuel) ont permis au Web de croÃ®tre exponentiellement. Cependant, ses limitations ont finalement nÃ©cessitÃ© une refonte complÃ¨te qui a abouti Ã  HTTP/2.*

â­ï¸ [HTTP/2 : multiplexage et server push](/05-couche-application/04.5-http-2.md)
