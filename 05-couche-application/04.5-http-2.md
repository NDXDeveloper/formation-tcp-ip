ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 5.4.5 HTTP/2 : Multiplexage et Server Push

## Introduction

HTTP/2, publiÃ© en **mai 2015** (RFC 7540), reprÃ©sente la **premiÃ¨re rÃ©vision majeure** d'HTTP depuis HTTP/1.1 en 1997. AprÃ¨s 18 ans de domination d'HTTP/1.1, le Web avait besoin d'une refonte profonde pour rÃ©pondre aux exigences des applications modernes.

**Le constat en 2015 :**
- Pages web moyennes : 100+ ressources (contre 10-20 en 2000)
- Latence rÃ©seau : Principal goulot d'Ã©tranglement
- Workarounds HTTP/1.1 : Complexes et sous-optimaux
- Mobile : Connexions Ã  haute latence

**Les objectifs d'HTTP/2 :**
- âœ… RÃ©duire la latence
- âœ… RÃ©soudre le head-of-line blocking
- âœ… Ã‰liminer les workarounds (concatenation, sprites, sharding)
- âœ… CompatibilitÃ© descendante (mÃªmes mÃ©thodes, status codes, headers)
- âœ… Un seul protocole unifiÃ©

**L'origine : SPDY de Google**

HTTP/2 est basÃ© sur SPDY, un protocole expÃ©rimental dÃ©veloppÃ© par Google en 2009-2012 et testÃ© sur Chrome et les serveurs Google.

```
2009 : Google dÃ©veloppe SPDY
2012 : SPDY/3 largement dÃ©ployÃ©
2014 : IETF utilise SPDY comme base pour HTTP/2
2015 : HTTP/2 standardisÃ© (RFC 7540)
2016 : Google abandonne SPDY au profit d'HTTP/2
```

## Le changement fondamental : Format binaire

### HTTP/1.1 : Protocole textuel

```http
GET /index.html HTTP/1.1\r\n
Host: www.example.com\r\n
User-Agent: Mozilla/5.0...\r\n
Accept: text/html\r\n
\r\n
```

**Lisible par un humain, mais :**
- Parsing complexe
- Plusieurs faÃ§ons de reprÃ©senter la mÃªme chose
- Difficile Ã  optimiser
- Sensible aux erreurs

### HTTP/2 : Protocole binaire

```
[Frame binaire]
0x00 0x00 0x10 0x01 0x04 0x00 0x00 0x00 0x01
0x82 0x86 0x84 0x41 0x8a 0xa0 0xe4 0x1d 0x13
...

Non lisible par un humain, mais :
âœ… Parsing rapide et sans ambiguÃ¯tÃ©
âœ… Compact
âœ… Moins d'erreurs
âœ… Facilite le multiplexage
```

**Impact :**
```
On ne peut plus faire de HTTP/2 Ã  la main avec telnet
NÃ©cessite des outils spÃ©cialisÃ©s
Mais gains de performance substantiels
```

## Architecture HTTP/2 : Streams, Messages, Frames

HTTP/2 introduit une **hiÃ©rarchie Ã  trois niveaux** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Connexion TCP                     â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Stream 1 (GET /index.html)            â”‚  â”‚
â”‚  â”‚  Message: Request                     â”‚  â”‚
â”‚  â”‚    Frame: HEADERS                     â”‚  â”‚
â”‚  â”‚    Frame: DATA (si body)              â”‚  â”‚
â”‚  â”‚  Message: Response                    â”‚  â”‚
â”‚  â”‚    Frame: HEADERS                     â”‚  â”‚
â”‚  â”‚    Frame: DATA                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Stream 3 (GET /style.css)             â”‚  â”‚
â”‚  â”‚  Message: Request                     â”‚  â”‚
â”‚  â”‚    Frame: HEADERS                     â”‚  â”‚
â”‚  â”‚  Message: Response                    â”‚  â”‚
â”‚  â”‚    Frame: HEADERS                     â”‚  â”‚
â”‚  â”‚    Frame: DATA                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Stream 5 (GET /script.js)             â”‚  â”‚
â”‚  â”‚  ...                                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### DÃ©finitions

**Connexion (Connection) :**
- Une connexion TCP entre client et serveur
- **Une seule connexion** suffit pour toute la communication

**Stream :**
- Un flux bidirectionnel de frames
- Correspond Ã  une requÃªte/rÃ©ponse HTTP
- IdentifiÃ© par un Stream ID (entier impair pour client, pair pour serveur)
- Plusieurs streams peuvent coexister sur une mÃªme connexion

**Message :**
- Une requÃªte ou une rÃ©ponse HTTP complÃ¨te
- ComposÃ© d'un ou plusieurs frames

**Frame :**
- La plus petite unitÃ© de communication
- Contient un type, des flags, un Stream ID et une payload
- Types : HEADERS, DATA, PRIORITY, RST_STREAM, SETTINGS, PUSH_PROMISE, PING, GOAWAY, WINDOW_UPDATE, CONTINUATION

## Le multiplexage : La rÃ©volution HTTP/2

### Le problÃ¨me HTTP/1.1 rappelÃ©

```
HTTP/1.1 avec pipelining :

RequÃªtes envoyÃ©es :
â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ Req1 â”‚ â”‚ Req2 â”‚ â”‚ Req3 â”‚
â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜
   â†“        â†“        â†“
EnvoyÃ©es dans l'ordre

RÃ©ponses (doivent arriver dans l'ordre) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Resp1 (grosse)   â”‚ â† Bloque tout !
â”‚ [...............]â”‚
â”‚ [...............]â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
   â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”
   â”‚ Res2 â”‚ â”‚ Res3 â”‚  â† Attendent
   â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜

Head-of-line blocking !
```

### La solution HTTP/2 : Multiplexage

**Plusieurs requÃªtes/rÃ©ponses en parallÃ¨le sur une seule connexion TCP :**

```
Connexion TCP unique :

Stream 1 : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (grosse rÃ©ponse)
Stream 3 : â–ˆâ–ˆ (petite rÃ©ponse, terminÃ©e rapidement)
Stream 5 : â–ˆâ–ˆâ–ˆâ–ˆ (moyenne rÃ©ponse)
Stream 7 : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (autre rÃ©ponse)

Timeline :
T0  : [S1][S3][S5][S7][S1][S1][S3][S5][S7][S1]...
      â””â”€ Les frames de diffÃ©rents streams s'entrelacent

RÃ©sultat :
- Stream 3 termine en premier (pas bloquÃ© par Stream 1)
- Stream 5 termine ensuite
- Stream 7 termine
- Stream 1 termine en dernier

PAS de head-of-line blocking !
```

### Exemple concret

**ScÃ©nario : Page avec plusieurs ressources**

```html
<!-- index.html avec 4 ressources -->
<link rel="stylesheet" href="/style.css">
<script src="/app.js"></script>
<img src="/logo.png">
<img src="/banner.jpg">
```

**HTTP/1.1 (6 connexions parallÃ¨les) :**
```
Connexion 1 : GET /index.html
Connexion 2 : GET /style.css
Connexion 3 : GET /app.js
Connexion 4 : GET /logo.png
Connexion 5 : GET /banner.jpg
Connexion 6 : (disponible)

Overhead :
- 5 handshakes TCP
- 5 slow starts
- 5 connexions Ã  maintenir
```

**HTTP/2 (1 connexion) :**
```
Connexion unique :
Stream 1 : GET /index.html
Stream 3 : GET /style.css
Stream 5 : GET /app.js
Stream 7 : GET /logo.png
Stream 9 : GET /banner.jpg

Overhead :
- 1 handshake TCP
- 1 slow start
- 1 connexion Ã  maintenir

Les frames de tous les streams s'entrelacent
```

### Interleaving des frames

**Vue dÃ©taillÃ©e du multiplexage :**

```
Temps â†’

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [HEADERS S1][DATA S1][HEADERS S3][DATA S3][DATA S1]  â”‚
â”‚ [HEADERS S5][DATA S1][DATA S5][DATA S3][DATA S1]     â”‚
â”‚ [DATA S5][HEADERS S7][DATA S7][DATA S1][DATA S5]     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

S1 = Stream 1 (index.html, gros fichier)
S3 = Stream 3 (style.css, petit fichier)
S5 = Stream 5 (app.js, moyen fichier)
S7 = Stream 7 (logo.png, petit fichier)

Chaque stream progresse indÃ©pendamment
Les petits fichiers terminent rapidement
Les gros fichiers ne bloquent pas les autres
```

### Anatomie d'un frame HTTP/2

**Structure d'un frame :**

```
+-----------------------------------------------+
|                 Length (24 bits)              |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31 bits)                 |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+

Length : Taille de la payload (max 16 KB par dÃ©faut)
Type   : Type de frame (HEADERS, DATA, etc.)
Flags  : Drapeaux spÃ©cifiques au type
R      : Bit rÃ©servÃ© (doit Ãªtre 0)
Stream ID : Identifiant du stream (0 pour frames de connexion)
Payload : DonnÃ©es du frame
```

**Types de frames :**

```
DATA          (0x0) : DonnÃ©es de la requÃªte/rÃ©ponse
HEADERS       (0x1) : Headers HTTP
PRIORITY      (0x2) : Priorisation d'un stream
RST_STREAM    (0x3) : Terminer un stream anormalement
SETTINGS      (0x4) : ParamÃ¨tres de connexion
PUSH_PROMISE  (0x5) : Annonce d'un server push
PING          (0x6) : Test de connectivitÃ©
GOAWAY        (0x7) : Fermeture gracieuse
WINDOW_UPDATE (0x8) : ContrÃ´le de flux
CONTINUATION  (0x9) : Continuation de HEADERS
```

### Exemple de sÃ©quence de frames

**Client demande /index.html :**

```
Client â†’ Serveur

Frame 1 : HEADERS (Stream 1)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Length: 42                  â”‚
â”‚ Type: HEADERS (0x1)         â”‚
â”‚ Flags: END_HEADERS (0x4)    â”‚
â”‚ Stream ID: 1                â”‚
â”‚ Payload:                    â”‚
â”‚   :method: GET              â”‚
â”‚   :path: /index.html        â”‚
â”‚   :scheme: https            â”‚
â”‚   :authority: example.com   â”‚
â”‚   user-agent: Chrome/120    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Serveur â†’ Client

Frame 1 : HEADERS (Stream 1)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Length: 35                  â”‚
â”‚ Type: HEADERS (0x1)         â”‚
â”‚ Flags: END_HEADERS (0x4)    â”‚
â”‚ Stream ID: 1                â”‚
â”‚ Payload:                    â”‚
â”‚   :status: 200              â”‚
â”‚   content-type: text/html   â”‚
â”‚   content-length: 1234      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Frame 2 : DATA (Stream 1)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Length: 1234                â”‚
â”‚ Type: DATA (0x0)            â”‚
â”‚ Flags: END_STREAM (0x1)     â”‚
â”‚ Stream ID: 1                â”‚
â”‚ Payload:                    â”‚
â”‚   <!DOCTYPE html>...        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Compression des headers : HPACK

### Le problÃ¨me des headers redondants

**HTTP/1.1 gaspille de la bande passante :**

```http
RequÃªte 1 :
GET /file1.css HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
Accept: text/css,*/*;q=0.1
Accept-Language: fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7
Accept-Encoding: gzip, deflate, br
Cookie: session=abc123; prefs=dark_mode; lang=fr
â†’ ~500 bytes

RequÃªte 2 :
GET /file2.css HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
Accept: text/css,*/*;q=0.1
Accept-Language: fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7
Accept-Encoding: gzip, deflate, br
Cookie: session=abc123; prefs=dark_mode; lang=fr
â†’ ~500 bytes (IDENTIQUES Ã  95%)

100 requÃªtes = 50 KB de headers redondants
```

### HPACK : Compression des headers

HTTP/2 utilise **HPACK** (RFC 7541), un algorithme de compression spÃ©cialement conÃ§u pour les headers HTTP.

**Principes de HPACK :**

1. **Table statique** : Headers courants prÃ©-indexÃ©s
2. **Table dynamique** : Headers vus prÃ©cÃ©demment, indexÃ©s
3. **Huffman coding** : Compression des valeurs

### Table statique HPACK

**Extrait de la table statique :**

```
Index | Header Name          | Header Value
------+----------------------+-------------
1     | :authority           |
2     | :method              | GET
3     | :method              | POST
4     | :path                | /
5     | :path                | /index.html
6     | :scheme              | http
7     | :scheme              | https
8     | :status              | 200
9     | :status              | 204
10    | :status              | 206
...
15    | accept-encoding      | gzip, deflate
...
20    | cache-control        |
...
32    | cookie               |
...
58    | user-agent           |
```

**Total : 61 entrÃ©es prÃ©dÃ©finies**

### Exemple de compression HPACK

**PremiÃ¨re requÃªte :**

```
Headers HTTP (non compressÃ©s) :
:method: GET
:path: /index.html
:scheme: https
:authority: www.example.com
user-agent: Mozilla/5.0 Chrome/120
accept: text/html

Encodage HPACK :
:method: GET                â†’ Index 2 (table statique)
:path: /index.html          â†’ Index 5 (table statique)
:scheme: https              â†’ Index 7 (table statique)
:authority: www.example.com â†’ Literal, ajoutÃ© Ã  la table dynamique (index 62)
user-agent: Mozilla...      â†’ Literal, ajoutÃ© Ã  la table dynamique (index 63)
accept: text/html           â†’ Literal, ajoutÃ© Ã  la table dynamique (index 64)

ReprÃ©sentation binaire compacte :
0x82 0x85 0x87 0x41 0x8a ... (beaucoup plus court)
```

**DeuxiÃ¨me requÃªte (vers le mÃªme serveur) :**

```
Headers HTTP :
:method: GET
:path: /style.css
:scheme: https
:authority: www.example.com
user-agent: Mozilla/5.0 Chrome/120
accept: text/css

Encodage HPACK :
:method: GET                â†’ Index 2 (table statique)
:path: /style.css           â†’ Literal + Huffman
:scheme: https              â†’ Index 7 (table statique)
:authority: www.example.com â†’ Index 62 (table dynamique !)
user-agent: Mozilla...      â†’ Index 63 (table dynamique !)
accept: text/css            â†’ Literal (diffÃ©rent)

Encore plus court car rÃ©utilise la table dynamique
```

### Gains de compression

**Mesures rÃ©elles :**

```
Headers HTTP/1.1 typiques : 500-800 bytes

Avec HPACK :
PremiÃ¨re requÃªte : 150-200 bytes (70% de rÃ©duction)
RequÃªtes suivantes : 50-100 bytes (85-90% de rÃ©duction)

Pour 100 requÃªtes :
HTTP/1.1 : 50-80 KB
HTTP/2   : 5-10 KB
Ã‰conomie : 80-90%
```

### SÃ©curitÃ© : Protection contre CRIME

HPACK a Ã©tÃ© conÃ§u pour Ã©viter la vulnÃ©rabilitÃ© **CRIME** (Compression Ratio Info-leak Made Easy).

**Le problÃ¨me CRIME :**
```
Attaquant injecte des donnÃ©es dans les headers
Observe la taille compressÃ©e
Peut deviner des secrets (cookies, tokens)
```

**Protection HPACK :**
```
- Compression contextuelle (pas de compression globale)
- Table dynamique avec Ã©viction
- Encodage Huffman statique (pas de dictionnaire adaptatif)
```

## Server Push : ProactivitÃ© du serveur

### Le concept

Le serveur peut **envoyer des ressources au client** avant que celui-ci ne les demande.

**HTTP/1.1 : RequÃªtes sÃ©quentielles**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚                         â”‚ Serveur â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                                   â”‚
     â”‚â”€â”€â”€â”€ GET /index.html â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                   â”‚
     â”‚<â”€â”€â”€ 200 OK [HTML] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚                                   â”‚
     â”‚ [Parse HTML, dÃ©couvre style.css]  â”‚
     â”‚                                   â”‚
     â”‚â”€â”€â”€â”€ GET /style.css â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                   â”‚
     â”‚<â”€â”€â”€ 200 OK [CSS] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚                                   â”‚
     â”‚ [Parse HTML, dÃ©couvre app.js]     â”‚
     â”‚                                   â”‚
     â”‚â”€â”€â”€â”€ GET /app.js â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                   â”‚
     â”‚<â”€â”€â”€ 200 OK [JS] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚

Total : 3 RTT pour rÃ©cupÃ©rer 3 ressources
```

**HTTP/2 : Server Push**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚                         â”‚ Serveur â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                                   â”‚
     â”‚â”€â”€â”€â”€ GET /index.html â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                   â”‚
     â”‚<â”€â”€â”€ PUSH_PROMISE (style.css) â”€â”€â”€â”€â”€â”‚
     â”‚<â”€â”€â”€ PUSH_PROMISE (app.js) â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚<â”€â”€â”€ 200 OK [HTML] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚<â”€â”€â”€ 200 OK [CSS] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ Pushed !
     â”‚<â”€â”€â”€ 200 OK [JS] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ Pushed !
     â”‚                                   â”‚
     â”‚ [Parse HTML, style.css et app.js  â”‚
     â”‚  sont dÃ©jÃ  dans le cache !]       â”‚

Total : 1 RTT pour rÃ©cupÃ©rer 3 ressources
Ã‰conomie : 2 RTT
```

### PUSH_PROMISE Frame

**Le serveur annonce ce qu'il va pusher :**

```
Frame PUSH_PROMISE :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Length: 45                      â”‚
â”‚ Type: PUSH_PROMISE (0x5)        â”‚
â”‚ Flags: END_HEADERS (0x4)        â”‚
â”‚ Stream ID: 1                    â”‚ â† Stream de la requÃªte originale
â”‚ Payload:                        â”‚
â”‚   Promised Stream ID: 2         â”‚ â† Nouveau stream pour le push
â”‚   :method: GET                  â”‚
â”‚   :path: /style.css             â”‚
â”‚   :scheme: https                â”‚
â”‚   :authority: example.com       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Puis envoie les donnÃ©es :
Frame HEADERS (Stream 2)
Frame DATA (Stream 2, END_STREAM)
```

### Exemple concret de configuration

**Nginx :**

```nginx
server {
    listen 443 ssl http2;
    server_name www.example.com;

    location / {
        # Push des ressources critiques
        http2_push /style.css;
        http2_push /app.js;
        http2_push /logo.png;

        root /var/www/html;
    }
}
```

**Apache (mod_http2) :**

```apache
<VirtualHost *:443>
    Protocols h2 http/1.1
    ServerName www.example.com

    <Location /index.html>
        # Link header dÃ©clenche le push
        Header add Link "</style.css>; rel=preload; as=style"
        Header add Link "</app.js>; rel=preload; as=script"
    </Location>
</VirtualHost>
```

**Node.js (avec http2) :**

```javascript
const http2 = require('http2');
const fs = require('fs');

const server = http2.createSecureServer({
  key: fs.readFileSync('server.key'),
  cert: fs.readFileSync('server.crt')
});

server.on('stream', (stream, headers) => {
  if (headers[':path'] === '/index.html') {
    // Push style.css
    stream.pushStream({ ':path': '/style.css' }, (err, pushStream) => {
      pushStream.respondWithFile('style.css');
    });

    // Push app.js
    stream.pushStream({ ':path': '/app.js' }, (err, pushStream) => {
      pushStream.respondWithFile('app.js');
    });

    // Envoyer index.html
    stream.respondWithFile('index.html');
  }
});

server.listen(443);
```

### Cas d'usage du Server Push

**âœ… Bon usage :**

```
1. Page d'accueil avec CSS/JS critiques
   GET / â†’ Push style.css, app.js

2. Single Page Application (SPA)
   GET /app â†’ Push app.bundle.js, vendor.js, styles.css

3. Ressources critiques pour le rendu
   GET /article â†’ Push hero-image.jpg, fonts.woff2

4. API avec donnÃ©es prÃ©visibles
   GET /dashboard â†’ Push user-data.json, notifications.json
```

**âŒ Mauvais usage :**

```
1. Pusher des ressources dÃ©jÃ  en cache
   â†’ Gaspillage de bande passante

2. Pusher trop de ressources
   â†’ Congestion, retarde ce qui est vraiment important

3. Pusher des ressources qui ne seront pas utilisÃ©es
   â†’ Gaspillage pur

4. Pusher sans condition
   â†’ Ignorer les caches existants
```

### Le client peut refuser un push

**RST_STREAM pour annuler :**

```
Serveur â†’ Client : PUSH_PROMISE (large-video.mp4)

Client (voit qu'il a dÃ©jÃ  le fichier en cache) :
Frame RST_STREAM :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Type: RST_STREAM (0x3)          â”‚
â”‚ Stream ID: 2 (pushed stream)    â”‚
â”‚ Error Code: CANCEL (0x8)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Serveur arrÃªte l'envoi de large-video.mp4
```

### Limitations et dÃ©clin du Server Push

**ProblÃ¨mes rencontrÃ©s :**

1. **Cache invalidation difficile**
   ```
   Serveur ne sait pas ce que le client a dÃ©jÃ  en cache
   Risque de pusher des ressources inutilement
   ```

2. **ComplexitÃ© de configuration**
   ```
   Difficile de savoir quoi pusher
   Trop de push â†’ performance dÃ©gradÃ©e
   Pas assez â†’ pas d'amÃ©lioration
   ```

3. **Priorisation complexe**
   ```
   Les pushes peuvent bloquer des ressources plus importantes
   ```

**Ã‰volution :**

```
2015 : Server Push annoncÃ© comme rÃ©volutionnaire
2017 : Adoption faible, problÃ¨mes identifiÃ©s
2020 : Chrome annonce la dÃ©prÃ©ciation du Server Push
2022 : HTTP/3 n'inclut plus Server Push par dÃ©faut
2025 : RemplacÃ© par Early Hints (103) et preload
```

**Alternative moderne : Early Hints (103)**

```http
Client â†’
GET /index.html

Serveur â†’ (immÃ©diatement)
HTTP/2 103 Early Hints
Link: </style.css>; rel=preload; as=style
Link: </app.js>; rel=preload; as=script

[Serveur continue de gÃ©nÃ©rer index.html]

Serveur â†’ (plus tard)
HTTP/2 200 OK
Content-Type: text/html

<!DOCTYPE html>...
```

**Avantages des Early Hints :**
- Client garde le contrÃ´le (peut utiliser le cache)
- Plus simple Ã  implÃ©menter
- Pas de risque de pusher inutilement

## Priorisation des streams

### Le problÃ¨me

Toutes les ressources n'ont pas la mÃªme importance :

```
Page web typique :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Critique (bloque le rendu) :            â”‚
â”‚ - HTML                                  â”‚
â”‚ - CSS                                   â”‚
â”‚ - JavaScript synchrone                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Important :                             â”‚
â”‚ - Images above the fold                 â”‚
â”‚ - Fonts                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Moins important :                       â”‚
â”‚ - Images below the fold                 â”‚
â”‚ - JavaScript asynchrone                 â”‚
â”‚ - Analytics                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Sans priorisation :**
```
Image dÃ©corative et CSS critique ont la mÃªme prioritÃ©
â†’ Risque de retarder le rendu Ã  cause d'images
```

### SystÃ¨me de priorisation HTTP/2

**Deux mÃ©canismes :**

1. **DÃ©pendances (Stream Dependencies)**
2. **Poids (Weights)**

### DÃ©pendances de streams

**Un stream peut dÃ©pendre d'un autre :**

```
Stream 1 (HTML)
    â†“ dÃ©pend de
Stream 3 (CSS critique)
    â†“ dÃ©pend de
Stream 5 (Image)

RÃ¨gle : Stream 5 ne peut progresser que si Stream 3 est terminÃ©
```

**Frame PRIORITY :**

```
Frame PRIORITY :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Type: PRIORITY (0x2)            â”‚
â”‚ Stream ID: 5                    â”‚
â”‚ Payload:                        â”‚
â”‚   Exclusive: 0                  â”‚
â”‚   Stream Dependency: 3          â”‚
â”‚   Weight: 16                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Stream 5 dÃ©pend de Stream 3
```

### Poids (Weights)

**RÃ©partition de la bande passante entre streams de mÃªme niveau :**

```
Stream 1 (Weight: 200) â”€â”€â”€â”
                          â”œâ”€ Niveau de prioritÃ© Ã©gal
Stream 3 (Weight: 100) â”€â”€â”€â”˜

RÃ©partition :
Stream 1 : 200/(200+100) = 66% de la bande passante
Stream 3 : 100/(200+100) = 33% de la bande passante
```

### Arbre de dÃ©pendances

**Exemple complet :**

```
                     Stream 0 (connexion)
                           |
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              |            |            |
          Stream 1     Stream 3     Stream 5
          (HTML)       (CSS)        (JS)
          Weight:256   Weight:256   Weight:128
              |            |
         â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”       |
         |         |       |
     Stream 7  Stream 9  Stream 11
     (Image)   (Font)    (Icon)
     W:16      W:32      W:8

Ordre de traitement :
1. HTML, CSS, JS (en parallÃ¨le, proportionnel aux poids)
2. Une fois HTML terminÃ© â†’ Image et Font
3. Une fois CSS terminÃ© â†’ Icon
```

### Priorisation en pratique

**Navigateurs modernes implÃ©mentent des heuristiques :**

```
Chrome priority scheme (simplifiÃ©) :

Highest (256) :
- HTML principal
- CSS bloquant le rendu

High (220) :
- Scripts synchrones
- Fonts

Medium (147) :
- Images visibles (viewport)
- Fetch/XHR important

Low (110) :
- Scripts async
- Images hors viewport
- Prefetch

Lowest (73) :
- Analytics
- Tracking pixels
```

**Configuration serveur :**

```nginx
# Nginx ajuste les prioritÃ©s automatiquement
# basÃ© sur le type de ressource

http2_max_concurrent_streams 128;
```

## ContrÃ´le de flux (Flow Control)

### Pourquoi le contrÃ´le de flux ?

**ProblÃ¨me :** Un stream rapide peut surcharger le rÃ©cepteur.

```
Serveur (rapide) :
Stream 1 : Envoie 10 MB/s
Stream 3 : Envoie 10 MB/s
Stream 5 : Envoie 10 MB/s
Total : 30 MB/s

Client (lent) :
Peut traiter seulement 5 MB/s
â†’ Buffers saturÃ©s
â†’ Perte de performance
```

### WINDOW_UPDATE frames

**Chaque stream et la connexion ont une fenÃªtre de contrÃ´le de flux :**

```
FenÃªtre initiale : 65,535 bytes (64 KB)

Client annonce combien il peut recevoir :

Frame WINDOW_UPDATE :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Type: WINDOW_UPDATE (0x8)       â”‚
â”‚ Stream ID: 1                    â”‚
â”‚ Window Size Increment: 16384    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Stream 1 peut maintenant envoyer 16 KB de plus
```

**Deux niveaux de contrÃ´le :**

```
1. Niveau connexion (Stream ID 0)
   â†’ Limite totale pour toute la connexion

2. Niveau stream (Stream ID > 0)
   â†’ Limite par stream individuel
```

### Exemple de flow control

```
Ã‰tat initial :
Connexion : Window = 65535
Stream 1  : Window = 65535

Serveur envoie 32 KB sur Stream 1 :
Connexion : Window = 33535
Stream 1  : Window = 33535

Client traite les donnÃ©es, envoie WINDOW_UPDATE :
Frame WINDOW_UPDATE (Stream 0) : +32768
Frame WINDOW_UPDATE (Stream 1) : +32768

Nouvelle capacitÃ© :
Connexion : Window = 66303
Stream 1  : Window = 66303
```

## NÃ©gociation HTTP/2

### Connection Preface

**DÃ©but d'une connexion HTTP/2 :**

```
1. Client Ã©tablit TLS
2. Client envoie la connection preface :

   "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
   (magic string pour identifier HTTP/2)

3. Client envoie SETTINGS frame
4. Serveur envoie SETTINGS frame
5. Les deux envoient SETTINGS ACK
6. Connexion HTTP/2 Ã©tablie
```

**SÃ©quence complÃ¨te :**

```
Client â†’ Serveur :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PRI * HTTP/2.0\r\n\r\nSM\r\n\r\nâ”‚ (24 bytes magic)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Client â†’ Serveur :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SETTINGS frame                  â”‚
â”‚   HEADER_TABLE_SIZE: 4096       â”‚
â”‚   ENABLE_PUSH: 1                â”‚
â”‚   MAX_CONCURRENT_STREAMS: 100   â”‚
â”‚   INITIAL_WINDOW_SIZE: 65535    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Serveur â†’ Client :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SETTINGS frame                  â”‚
â”‚   MAX_CONCURRENT_STREAMS: 128   â”‚
â”‚   INITIAL_WINDOW_SIZE: 65535    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Client â†’ Serveur :
SETTINGS ACK

Serveur â†’ Client :
SETTINGS ACK

â†’ Connexion HTTP/2 prÃªte
```

### ALPN (Application-Layer Protocol Negotiation)

**NÃ©gociation pendant le handshake TLS :**

```
TLS ClientHello :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ...                             â”‚
â”‚ ALPN Extension:                 â”‚
â”‚   - h2         (HTTP/2)         â”‚
â”‚   - http/1.1   (fallback)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TLS ServerHello :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ...                             â”‚
â”‚ ALPN Selected: h2               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â†’ HTTP/2 sera utilisÃ©
```

**Identifiants de protocole :**
```
h2      : HTTP/2 over TLS
h2c     : HTTP/2 over cleartext TCP (rarement utilisÃ©)
http/1.1 : HTTP/1.1
h3      : HTTP/3 (QUIC)
```

## Comparaison HTTP/1.1 vs HTTP/2

### Benchmark rÃ©el

**Page typique : 100 ressources (HTML, CSS, JS, images)**

```
RÃ©seau : 100 Mbps, RTT = 50ms

HTTP/1.1 (6 connexions) :
- Handshakes : 6 Ã— 50ms = 300ms
- Head-of-line blocking
- Headers non compressÃ©s : 50 KB
- Temps total : 4.2 secondes

HTTP/2 (1 connexion) :
- Handshake : 1 Ã— 50ms = 50ms
- Pas de head-of-line blocking
- Headers compressÃ©s : 5 KB
- Multiplexage efficace
- Temps total : 2.1 secondes

AmÃ©lioration : 50% plus rapide
```

### Tableau comparatif

| CaractÃ©ristique | HTTP/1.1 | HTTP/2 |
|----------------|----------|---------|
| **Format** | Texte | Binaire |
| **Connexions** | 6+ parallÃ¨les | 1 seule |
| **Multiplexage** | âŒ Non | âœ… Oui |
| **Head-of-line blocking** | âœ… Oui | âŒ Non (au niveau HTTP) |
| **Compression headers** | âŒ Non | âœ… Oui (HPACK) |
| **Server push** | âŒ Non | âœ… Oui (dÃ©prÃ©ciÃ©) |
| **Priorisation** | âŒ Non | âœ… Oui |
| **TLS** | Optionnel | Obligatoire (navigateurs) |
| **Overhead headers** | ~500 bytes/req | ~50-100 bytes/req |

### Cas oÃ¹ HTTP/2 brille

**âœ… Excellente amÃ©lioration :**

```
1. Pages avec beaucoup de ressources
   - Sites modernes (100+ requÃªtes)
   - SPA (Single Page Applications)

2. Latence rÃ©seau Ã©levÃ©e
   - Mobile (4G/5G)
   - Connexions longue distance
   - Satellites

3. APIs avec beaucoup de requÃªtes
   - Microservices
   - GraphQL
   - REST avec pagination

4. Streaming de donnÃ©es
   - Pas de head-of-line blocking
```

**âš ï¸ AmÃ©lioration limitÃ©e :**

```
1. Sites trÃ¨s simples
   - 5-10 ressources seulement
   - Gain marginal

2. RÃ©seau trÃ¨s rapide et faible latence
   - LAN local
   - Gain moins perceptible

3. Gros fichiers uniques
   - TÃ©lÃ©chargement d'un fichier de 1 GB
   - Pas de diffÃ©rence notable
```

## Adoption et dÃ©ploiement

### Statistiques d'adoption (2025)

```
Support navigateurs : 100%
- Chrome/Edge : Depuis 2015
- Firefox : Depuis 2015
- Safari : Depuis 2016
- Opera : Depuis 2016

Sites web utilisant HTTP/2 :
- Top 1000 sites : >95%
- Tous les sites : ~70%

CDNs :
- Cloudflare : âœ…
- AWS CloudFront : âœ…
- Akamai : âœ…
- Fastly : âœ…
```

### Support serveur

```
âœ… Nginx : 1.9.5+ (2015)
âœ… Apache : 2.4.17+ avec mod_http2
âœ… IIS : Windows Server 2016+
âœ… Node.js : Module http2 natif (8.4+)
âœ… Caddy : Support natif
âœ… LiteSpeed : Support natif
```

### Migration HTTP/1.1 â†’ HTTP/2

**Configuration Nginx :**

```nginx
# Avant (HTTP/1.1 seulement)
server {
    listen 443 ssl;
    server_name www.example.com;

    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
}

# AprÃ¨s (HTTP/2 activÃ©)
server {
    listen 443 ssl http2;  # â† Ajout de http2
    server_name www.example.com;

    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
}
```

**Configuration Apache :**

```apache
# Activer mod_http2
LoadModule http2_module modules/mod_http2.so

<VirtualHost *:443>
    Protocols h2 http/1.1
    ServerName www.example.com

    SSLEngine on
    SSLCertificateFile /path/to/cert.pem
    SSLCertificateKeyFile /path/to/key.pem
</VirtualHost>
```

### VÃ©rifier si HTTP/2 est activÃ©

**Chrome DevTools :**

```
1. F12 â†’ Network
2. Clic droit sur les en-tÃªtes de colonnes
3. Activer "Protocol"
4. Actualiser la page
5. Voir "h2" dans la colonne Protocol
```

**curl :**

```bash
# Verbose pour voir le protocole
curl -I --http2 -v https://www.example.com

# RÃ©sultat :
* ALPN, offering h2
* ALPN, server accepted to use h2
> GET / HTTP/2
> Host: www.example.com
...
< HTTP/2 200
```

**En ligne :**

```
https://tools.keycdn.com/http2-test
```

### Optimisations inutiles avec HTTP/2

**Ã€ supprimer :**

```
âŒ Domain sharding (plusieurs domaines)
   â†’ Une connexion suffit

âŒ ConcatÃ©nation CSS/JS
   â†’ Perte de cache granulaire
   â†’ HTTP/2 gÃ¨re bien les petits fichiers

âŒ CSS Sprites
   â†’ ComplexitÃ© inutile
   â†’ HTTP/2 gÃ¨re bien les petites images

âŒ Inlining
   â†’ Perte de cache
   â†’ Taille de page augmentÃ©e
```

**Ã€ garder :**

```
âœ… Minification (CSS, JS)
   â†’ Toujours utile (moins de bytes)

âœ… Compression (gzip, brotli)
   â†’ Toujours utile

âœ… Lazy loading
   â†’ Toujours utile (charge ce qui est nÃ©cessaire)

âœ… CDN
   â†’ Toujours utile (proximitÃ© gÃ©ographique)
```

## Limitations d'HTTP/2

MalgrÃ© ses amÃ©liorations, HTTP/2 a encore des limitations.

### 1. Head-of-line blocking TCP

**HTTP/2 rÃ©sout le HOL au niveau HTTP, mais PAS au niveau TCP :**

```
HTTP/2 utilise toujours TCP

Perte de paquet TCP :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Paquet 1 [S1][S3][S5]    âœ…         â”‚
â”‚ Paquet 2 [S1][S7][S9]    âŒ PERDU   â”‚
â”‚ Paquet 3 [S3][S5][S11]   âœ…         â”‚
â”‚ Paquet 4 [S1][S13][S15]  âœ…         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ProblÃ¨me :
- Paquet 2 perdu
- TCP bloque TOUS les paquets suivants
- MÃªme si Paquet 3 et 4 sont reÃ§us
- Tous les streams attendent la retransmission

â†’ Head-of-line blocking TCP
```

**Impact sur mobile :**

```
4G/5G avec perte de paquets 1-3% :
- HTTP/1.1 avec 6 connexions : Une perte affecte 1 connexion
- HTTP/2 avec 1 connexion : Une perte affecte TOUT

Parfois HTTP/1.1 peut Ãªtre plus rapide !
```

### 2. ComplexitÃ© d'implÃ©mentation

```
HTTP/2 est complexe :
- Format binaire
- Multiplexage
- Compression HPACK
- Flow control
- Priorisation

Bugs frÃ©quents dans les implÃ©mentations
Difficile Ã  dÃ©boguer
```

### 3. Server Push peu utilisÃ©

```
Comme vu prÃ©cÃ©demment :
- Difficile Ã  configurer correctement
- ProblÃ¨mes de cache
- DÃ©prÃ©ciÃ© dans Chrome
```

## HTTP/2 vs HTTP/3

**HTTP/3 rÃ©sout le head-of-line blocking TCP en utilisant QUIC/UDP :**

```
HTTP/2 :
Application : HTTP/2
Transport   : TCP      â† Bloque tout si perte
Network     : IP

HTTP/3 :
Application : HTTP/3
Transport   : QUIC/UDP â† Pas de HOL au niveau transport
Network     : IP
```

Nous verrons HTTP/3 dans la section suivante !

---

## Points clÃ©s Ã  retenir

ğŸ”‘ **Format binaire** : Plus efficace, parsing rapide, mais pas lisible

ğŸ”‘ **Multiplexage** : Plusieurs requÃªtes/rÃ©ponses en parallÃ¨le sur une connexion

ğŸ”‘ **Streams** : UnitÃ© de communication, plusieurs streams par connexion

ğŸ”‘ **HPACK** : Compression des headers (80-90% de rÃ©duction)

ğŸ”‘ **Server Push** : Le serveur peut envoyer proactivement (dÃ©prÃ©ciÃ©)

ğŸ”‘ **Priorisation** : DÃ©pendances et poids pour optimiser l'ordre

ğŸ”‘ **Une connexion suffit** : Plus de domain sharding ou connexions multiples

ğŸ”‘ **TLS obligatoire** : HTTPS requis par les navigateurs

ğŸ”‘ **Gains rÃ©els** : 30-50% plus rapide que HTTP/1.1 sur pages modernes

ğŸ”‘ **Limitation TCP** : Head-of-line blocking TCP persiste (rÃ©solu par HTTP/3)

---

## Ce que nous allons voir ensuite

Dans la prochaine section **5.4.6 HTTP/3 et QUIC : transport sur UDP**, nous explorerons :
- QUIC : Nouveau protocole de transport basÃ© sur UDP
- RÃ©solution du head-of-line blocking TCP
- Migration de connexion
- 0-RTT connection establishment
- Adoption et avenir du web

**HTTP/3 est la prochaine rÃ©volution, abandonnant TCP aprÃ¨s 40 ans !** ğŸ‘‰

---

*HTTP/2 a reprÃ©sentÃ© une avancÃ©e majeure en rÃ©solvant les problÃ¨mes critiques d'HTTP/1.1 : multiplexage, compression des headers, et optimisations de performance. Bien que complexe, il est devenu le standard du web moderne et a permis des applications web beaucoup plus riches et performantes. Cependant, ses limitations au niveau TCP ont ouvert la voie Ã  HTTP/3.*

â­ï¸ [HTTP/3 et QUIC : transport sur UDP](/05-couche-application/04.6-http-3-quic.md)
