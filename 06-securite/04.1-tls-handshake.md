üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.4.1 Handshake TLS

## Introduction

Le **handshake TLS** (poign√©e de main) est la s√©quence de n√©gociation qui se produit au d√©but de chaque connexion TLS. C'est pendant ce processus crucial que :

- **Client et serveur se mettent d'accord** sur les param√®tres cryptographiques
- **Le serveur prouve son identit√©** avec son certificat
- **Les cl√©s de chiffrement sont √©tablies** de mani√®re s√©curis√©e
- **L'int√©grit√© du handshake est v√©rifi√©e** pour d√©tecter toute manipulation

Le handshake est la phase la plus complexe de TLS, mais aussi la plus critique pour la s√©curit√©. Une compr√©hension approfondie de ce m√©canisme est essentielle pour :

- Diagnostiquer les probl√®mes de connexion HTTPS
- Optimiser les performances TLS
- Comprendre les vuln√©rabilit√©s potentielles
- Configurer correctement serveurs et clients
- Analyser le trafic r√©seau chiffr√©

**Analogie** : Le handshake TLS est comme deux espions qui se rencontrent pour la premi√®re fois :
1. Ils v√©rifient mutuellement leur identit√© (badges, codes secrets)
2. Ils s'accordent sur une langue commune pour communiquer
3. Ils √©tablissent un code secret que personne d'autre ne conna√Æt
4. Seulement apr√®s tout cela, ils commencent √† √©changer des informations sensibles

## Vue d'ensemble : avant et apr√®s le handshake

### Cycle de vie d'une connexion TLS

```
1. √âtablissement TCP (three-way handshake)
   Client ‚Üí SYN
   Server ‚Üí SYN-ACK
   Client ‚Üí ACK
   [Connexion TCP √©tablie]

2. Handshake TLS
   Client ‚Üí ClientHello
   Server ‚Üí ServerHello, Certificate, ServerHelloDone
   Client ‚Üí ClientKeyExchange, ChangeCipherSpec, Finished
   Server ‚Üí ChangeCipherSpec, Finished
   [Connexion TLS s√©curis√©e √©tablie]

3. Transfert de donn√©es chiffr√©es
   Client ‚Üî Server : Application Data (HTTP, etc.)
   [Communication prot√©g√©e]

4. Fermeture de connexion
   Client/Server ‚Üí Close notify
   [Connexion TLS ferm√©e proprement]
```

### Avant le handshake : √©tat initial

```
Client et Serveur :
- Aucun secret partag√©
- Aucune cl√© de chiffrement
- Communication en clair (TCP uniquement)
- Vuln√©rable √† toutes les attaques r√©seau

Exemple - ce qui serait visible sans TLS :
GET /account HTTP/1.1
Cookie: session=abc123
‚Üí Visible par tous les interm√©diaires
```

### Apr√®s le handshake : √©tat s√©curis√©

```
Client et Serveur ont √©tabli :
‚úì Master Secret (cl√© ma√Ætresse partag√©e)
‚úì Cl√©s de chiffrement (client‚Üíserver, server‚Üíclient)
‚úì Cl√©s d'authentification (MAC keys)
‚úì Algorithmes convenus (cipher suite)
‚úì Authentification du serveur (certificat v√©rifi√©)
‚úì V√©rification de l'int√©grit√© du handshake

R√©sultat :
GET /account HTTP/1.1
Cookie: session=abc123
‚Üì Transform√© en :
0x17 0x03 0x03 0x00 0x29 [donn√©es chiffr√©es]...
‚Üí Illisible pour les interm√©diaires
```

## TLS 1.2 Handshake : le standard actuel

TLS 1.2 est encore largement utilis√© en 2024 et sera notre point de d√©part pour comprendre le handshake.

### Diagramme complet du handshake

```
Client                                               Server

ClientHello                  -------->
                                                ServerHello
                                               Certificate*
                                         ServerKeyExchange*
                                        CertificateRequest*
                             <--------      ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished                     -------->
                                         [ChangeCipherSpec]
                             <--------             Finished
Application Data             <------->     Application Data

* = Messages conditionnels
[...] = Pas vraiment un message handshake, mais un record protocol message
```

**Temps d'√©change** : 2 RTT (Round-Trip Time)

```
RTT 1 : ClientHello ‚Üí ServerHello + Certificate + ...
RTT 2 : ClientKeyExchange + ... ‚Üí Finished
Ensuite : Donn√©es applicatives
```

### Phase 1 : ClientHello

Le client initie la connexion en envoyant ses capacit√©s et pr√©f√©rences.

**Structure du message ClientHello** :

```
ClientHello {
    client_version          : ProtocolVersion (ex: TLS 1.2 = 0x0303)
    random                  : 32 octets
        ‚îú‚îÄ timestamp (4 octets)
        ‚îî‚îÄ random bytes (28 octets)
    session_id              : 0-32 octets (pour session resumption)
    cipher_suites           : Liste des cipher suites support√©es
    compression_methods     : Liste des m√©thodes de compression (d√©pr√©ci√©)
    extensions              : Extensions TLS
        ‚îú‚îÄ server_name (SNI)
        ‚îú‚îÄ supported_groups (courbes elliptiques)
        ‚îú‚îÄ signature_algorithms
        ‚îú‚îÄ application_layer_protocol_negotiation (ALPN)
        ‚îî‚îÄ ...
}
```

**Exemple concret** :

```
ClientHello d√©taill√© :

Version: TLS 1.2 (0x0303)

Random: 32 octets
  Timestamp: 2024-12-06 14:30:45 UTC
  Random bytes: a3 f5 c8 d9 e1 b4 a7 c2 f8 d3 e9 b1 ...

Session ID: (vide si nouvelle connexion)

Cipher Suites (18 suites propos√©es) :
  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256       (0xc02f)
  TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384       (0xc030)
  TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xcca8)
  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256     (0xc02b)
  TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384     (0xc02c)
  ... (autres suites)

Compression Methods:
  null (0x00)  ‚Üê Seule m√©thode recommand√©e

Extensions:
  server_name (SNI):
    hostname: www.example.com

  supported_groups (courbes elliptiques):
    x25519, secp256r1, secp384r1

  ec_point_formats:
    uncompressed

  signature_algorithms:
    rsa_pss_rsae_sha256
    rsa_pkcs1_sha256
    ecdsa_secp256r1_sha256
    ...

  application_layer_protocol_negotiation (ALPN):
    h2 (HTTP/2)
    http/1.1

  supported_versions:
    TLS 1.3, TLS 1.2
```

**Capture r√©elle (Wireshark)** :

```
Transport Layer Security
  TLSv1.2 Record Layer: Handshake Protocol: Client Hello
    Content Type: Handshake (22)
    Version: TLS 1.0 (0x0301)  ‚Üê Compatibility
    Length: 512
    Handshake Protocol: Client Hello
      Handshake Type: Client Hello (1)
      Length: 508
      Version: TLS 1.2 (0x0303)
      Random: 675270a5 b3c4d5e6 f7a8b9c0 ... (32 bytes)
      Session ID Length: 0
      Cipher Suites Length: 36
      Cipher Suites (18 suites)
        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        ...
      Compression Methods Length: 1
      Compression Methods (1 method)
      Extensions Length: 431
      Extension: server_name (len=20)
        Server Name: www.example.com
      Extension: supported_groups (len=10)
        Supported Groups (4 groups)
          Supported Group: x25519 (0x001d)
          Supported Group: secp256r1 (0x0017)
          ...
```

**Informations r√©v√©l√©es (m√™me chiffr√©es plus tard)** :

```
Visibles en clair dans ClientHello :
‚úì SNI (Server Name Indication) : www.example.com
‚úì Cipher suites support√©es (fingerprinting possible)
‚úì Extensions utilis√©es
‚úì Version TLS maximale support√©e

‚Üí M√©tadonn√©es expos√©es (privacy concern)
‚Üí Solutions : ESNI (Encrypted SNI), ECH (Encrypted Client Hello)
```

### Phase 2 : ServerHello et certificat

Le serveur r√©pond avec ses choix et son identit√©.

**Messages du serveur** :

```
1. ServerHello
2. Certificate
3. ServerKeyExchange (si n√©cessaire)
4. CertificateRequest (optionnel - authentification client)
5. ServerHelloDone
```

#### ServerHello

```
ServerHello {
    server_version     : TLS 1.2 (0x0303)
    random             : 32 octets (diff√©rent du client)
    session_id         : ID de session (pour resumption future)
    cipher_suite       : UNE seule cipher suite (choix du serveur)
    compression_method : null
    extensions         : Extensions serveur
}
```

**Exemple** :

```
ServerHello d√©taill√© :

Version: TLS 1.2 (0x0303)

Random: 32 octets
  Timestamp: 2024-12-06 14:30:45 UTC
  Random bytes: 7b 2d 9a 1f 3c 8e 4b 6d 5a 7c 8d 9e ...

Session ID: 32 octets
  a1 b2 c3 d4 e5 f6 07 18 29 3a 4b 5c 6d 7e 8f 90 ...
  (le client peut l'utiliser pour resumption)

Cipher Suite choisi:
  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)

Compression Method: null (0x00)

Extensions:
  renegotiation_info: (empty)
  extended_master_secret
  ec_point_formats: uncompressed
  application_layer_protocol_negotiation: h2
```

**Choix de la cipher suite** :

```
Processus de s√©lection :
1. Serveur examine la liste du client (18 suites propos√©es)
2. Serveur trouve la premi√®re suite qu'il supporte ET pr√©f√®re
3. Serveur s√©lectionne cette suite unique

Exemple :
Client propose : A, B, C, D, E
Serveur supporte : B, D, F
Serveur pr√©f√®re (ordre) : D, B, F
‚Üí Serveur choisit : D

R√©sultat :
‚úì Une seule cipher suite pour toute la session
‚úì Impossible de changer apr√®s ServerHello
‚úì D√©termine tous les algorithmes cryptographiques
```

#### Certificate

Le serveur envoie son certificat (et la cha√Æne de certification).

```
Certificate {
    certificate_list : S√©quence de certificats
        [0] : Certificat du serveur (end-entity)
        [1] : Certificat interm√©diaire (optionnel)
        [2] : Autre certificat interm√©diaire (optionnel)
        ... (jusqu'au certificat racine, souvent non inclus)
}
```

**Exemple** :

```
Certificate chain:

Certificate 0 (Server certificate):
  Subject: CN=www.example.com, O=Example Inc, C=US
  Issuer: CN=Let's Encrypt Authority X3, O=Let's Encrypt, C=US
  Validity:
    Not Before: 2024-01-01 00:00:00 UTC
    Not After:  2025-01-01 23:59:59 UTC
  Public Key: RSA 2048 bits
    Modulus: c7 45 89 ab cd ef ... (256 bytes)
    Exponent: 65537 (0x010001)
  Extensions:
    Subject Alternative Names:
      DNS: www.example.com
      DNS: example.com
    Key Usage: Digital Signature, Key Encipherment
    Extended Key Usage: Server Authentication
  Signature Algorithm: SHA256-RSA
  Signature: 3a 5f 7c 8d ... (256 bytes)

Certificate 1 (Intermediate):
  Subject: CN=Let's Encrypt Authority X3, O=Let's Encrypt, C=US
  Issuer: CN=DST Root CA X3, O=Digital Signature Trust Co.
  Validity: ...
  Public Key: RSA 2048 bits
  ...
```

**V√©rification par le client** :

```
√âtapes de v√©rification :

1. Validation de la cha√Æne de confiance :
   Server cert ‚Üí sign√© par ‚Üí Intermediate
   Intermediate ‚Üí sign√© par ‚Üí Root CA (dans trust store)

2. V√©rification des signatures :
   Pour chaque certificat :
     Hash = SHA256(Certificat)
     Signature_d√©chiffr√©e = RSA_decrypt(Signature, PublicKey_issuer)
     if Hash == Signature_d√©chiffr√©e: ‚úì
     else: ‚úó ERREUR

3. V√©rification du domaine :
   Hostname demand√© : www.example.com
   Certificate CN ou SAN : www.example.com
   Match ? ‚úì

4. V√©rification de la validit√© temporelle :
   Date actuelle : 2024-12-06
   Not Before : 2024-01-01 ‚úì
   Not After : 2025-01-01 ‚úì

5. V√©rification de r√©vocation (optionnel mais recommand√©) :
   OCSP check ou CRL check
   Status: Good ‚úì

Si toutes les v√©rifications r√©ussissent : ‚úì Certificat VALIDE
Sinon : ‚úó ERREUR, connexion abandonn√©e
```

#### ServerKeyExchange

**Quand est-il envoy√© ?**

```
ServerKeyExchange est envoy√© SI :
‚úì Cipher suite utilise DHE ou ECDHE (√©change de cl√©s √©ph√©m√®res)
‚úì Cipher suite utilise PSK (Pre-Shared Key)
‚úì Authentification serveur faible (SRP, etc.)

ServerKeyExchange N'EST PAS envoy√© SI :
‚úó Cipher suite utilise RSA key exchange
  (cl√© publique d√©j√† dans le certificat)
```

**Contenu pour ECDHE** :

```
ServerKeyExchange (ECDHE) {
    curve_params : Courbe elliptique utilis√©e (ex: secp256r1)
    public_key   : Point public √©ph√©m√®re du serveur (65 bytes)
    signature    : Signature de (client.random + server.random + params)
}
```

**Exemple ECDHE** :

```
EC Diffie-Hellman Server Params:
  Curve Type: named_curve (0x03)
  Named Curve: secp256r1 (0x0017)
  Pubkey Length: 65
  Pubkey: 04 a3 5f 7c 8d 9e 2b 4f ... (65 bytes)
    ‚Üë
    0x04 = point non compress√© (format standard)

Signature Algorithm: rsa_pkcs1_sha256
Signature Length: 256
Signature: c7 45 89 ab cd ef 12 34 ... (256 bytes)
```

**Calcul de la signature** :

```
Serveur calcule :

hash = SHA256(
    client_random +      // 32 bytes du ClientHello
    server_random +      // 32 bytes du ServerHello
    curve_params +       // Identifiant de la courbe
    server_public_key    // Point ECDH du serveur
)

signature = RSA_sign(hash, server_private_key)

Client v√©rifie :
hash_calculated = SHA256(client_random + server_random + params + pubkey)
hash_from_signature = RSA_verify(signature, server_public_key_from_cert)

if hash_calculated == hash_from_signature:
    ‚úì ServerKeyExchange authentique et non modifi√©
else:
    ‚úó ERREUR, possible MITM
```

**Pourquoi cette signature est cruciale** :

```
Sans signature :
Attaquant pourrait :
1. Intercepter ServerKeyExchange l√©gitime
2. Remplacer server_public_key par sa propre cl√©
3. √âtablir deux connexions s√©par√©es :
   Client ‚Üê Attaquant ‚Üí Server
4. D√©chiffrer tout le trafic

Avec signature :
Attaquant ne peut pas :
‚úó Forger la signature (sans cl√© priv√©e du serveur)
‚úó Modifier les param√®tres ECDH
‚Üí MITM d√©tect√© et bloqu√©
```

#### ServerHelloDone

Message simple indiquant la fin des messages du serveur.

```
ServerHelloDone {
    (vide - juste un signal)
}

Signification :
"J'ai envoy√© tout ce que j'avais √† envoyer.
√Ä ton tour, client !"
```

### Phase 3 : R√©ponse du client et √©tablissement des cl√©s

#### ClientKeyExchange

Le client g√©n√®re et envoie le mat√©riel pour d√©river le secret ma√Ætre.

**Pour ECDHE** :

```
ClientKeyExchange (ECDHE) {
    public_key : Point public √©ph√©m√®re du client (65 bytes)
}
```

**Exemple** :

```
EC Diffie-Hellman Client Params:
  Pubkey Length: 65
  Pubkey: 04 b2 7e 9a 3f 5c 6d 8e ... (65 bytes)
```

**Calcul du Pre-Master Secret** :

```
C√¥t√© client :
  client_private = random(256 bits)  // Cl√© priv√©e √©ph√©m√®re
  client_public = ECDH_generate_public(client_private, curve)
  ‚Üí Envoy√© dans ClientKeyExchange

  pre_master_secret = ECDH_compute(
      client_private,
      server_public  // Re√ßu dans ServerKeyExchange
  )

C√¥t√© serveur :
  server_private = random(256 bits)  // G√©n√©r√© pr√©c√©demment
  server_public = ECDH_generate_public(server_private, curve)
  ‚Üí Envoy√© dans ServerKeyExchange

  pre_master_secret = ECDH_compute(
      server_private,
      client_public  // Re√ßu dans ClientKeyExchange
  )

Magie ECDH :
Les deux parties calculent le M√äME pre_master_secret
Sans jamais l'avoir transmis sur le r√©seau !

pre_master_secret ‚âà 32 bytes (256 bits)
```

**Pour RSA (d√©pr√©ci√© en TLS 1.3)** :

```
ClientKeyExchange (RSA) {
    encrypted_pre_master_secret :
        RSA_encrypt(pre_master_secret, server_public_key)
}

Client g√©n√®re :
  pre_master_secret = random(48 bytes)
  Version TLS (2 bytes) + Random (46 bytes)

Client chiffre avec cl√© publique du serveur :
  encrypted = RSA_encrypt(pre_master_secret, server_pubkey)

Serveur d√©chiffre avec sa cl√© priv√©e :
  pre_master_secret = RSA_decrypt(encrypted, server_privkey)

Probl√®me de RSA key exchange :
‚úó Pas de forward secrecy
‚úó Si cl√© priv√©e serveur compromise dans le futur
  ‚Üí Toutes les sessions pass√©es peuvent √™tre d√©chiffr√©es
  ‚Üí Car pre_master_secret √©tait chiffr√© avec cl√© statique

‚Üí C'est pourquoi ECDHE est pr√©f√©r√© (et obligatoire en TLS 1.3)
```

#### D√©rivation du Master Secret

Le Pre-Master Secret est utilis√© pour d√©river le Master Secret.

```
PRF = Pseudo-Random Function (bas√©e sur HMAC-SHA256 en TLS 1.2)

master_secret = PRF(
    pre_master_secret,
    "master secret",
    client_random + server_random
)[0..47]  // 48 bytes (384 bits)

D√©tails :
- PRF utilise HMAC-SHA256 de mani√®re it√©rative
- Label "master secret" emp√™che confusion
- Randoms du client ET serveur inclus
- R√©sultat : 48 bytes de mat√©riel cryptographique
```

**Expansion du Master Secret en cl√©s de session** :

```
√Ä partir du master_secret, d√©river toutes les cl√©s n√©cessaires :

key_block = PRF(
    master_secret,
    "key expansion",
    server_random + client_random
)[0..required_length]

Extraction des cl√©s :
client_write_MAC_key = key_block[0..mac_key_length-1]
server_write_MAC_key = key_block[mac_key_length..2*mac_key_length-1]
client_write_key     = key_block[2*mac_key_length..2*mac_key_length+enc_key_length-1]
server_write_key     = key_block[...+enc_key_length..+2*enc_key_length-1]
client_write_IV      = key_block[..+iv_length]
server_write_IV      = key_block[..+2*iv_length]

Exemple pour AES-128-GCM :
- client_write_key : 16 bytes (AES-128)
- server_write_key : 16 bytes (AES-128)
- client_write_IV : 4 bytes (nonce fixe)
- server_write_IV : 4 bytes (nonce fixe)
- Pas de MAC keys s√©par√©es (GCM = AEAD)

Total : 40 bytes extraits du key_block
```

**R√©sultat de la d√©rivation** :

```
Apr√®s calcul, client ET serveur poss√®dent :

‚úì master_secret (48 bytes)
  Partag√©, jamais transmis

‚úì client_write_key (16 bytes pour AES-128)
  Client l'utilise pour CHIFFRER ses donn√©es
  Serveur l'utilise pour D√âCHIFFRER donn√©es du client

‚úì server_write_key (16 bytes pour AES-128)
  Serveur l'utilise pour CHIFFRER ses donn√©es
  Client l'utilise pour D√âCHIFFRER donn√©es du serveur

‚úì IVs (nonces)
  Pour le mode GCM

Communications bidirectionnelles s√©curis√©es possibles !
```

#### ChangeCipherSpec

Signal que les messages suivants seront chiffr√©s.

```
ChangeCipherSpec Protocol (TLS 1.2) {
    type : 0x01
}

Note : Ce n'est PAS un message Handshake Protocol
C'est un protocole s√©par√© (Record Layer)

Content Type: Change Cipher Spec (20)
Version: TLS 1.2
Length: 1
Message: 0x01

Signification :
"√Ä partir de maintenant, j'active le chiffrement
avec les cl√©s que nous venons de d√©river."
```

#### Finished

Premier message chiffr√©, v√©rifie l'int√©grit√© du handshake.

```
Finished {
    verify_data : PRF(
        master_secret,
        finished_label,  // "client finished" ou "server finished"
        Hash(all_handshake_messages)
    )[0..11]  // 12 bytes
}

Calcul :
1. Hash de TOUS les messages handshake pr√©c√©dents :
   ClientHello + ServerHello + Certificate +
   ServerKeyExchange + ServerHelloDone +
   ClientKeyExchange

2. D√©rivation avec PRF :
   verify_data = PRF(master_secret, label, hash)[0..11]

3. Chiffrement du message Finished avec les cl√©s d√©riv√©es

4. Transmission
```

**V√©rification par le r√©cepteur** :

```
Serveur re√ßoit Finished du client :

1. D√©chiffre le message
2. Extrait verify_data (12 bytes)
3. Recalcule ind√©pendamment :
   - Hash de tous les messages handshake
   - PRF(master_secret, "client finished", hash)
4. Compare :
   if verify_data_re√ßu == verify_data_calcul√©:
       ‚úì Handshake int√®gre, pas de MITM
   else:
       ‚úó ERREUR, handshake compromis
       ‚Üí Alerte "decrypt_error"
       ‚Üí Connexion ferm√©e

Cette v√©rification prouve :
‚úì Les deux parties ont le m√™me master_secret
‚úì Aucun message handshake n'a √©t√© modifi√©
‚úì Pas d'attaque MITM r√©ussie
```

**Finished √©chang√© dans les deux sens** :

```
Client ‚Üí Finished (avec "client finished" label)
Server ‚Üí Finished (avec "server finished" label)

Les deux v√©rifications doivent r√©ussir
Sinon : connexion abandonn√©e
```

### Phase 4 : Application Data

Une fois les deux messages Finished √©chang√©s et v√©rifi√©s, la connexion est √©tablie.

```
Application Data Records :
  Content Type: Application Data (23)
  Version: TLS 1.2
  Length: variable
  Encrypted Data: [donn√©es chiffr√©es]

Format d'un record chiffr√© (AES-GCM) :
+------------------+
| Nonce explicite  | 8 bytes
| Donn√©es chiffr√©es| Longueur variable
| Auth Tag (GCM)   | 16 bytes
+------------------+

Processus de chiffrement :
plaintext = "GET /index.html HTTP/1.1\r\n..."
nonce = nonce_fixe || nonce_explicite (12 bytes total)
ciphertext, tag = AES_GCM_encrypt(plaintext, key, nonce, AAD)

AAD (Additional Authenticated Data) :
  sequence_number || record_type || version || length
  ‚Üí Prot√®ge contre r√©ordering, replays, etc.
```

## TLS 1.3 Handshake : la r√©volution

TLS 1.3 a consid√©rablement simplifi√© et acc√©l√©r√© le handshake.

### Diff√©rences majeures vs TLS 1.2

```
TLS 1.2 :
- 2 RTT minimum
- RSA key exchange possible (pas de forward secrecy)
- ChangeCipherSpec protocol s√©par√©
- Beaucoup de cipher suites (bonnes et mauvaises)
- Renegotiation possible

TLS 1.3 :
- 1 RTT (ou 0-RTT pour reconnexions)
- ECDHE obligatoire (toujours forward secrecy)
- ChangeCipherSpec supprim√©
- 5 cipher suites seulement (tous AEAD)
- Renegotiation supprim√©e
- Plus de messages chiffr√©s d√®s le handshake
```

### Handshake TLS 1.3 (1-RTT)

```
Client                                               Server

ClientHello
+ key_share*
+ signature_algorithms*
+ psk_key_exchange_modes*
+ pre_shared_key*          -------->
                                                ServerHello
                                               + key_share*
                                          + pre_shared_key*
                                      {EncryptedExtensions}
                                      {CertificateRequest*}
                                             {Certificate*}
                                       {CertificateVerify*}
                                                 {Finished}
                           <--------       [Application Data*]
{Certificate*}
{CertificateVerify*}
{Finished}                 -------->
[Application Data]         <------->        [Application Data]

{...} = Messages chiffr√©s avec handshake traffic keys
[...] = Messages chiffr√©s avec application traffic keys
* = Messages optionnels ou conditionnels

Temps : 1 RTT au lieu de 2 !
```

### ClientHello TLS 1.3

**Diff√©rence cruciale** : Le client envoie **imm√©diatement** son key_share.

```
ClientHello (TLS 1.3) {
    legacy_version       : TLS 1.2 (compatibility)
    random               : 32 bytes
    legacy_session_id    : (pour compatibility)
    cipher_suites        : 5 cipher suites TLS 1.3
    legacy_compression   : null
    extensions           : REQUIRED en TLS 1.3
        supported_versions : TLS 1.3
        key_share         : ‚Üê NOUVEAU : cl√©s publiques d√©j√† envoy√©es !
            group: x25519
            key_exchange: [public key 32 bytes]
        signature_algorithms
        supported_groups
        ...
}
```

**Pourquoi key_share dans ClientHello ?**

```
TLS 1.2 :
Client ‚Üí "Je supporte ces courbes"
Server ‚Üí "J'ai choisi x25519, voici ma cl√© publique"
Client ‚Üí "Voici ma cl√© publique pour x25519"
‚Üí 2 RTT

TLS 1.3 :
Client ‚Üí "Je supporte ces courbes, ET voici d√©j√† mes cl√©s publiques
          pour x25519, secp256r1, et secp384r1"
Server ‚Üí "J'ai choisi x25519, voici ma cl√© publique,
          et voici d√©j√† des donn√©es chiffr√©es !"
‚Üí 1 RTT, √©conomie de 50% du temps !

Trade-off :
+ 50% plus rapide
- ClientHello plus gros (plusieurs key_shares)
- Si le serveur choisit une courbe non propos√©e :
  ‚Üí HelloRetryRequest (retour √† 2 RTT, rare)
```

### ServerHello et messages chiffr√©s

```
ServerHello (TLS 1.3) {
    legacy_version       : TLS 1.2
    random               : 32 bytes
    legacy_session_id    : (echo du client)
    cipher_suite         : TLS_AES_128_GCM_SHA256 (1 seul choisi)
    legacy_compression   : null
    extensions:
        supported_versions : TLS 1.3
        key_share         :
            group: x25519
            key_exchange: [server public key]
}

PUIS imm√©diatement (m√™me vol de paquets) :

{EncryptedExtensions}
{Certificate}
{CertificateVerify}
{Finished}
```

**D√©rivation des cl√©s en TLS 1.3** :

```
TLS 1.3 utilise HKDF (HMAC-based Key Derivation Function)

Phase 1 : Early Secret (pour 0-RTT)
early_secret = HKDF-Extract(0, PSK or 0)

Phase 2 : Handshake Secret
handshake_secret = HKDF-Extract(
    Derive-Secret(early_secret, "derived"),
    ECDHE_shared_secret
)

D√©rivation des cl√©s handshake :
client_handshake_traffic_secret = Derive-Secret(
    handshake_secret,
    "c hs traffic",
    ClientHello...ServerHello
)

server_handshake_traffic_secret = Derive-Secret(
    handshake_secret,
    "s hs traffic",
    ClientHello...ServerHello
)

‚Üí Utilis√©es pour chiffrer Certificate, CertificateVerify, Finished !

Phase 3 : Master Secret
master_secret = HKDF-Extract(
    Derive-Secret(handshake_secret, "derived"),
    0
)

Phase 4 : Application Secrets
client_application_traffic_secret_0 = Derive-Secret(
    master_secret,
    "c ap traffic",
    ClientHello...server Finished
)

server_application_traffic_secret_0 = Derive-Secret(
    master_secret,
    "s ap traffic",
    ClientHello...server Finished
)

‚Üí Utilis√©es pour chiffrer Application Data
```

**Cons√©quence importante** :

```
En TLS 1.3, d√®s le ServerHello :
‚úì Certificate chiffr√©
‚úì CertificateVerify chiffr√©
‚úì Finished chiffr√©

Avantages :
+ Confidentialit√© accrue (serveur identity prot√©g√©e)
+ Moins de m√©tadonn√©es expos√©es
+ Protection contre certaines attaques

Seuls messages en clair :
- ClientHello (incluant SNI ‚Üê encore un probl√®me)
- ServerHello
```

### 0-RTT Mode (Zero Round-Trip Time)

**Le plus rapide possible** : donn√©es envoy√©es AVANT la fin du handshake !

```
Pr√©requis : Session pr√©c√©dente avec le m√™me serveur (PSK disponible)

Client                                               Server

ClientHello
+ early_data
+ key_share*
+ psk_key_exchange_modes
+ pre_shared_key
(0-RTT Application Data)   -------->
                                                ServerHello
                                           + pre_shared_key
                                               + key_share*
                                      {EncryptedExtensions}
                                              + early_data*
                                                 {Finished}
                           <--------       [Application Data*]
(EndOfEarlyData)
{Finished}                 -------->
[Application Data]         <------->        [Application Data]

Les donn√©es applicatives sont envoy√©es dans le PREMIER paquet !
0 RTT d'attente avant d'envoyer la requ√™te HTTP !
```

**Calcul des cl√©s 0-RTT** :

```
Depuis la session pr√©c√©dente, le client a :
- resumption_master_secret (ou PSK)

Client d√©rive :
early_secret = HKDF-Extract(0, PSK)

client_early_traffic_secret = Derive-Secret(
    early_secret,
    "c e traffic",
    ClientHello
)

‚Üí Utilis√© pour chiffrer 0-RTT Application Data

Serveur, en recevant ClientHello avec PSK :
‚Üí D√©rive la m√™me client_early_traffic_secret
‚Üí D√©chiffre les donn√©es 0-RTT
‚Üí Les traite imm√©diatement
```

**Risques du 0-RTT** :

```
Probl√®me majeur : Replay Attack

Attaquant capture le paquet ClientHello + 0-RTT Data :
1. Copie exacte du paquet
2. Renvoie le paquet au serveur
3. Serveur accepte et traite √† nouveau

Exemple catastrophique :
0-RTT Data : "POST /transfer?amount=1000&to=attacker"

Si rejouable :
‚Üí Transfert ex√©cut√© plusieurs fois
‚Üí Perte financi√®re

Protection :
‚úì Serveur DOIT rejeter requ√™tes non-idempotentes en 0-RTT
‚úì Seulement GET, HEAD, OPTIONS acceptables
‚úì Anti-replay mechanisms (timestamps, single-use tickets)
‚úì Applications doivent √™tre conscientes du risque

Configuration Nginx :
ssl_early_data on;
‚Üí Serveur accepte 0-RTT

Dans l'application :
if ($http_early_data == "1") {
    # Requ√™te 0-RTT, √™tre prudent !
    # Rejeter POST/PUT/DELETE
}
```

**Performance gain** :

```
Latence r√©seau : 50ms (exemple)

HTTP/1.1 sans TLS :
TCP handshake : 50ms (1 RTT)
Request ‚Üí Response : 50ms (1 RTT)
Total : 100ms

HTTPS TLS 1.2 :
TCP handshake : 50ms
TLS handshake : 100ms (2 RTT)
Request ‚Üí Response : 50ms
Total : 200ms

HTTPS TLS 1.3 (premi√®re connexion) :
TCP handshake : 50ms
TLS handshake : 50ms (1 RTT)
Request ‚Üí Response : 50ms
Total : 150ms
‚Üí 25% plus rapide que TLS 1.2

HTTPS TLS 1.3 avec 0-RTT (reconnexion) :
TCP handshake : 50ms
TLS + Request dans m√™me paquet : 0ms
Response : 50ms
Total : 100ms
‚Üí 50% plus rapide que TLS 1.2
‚Üí Aussi rapide que HTTP non chiffr√© !

Sur mobile (latence ~200ms) :
TLS 1.2 : 600ms
TLS 1.3 : 400ms  (-33%)
TLS 1.3 0-RTT : 200ms  (-67%)
```

## Analyse de captures r√©seau r√©elles

### Capture Wireshark d'un handshake TLS 1.2 complet

```
Frame 1: TCP SYN
  192.168.1.100:54321 ‚Üí 93.184.216.34:443
  Seq=0 Len=0

Frame 2: TCP SYN-ACK
  93.184.216.34:443 ‚Üí 192.168.1.100:54321
  Seq=0 Ack=1 Len=0

Frame 3: TCP ACK
  192.168.1.100:54321 ‚Üí 93.184.216.34:443
  Seq=1 Ack=1 Len=0

[TCP √©tabli, d√©but TLS]

Frame 4: Client Hello
  TLSv1.2 Record Layer: Handshake Protocol: Client Hello
    Content Type: Handshake (22)
    Version: TLS 1.0 (0x0301)
    Length: 512
    Handshake Protocol: Client Hello
      Version: TLS 1.2 (0x0303)
      Random: 675270a5b3c4d5e6...
      Cipher Suites (18 suites)
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        ...
      Extension: server_name
        Server Name: www.example.com
      Extension: supported_groups
        x25519, secp256r1, secp384r1

Frame 5: Server Hello, Certificate, Server Key Exchange, Server Hello Done
  TLSv1.2 Record Layer: Handshake Protocol: Multiple Handshake Messages
    Handshake Protocol: Server Hello
      Version: TLS 1.2
      Random: 3f8a9c2e5d7b4f6a...
      Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256

    Handshake Protocol: Certificate
      Certificates Length: 3045
      Certificate: www.example.com (1521 bytes)
      Certificate: Intermediate CA (1524 bytes)

    Handshake Protocol: Server Key Exchange
      EC Diffie-Hellman Server Params
        Named Curve: secp256r1
        Pubkey: 04a35f7c8d9e2b4f... (65 bytes)
      Signature Algorithm: rsa_pkcs1_sha256
      Signature: c74589abcdef1234... (256 bytes)

    Handshake Protocol: Server Hello Done

Frame 6: Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message
  Handshake Protocol: Client Key Exchange
    EC Diffie-Hellman Client Params
      Pubkey: 04b27e9a3f5c6d8e... (65 bytes)

  Change Cipher Spec Protocol
    Change Cipher Spec Message

  Handshake Protocol: Encrypted Handshake Message
    [Encrypted Finished message]
    Opaque Data: 9f3a7c2e5d8b4f1a...

Frame 7: New Session Ticket, Change Cipher Spec, Encrypted Handshake Message
  [New Session Ticket - pour session resumption future]

  Change Cipher Spec Protocol

  Handshake Protocol: Encrypted Handshake Message
    [Encrypted Finished message from server]

[Handshake complet, d√©but Application Data]

Frame 8: Application Data
  TLSv1.2 Record Layer: Application Data Protocol
    Content Type: Application Data (23)
    Encrypted Application Data: 8a3f9c2e7d5b...
    [HTTP request chiffr√©]

Frame 9: Application Data
  TLSv1.2 Record Layer: Application Data Protocol
    [HTTP response chiffr√©]
```

### Analyse temporelle

```
Frame   Time        Delta   Description
1       0.000000    0.000   TCP SYN
2       0.025123    0.025   TCP SYN-ACK         ‚Üê 25ms (1 RTT/2)
3       0.025234    0.000   TCP ACK
4       0.025456    0.000   Client Hello
5       0.075889    0.050   Server Hello...     ‚Üê 50ms (1 RTT)
6       0.076012    0.000   Client Key Exch...
7       0.126445    0.050   Change Cipher...    ‚Üê 50ms (1 RTT)
8       0.126678    0.000   Application Data
9       0.177012    0.050   App Data Response   ‚Üê 50ms (1 RTT)

Total handshake : 100ms (2 RTT pour TLS 1.2)
First byte : 177ms (TCP + TLS + HTTP)

Avec TLS 1.3 :
Total handshake : 50ms (1 RTT)
First byte : 127ms (30% plus rapide)

Avec TLS 1.3 + 0-RTT :
Total handshake : 0ms
First byte : 77ms (60% plus rapide)
```

### D√©chiffrement de captures avec cl√©s

**Wireshark peut d√©chiffrer TLS si on lui fournit les cl√©s** :

```
M√©thode 1 : SSLKEYLOGFILE (recommand√©)

export SSLKEYLOGFILE=/tmp/sslkeys.log
firefox  # ou chrome

Le navigateur √©crira :
CLIENT_RANDOM 675270a5b3c4d5e6... master_secret...
CLIENT_RANDOM 8f3a9c2e5d7b4f6a... master_secret...
...

Dans Wireshark :
Edit ‚Üí Preferences ‚Üí Protocols ‚Üí TLS
‚Üí (Pre)-Master-Secret log filename: /tmp/sslkeys.log

Wireshark d√©chiffre automatiquement tout le trafic !

M√©thode 2 : Cl√© priv√©e du serveur (seulement pour RSA key exchange)
‚Üí Ne fonctionne PAS avec ECDHE (forward secrecy)
```

**Exemple de d√©chiffrement** :

```
Avant (avec cl√©s) :
Frame 8: Application Data
  Decrypted Application Data:
    Hypertext Transfer Protocol
      GET /index.html HTTP/1.1\r\n
      Host: www.example.com\r\n
      User-Agent: Mozilla/5.0...\r\n
      Cookie: session=abc123xyz789\r\n
      \r\n

Sans cl√©s :
Frame 8: Application Data
  Encrypted Application Data: 8a 3f 9c 2e 7d 5b 4f ...
  [Cannot decrypt - no keys available]
```

## Probl√®mes courants et debugging

### Erreur : Certificate Verify Failed

```
Erreur navigateur :
"Your connection is not private"
NET::ERR_CERT_AUTHORITY_INVALID

Causes possibles :

1. Certificat auto-sign√© :
   Subject: CN=localhost
   Issuer: CN=localhost  ‚Üê M√™me que subject, auto-sign√©
   ‚Üí Pas dans trust store du client

2. Certificat expir√© :
   Not After: 2023-01-01 00:00:00 UTC
   Date actuelle : 2024-12-06
   ‚Üí Certificat p√©rim√©

3. Nom de domaine incorrect :
   Certificat CN/SAN: www.example.com
   URL demand√©e : example.com
   ‚Üí Nom ne correspond pas

4. Cha√Æne de certification incompl√®te :
   Serveur envoie : [End-entity cert]
   Manque : [Intermediate cert]
   ‚Üí Client ne peut pas valider jusqu'√† root

5. Autorit√© de certification inconnue :
   Issuer: CN=MyCompanyCA
   ‚Üí MyCompanyCA pas dans trust store

Debug :
openssl s_client -connect example.com:443 -showcerts
‚Üí Affiche certificats re√ßus
‚Üí V√©rifie dates, issuer, chain
```

### Erreur : Handshake Failure

```
Alerte TLS : Handshake Failure (40)

Causes :

1. Aucune cipher suite commune :
   Client supporte : A, B, C
   Serveur supporte : D, E, F
   Intersection : vide
   ‚Üí Pas d'accord possible

2. Version TLS incompatible :
   Client : TLS 1.3 seulement
   Serveur : TLS 1.2 maximum
   ‚Üí Pas de version commune

3. Erreur de signature :
   ServerKeyExchange signature invalide
   ‚Üí Possible MITM ou corruption

Debug :
openssl s_client -connect example.com:443 -tls1_2
‚Üí Force TLS 1.2

openssl s_client -connect example.com:443 -cipher 'ECDHE-RSA-AES128-GCM-SHA256'
‚Üí Force une cipher suite sp√©cifique
```

### Erreur : SNI (Server Name Indication) manquant

```
Probl√®me :
Serveur h√©berge plusieurs sites (virtual hosting) :
- www.site1.com
- www.site2.com
Tous sur la m√™me IP : 203.0.113.50

Sans SNI :
Client ‚Üí Connexion √† 203.0.113.50:443
Server ‚Üí Quel certificat envoyer ??
       ‚Üí Envoie certificat par d√©faut (peut-√™tre site1)
Client ‚Üí Demande www.site2.com
       ‚Üí Certificat ne correspond pas
       ‚Üí Erreur

Avec SNI :
Client ‚Üí ClientHello avec extension SNI: www.site2.com
Server ‚Üí Identifie le site demand√©
       ‚Üí Envoie le bon certificat (site2)
Client ‚Üí V√©rifie : ‚úì Nom correspond

Vieux clients sans SNI :
- Anciennes versions IE, Android
- Certains outils (wget ancien)
‚Üí Incompatibles avec virtual hosting TLS

Curl avec SNI :
curl https://www.site2.com  ‚úì SNI automatique

Curl sans SNI (pour tester) :
curl --resolve www.site2.com:443:203.0.113.50 https://www.site2.com
```

### Performance : Handshake lent

```
Sympt√¥me : Handshake prend plusieurs secondes

Causes :

1. Latence r√©seau √©lev√©e :
   2 RTT √ó 200ms = 400ms minimum
   Solution : TLS 1.3 (1 RTT)

2. Op√©rations RSA lentes :
   RSA 4096 bits : 10-50ms par op√©ration
   Solution : ECDSA (10√ó plus rapide), ou RSA 2048 max

3. Pas d'acc√©l√©ration mat√©rielle :
   AES software : lent
   Solution : Activer AES-NI (CPU), ou hardware crypto

4. Validation OCSP lente :
   Requ√™te OCSP vers CA : peut timeout
   Solution : OCSP Stapling

5. Charge CPU serveur :
   Serveur surcharg√©
   Solution : Load balancing, + de ressources

Monitoring :
time openssl s_client -connect example.com:443 </dev/null

Benchmark :
openssl speed rsa2048
openssl speed aes-128-gcm
‚Üí Mesure performance crypto du CPU
```

### Alert Messages TLS

```
Alerts courantes :

close_notify (0) :
  Fermeture propre de connexion
  Normal

unexpected_message (10) :
  Message re√ßu dans mauvais √©tat
  Bug d'impl√©mentation ou attaque

bad_record_mac (20) :
  MAC invalide (TLS 1.2)
  Corruption ou cl√©s incorrectes

record_overflow (22) :
  Record TLS trop grand (>16384 bytes)
  Fragmentation n√©cessaire

handshake_failure (40) :
  Handshake impossible
  Incompatibilit√© param√®tres

bad_certificate (42) :
  Certificat malform√©

unsupported_certificate (43) :
  Type de certificat non support√©

certificate_revoked (44) :
  Certificat r√©voqu√© (CRL/OCSP)

certificate_expired (45) :
  Certificat p√©rim√©

certificate_unknown (46) :
  Probl√®me certificat non sp√©cifi√©

illegal_parameter (47) :
  Param√®tre invalide dans handshake

unknown_ca (48) :
  CA non reconnue

access_denied (49) :
  Acc√®s refus√© (client cert invalide)

decode_error (50) :
  Message mal form√©

decrypt_error (51) :
  D√©chiffrement √©chou√©

protocol_version (70) :
  Version TLS non support√©e

insufficient_security (71) :
  Cipher suite trop faible

internal_error (80) :
  Erreur interne serveur

inappropriate_fallback (86) :
  Downgrade attack d√©tect√©

no_renegotiation (100) :
  Ren√©gociation refus√©e
```

## Optimisations et bonnes pratiques

### Configuration serveur recommand√©e (2024)

```nginx
# Nginx configuration

server {
    listen 443 ssl http2;
    server_name www.example.com;

    # Certificats
    ssl_certificate /path/to/fullchain.pem;
    ssl_certificate_key /path/to/privkey.pem;

    # Protocoles
    ssl_protocols TLSv1.2 TLSv1.3;

    # Cipher suites (ordre serveur prioritaire)
    ssl_prefer_server_ciphers on;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305';

    # DH parameters (pour DHE si utilis√©)
    ssl_dhparam /path/to/dhparam.pem;

    # Session cache (performance)
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_session_tickets on;

    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    ssl_trusted_certificate /path/to/chain.pem;
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;

    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

    # TLS 1.3 early data (0-RTT)
    ssl_early_data on;

    location / {
        # V√©rifier early data pour requ√™tes sensibles
        if ($ssl_early_data = "1") {
            set $block_early_data "${request_method}:${uri}";
        }
        if ($block_early_data ~* "^(POST|PUT|DELETE):") {
            return 425; # Too Early
        }

        # ...
    }
}
```

### Test de configuration

```bash
# Test avec testssl.sh
./testssl.sh https://www.example.com

# Test avec SSL Labs
# https://www.ssllabs.com/ssltest/

# Test rapidement les cipher suites
nmap --script ssl-enum-ciphers -p 443 example.com

# Test de la cha√Æne de certificats
openssl s_client -connect example.com:443 -showcerts

# Test OCSP stapling
openssl s_client -connect example.com:443 -status
```

## Conclusion

Le handshake TLS est le m√©canisme fondamental qui rend Internet s√©curis√©. Sa compr√©hension approfondie permet de :

**Diagnostiquer efficacement** :
- Probl√®mes de connexion HTTPS
- Erreurs de certificats
- Incompatibilit√©s de version

**Optimiser les performances** :
- R√©duire la latence (TLS 1.3, 0-RTT)
- Am√©liorer le d√©bit (session resumption)
- Minimiser la charge CPU (bonnes cipher suites)

**Renforcer la s√©curit√©** :
- Choisir les bons algorithmes
- √âviter les configurations faibles
- D√©tecter les attaques

**Points cl√©s √† retenir** :

```
TLS 1.2 :
‚úì 2 RTT pour handshake complet
‚úì RSA ou ECDHE key exchange
‚úì Largement d√©ploy√© et compatible
‚úì Standard actuel (2024)

TLS 1.3 :
‚úì 1 RTT (ou 0-RTT)
‚úì ECDHE obligatoire (forward secrecy)
‚úì Plus simple et plus s√ªr
‚úì Adoption croissante (~40-50%)

Messages critiques :
‚úì ClientHello : Capacit√©s client
‚úì ServerHello : Choix serveur
‚úì Certificate : Identit√© serveur
‚úì ServerKeyExchange : Param√®tres ECDHE (TLS 1.2)
‚úì ClientKeyExchange : Cl√© publique client
‚úì Finished : V√©rification int√©grit√©

S√©curit√© :
‚úì Cha√Æne de certification v√©rifi√©e
‚úì Forward secrecy avec ECDHE
‚úì Finished message prouve int√©grit√©
‚úì Impossible de MITM un handshake valide
```

Dans la prochaine section (6.4.2), nous approfondirons les certificats et la PKI : comment les certificats sont √©mis, la cha√Æne de confiance, la r√©vocation, et les autorit√©s de certification.

‚è≠Ô∏è [Certificats et PKI](/06-securite/04.2-tls-certificats-pki.md)
